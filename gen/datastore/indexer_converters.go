// Code generated by protoc-gen-dal-datastore. DO NOT EDIT.
package datastore

import (
	models "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/models"

	"fmt"

	"github.com/panyam/protoc-gen-dal/pkg/converters"
)

// IndexStateToIndexStateDatastore converts a IndexState to IndexStateDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source IndexState message to convert from
//   - dest: Destination IndexStateDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexStateDatastore entity
//   - Error if conversion fails
func IndexStateToIndexStateDatastore(
	src *models.IndexState,
	dest *IndexStateDatastore,
	decorator func(*models.IndexState, *IndexStateDatastore) error,
) (out *IndexStateDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IndexStateDatastore{}
	}

	// Initialize struct with inline values
	*dest = IndexStateDatastore{
		EntityType:     src.EntityType,
		EntityId:       src.EntityId,
		IndexType:      src.IndexType,
		NeedsIndexing:  src.NeedsIndexing,
		Status:         src.Status,
		LastError:      src.LastError,
		IdempotencyKey: src.IdempotencyKey,
		RetryCount:     src.RetryCount,
	}
	out = dest

	if src.CreatedAt != nil {
		out.CreatedAt = converters.TimestampToTime(src.CreatedAt)
	}

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.IndexedAt != nil {
		out.IndexedAt = converters.TimestampToTime(src.IndexedAt)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexStateFromIndexStateDatastore converts a IndexStateDatastore back to IndexState.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination IndexState message (if nil, a new one is created)
//   - src: Source IndexStateDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexState message
//   - Error if conversion fails
func IndexStateFromIndexStateDatastore(
	dest *models.IndexState,
	src *IndexStateDatastore,
	decorator func(*models.IndexState, *IndexStateDatastore) error,
) (out *models.IndexState, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IndexState{}
	}

	// Initialize struct with inline values
	*dest = models.IndexState{
		EntityType:     src.EntityType,
		EntityId:       src.EntityId,
		IndexType:      src.IndexType,
		CreatedAt:      converters.TimeToTimestamp(src.CreatedAt),
		UpdatedAt:      converters.TimeToTimestamp(src.UpdatedAt),
		IndexedAt:      converters.TimeToTimestamp(src.IndexedAt),
		NeedsIndexing:  src.NeedsIndexing,
		Status:         src.Status,
		LastError:      src.LastError,
		IdempotencyKey: src.IdempotencyKey,
		RetryCount:     src.RetryCount,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexRecordToIndexRecordDatastore converts a IndexRecord to IndexRecordDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source IndexRecord message to convert from
//   - dest: Destination IndexRecordDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexRecordDatastore entity
//   - Error if conversion fails
func IndexRecordToIndexRecordDatastore(
	src *models.IndexRecord,
	dest *IndexRecordDatastore,
	decorator func(*models.IndexRecord, *IndexRecordDatastore) error,
) (out *IndexRecordDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IndexRecordDatastore{}
	}

	// Initialize struct with inline values
	*dest = IndexRecordDatastore{
		EntityId:     src.EntityId,
		IndexerTypes: src.IndexerTypes,
	}
	out = dest

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.EntityData != nil {
		out.EntityData, err = converters.AnyToBytes(src.EntityData)
		if err != nil {
			return nil, fmt.Errorf("converting EntityData: %w", err)
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexRecordFromIndexRecordDatastore converts a IndexRecordDatastore back to IndexRecord.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination IndexRecord message (if nil, a new one is created)
//   - src: Source IndexRecordDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexRecord message
//   - Error if conversion fails
func IndexRecordFromIndexRecordDatastore(
	dest *models.IndexRecord,
	src *IndexRecordDatastore,
	decorator func(*models.IndexRecord, *IndexRecordDatastore) error,
) (out *models.IndexRecord, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IndexRecord{}
	}

	// Initialize struct with inline values
	*dest = models.IndexRecord{
		EntityId:     src.EntityId,
		UpdatedAt:    converters.TimeToTimestamp(src.UpdatedAt),
		IndexerTypes: src.IndexerTypes,
	}
	out = dest

	out.EntityData, err = converters.BytesToAny(src.EntityData)
	if err != nil {
		return nil, fmt.Errorf("converting EntityData: %w", err)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexRecordsLROToIndexRecordsLRODatastore converts a IndexRecordsLRO to IndexRecordsLRODatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source IndexRecordsLRO message to convert from
//   - dest: Destination IndexRecordsLRODatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexRecordsLRODatastore entity
//   - Error if conversion fails
func IndexRecordsLROToIndexRecordsLRODatastore(
	src *models.IndexRecordsLRO,
	dest *IndexRecordsLRODatastore,
	decorator func(*models.IndexRecordsLRO, *IndexRecordsLRODatastore) error,
) (out *IndexRecordsLRODatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IndexRecordsLRODatastore{}
	}

	// Initialize struct with inline values
	*dest = IndexRecordsLRODatastore{
		LroId:       src.LroId,
		EntityType:  src.EntityType,
		CallbackUrl: src.CallbackUrl,
	}
	out = dest

	if src.CreatedAt != nil {
		out.CreatedAt = converters.TimestampToTime(src.CreatedAt)
	}

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.Records != nil {
		out.Records = make([]IndexRecordDatastore, len(src.Records))
		for i, item := range src.Records {
			_, err = IndexRecordToIndexRecordDatastore(item, &out.Records[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Records[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexRecordsLROFromIndexRecordsLRODatastore converts a IndexRecordsLRODatastore back to IndexRecordsLRO.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination IndexRecordsLRO message (if nil, a new one is created)
//   - src: Source IndexRecordsLRODatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexRecordsLRO message
//   - Error if conversion fails
func IndexRecordsLROFromIndexRecordsLRODatastore(
	dest *models.IndexRecordsLRO,
	src *IndexRecordsLRODatastore,
	decorator func(*models.IndexRecordsLRO, *IndexRecordsLRODatastore) error,
) (out *models.IndexRecordsLRO, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IndexRecordsLRO{}
	}

	// Initialize struct with inline values
	*dest = models.IndexRecordsLRO{
		LroId:       src.LroId,
		EntityType:  src.EntityType,
		CreatedAt:   converters.TimeToTimestamp(src.CreatedAt),
		UpdatedAt:   converters.TimeToTimestamp(src.UpdatedAt),
		CallbackUrl: src.CallbackUrl,
	}
	out = dest

	if src.Records != nil {
		out.Records = make([]*models.IndexRecord, len(src.Records))
		for i, item := range src.Records {
			out.Records[i], err = IndexRecordFromIndexRecordDatastore(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Records[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}
