// Code generated by protoc-gen-dal-datastore. DO NOT EDIT.
package datastore

import (
	models "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/models"

	"fmt"

	"github.com/panyam/protoc-gen-dal/pkg/converters"
)

// IndexInfoToIndexInfoDatastore converts a IndexInfo to IndexInfoDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source IndexInfo message to convert from
//   - dest: Destination IndexInfoDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexInfoDatastore entity
//   - Error if conversion fails
func IndexInfoToIndexInfoDatastore(
	src *models.IndexInfo,
	dest *IndexInfoDatastore,
	decorator func(*models.IndexInfo, *IndexInfoDatastore) error,
) (out *IndexInfoDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IndexInfoDatastore{}
	}

	// Initialize struct with inline values
	*dest = IndexInfoDatastore{
		NeedsIndexing: src.NeedsIndexing,
	}
	out = dest

	if src.LastUpdatedAt != nil {
		out.LastUpdatedAt = converters.TimestampToTime(src.LastUpdatedAt)
	}

	if src.LastIndexedAt != nil {
		out.LastIndexedAt = converters.TimestampToTime(src.LastIndexedAt)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexInfoFromIndexInfoDatastore converts a IndexInfoDatastore back to IndexInfo.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination IndexInfo message (if nil, a new one is created)
//   - src: Source IndexInfoDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IndexInfo message
//   - Error if conversion fails
func IndexInfoFromIndexInfoDatastore(
	dest *models.IndexInfo,
	src *IndexInfoDatastore,
	decorator func(*models.IndexInfo, *IndexInfoDatastore) error,
) (out *models.IndexInfo, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IndexInfo{}
	}

	// Initialize struct with inline values
	*dest = models.IndexInfo{
		LastUpdatedAt: converters.TimeToTimestamp(src.LastUpdatedAt),
		LastIndexedAt: converters.TimeToTimestamp(src.LastIndexedAt),
		NeedsIndexing: src.NeedsIndexing,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// TileToTileDatastore converts a Tile to TileDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source Tile message to convert from
//   - dest: Destination TileDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted TileDatastore entity
//   - Error if conversion fails
func TileToTileDatastore(
	src *models.Tile,
	dest *TileDatastore,
	decorator func(*models.Tile, *TileDatastore) error,
) (out *TileDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &TileDatastore{}
	}

	// Initialize struct with inline values
	*dest = TileDatastore{
		Q:                src.Q,
		R:                src.R,
		TileType:         src.TileType,
		Player:           src.Player,
		Shortcut:         src.Shortcut,
		LastActedTurn:    src.LastActedTurn,
		LastToppedupTurn: src.LastToppedupTurn,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// TileFromTileDatastore converts a TileDatastore back to Tile.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination Tile message (if nil, a new one is created)
//   - src: Source TileDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted Tile message
//   - Error if conversion fails
func TileFromTileDatastore(
	dest *models.Tile,
	src *TileDatastore,
	decorator func(*models.Tile, *TileDatastore) error,
) (out *models.Tile, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Tile{}
	}

	// Initialize struct with inline values
	*dest = models.Tile{
		Q:                src.Q,
		R:                src.R,
		TileType:         src.TileType,
		Player:           src.Player,
		Shortcut:         src.Shortcut,
		LastActedTurn:    src.LastActedTurn,
		LastToppedupTurn: src.LastToppedupTurn,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// CrossingToCrossingDatastore converts a Crossing to CrossingDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source Crossing message to convert from
//   - dest: Destination CrossingDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted CrossingDatastore entity
//   - Error if conversion fails
func CrossingToCrossingDatastore(
	src *models.Crossing,
	dest *CrossingDatastore,
	decorator func(*models.Crossing, *CrossingDatastore) error,
) (out *CrossingDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &CrossingDatastore{}
	}

	// Initialize struct with inline values
	*dest = CrossingDatastore{
		Type:       src.Type,
		ConnectsTo: src.ConnectsTo,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// CrossingFromCrossingDatastore converts a CrossingDatastore back to Crossing.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination Crossing message (if nil, a new one is created)
//   - src: Source CrossingDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted Crossing message
//   - Error if conversion fails
func CrossingFromCrossingDatastore(
	dest *models.Crossing,
	src *CrossingDatastore,
	decorator func(*models.Crossing, *CrossingDatastore) error,
) (out *models.Crossing, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Crossing{}
	}

	// Initialize struct with inline values
	*dest = models.Crossing{
		Type:       src.Type,
		ConnectsTo: src.ConnectsTo,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// UnitToUnitDatastore converts a Unit to UnitDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source Unit message to convert from
//   - dest: Destination UnitDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted UnitDatastore entity
//   - Error if conversion fails
func UnitToUnitDatastore(
	src *models.Unit,
	dest *UnitDatastore,
	decorator func(*models.Unit, *UnitDatastore) error,
) (out *UnitDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &UnitDatastore{}
	}

	// Initialize struct with inline values
	*dest = UnitDatastore{
		Q:                       src.Q,
		R:                       src.R,
		Player:                  src.Player,
		UnitType:                src.UnitType,
		Shortcut:                src.Shortcut,
		AvailableHealth:         src.AvailableHealth,
		DistanceLeft:            src.DistanceLeft,
		LastActedTurn:           src.LastActedTurn,
		LastToppedupTurn:        src.LastToppedupTurn,
		AttacksReceivedThisTurn: src.AttacksReceivedThisTurn,
		ProgressionStep:         src.ProgressionStep,
		ChosenAlternative:       src.ChosenAlternative,
		CaptureStartedTurn:      src.CaptureStartedTurn,
	}
	out = dest

	if src.AttackHistory != nil {
		out.AttackHistory = make([]AttackRecordDatastore, len(src.AttackHistory))
		for i, item := range src.AttackHistory {
			_, err = AttackRecordToAttackRecordDatastore(item, &out.AttackHistory[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting AttackHistory[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// UnitFromUnitDatastore converts a UnitDatastore back to Unit.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination Unit message (if nil, a new one is created)
//   - src: Source UnitDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted Unit message
//   - Error if conversion fails
func UnitFromUnitDatastore(
	dest *models.Unit,
	src *UnitDatastore,
	decorator func(*models.Unit, *UnitDatastore) error,
) (out *models.Unit, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Unit{}
	}

	// Initialize struct with inline values
	*dest = models.Unit{
		Q:                       src.Q,
		R:                       src.R,
		Player:                  src.Player,
		UnitType:                src.UnitType,
		Shortcut:                src.Shortcut,
		AvailableHealth:         src.AvailableHealth,
		DistanceLeft:            src.DistanceLeft,
		LastActedTurn:           src.LastActedTurn,
		LastToppedupTurn:        src.LastToppedupTurn,
		AttacksReceivedThisTurn: src.AttacksReceivedThisTurn,
		ProgressionStep:         src.ProgressionStep,
		ChosenAlternative:       src.ChosenAlternative,
		CaptureStartedTurn:      src.CaptureStartedTurn,
	}
	out = dest

	if src.AttackHistory != nil {
		out.AttackHistory = make([]*models.AttackRecord, len(src.AttackHistory))
		for i, item := range src.AttackHistory {
			out.AttackHistory[i], err = AttackRecordFromAttackRecordDatastore(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting AttackHistory[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// AttackRecordToAttackRecordDatastore converts a AttackRecord to AttackRecordDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source AttackRecord message to convert from
//   - dest: Destination AttackRecordDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted AttackRecordDatastore entity
//   - Error if conversion fails
func AttackRecordToAttackRecordDatastore(
	src *models.AttackRecord,
	dest *AttackRecordDatastore,
	decorator func(*models.AttackRecord, *AttackRecordDatastore) error,
) (out *AttackRecordDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &AttackRecordDatastore{}
	}

	// Initialize struct with inline values
	*dest = AttackRecordDatastore{
		Q:          src.Q,
		R:          src.R,
		IsRanged:   src.IsRanged,
		TurnNumber: src.TurnNumber,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// AttackRecordFromAttackRecordDatastore converts a AttackRecordDatastore back to AttackRecord.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination AttackRecord message (if nil, a new one is created)
//   - src: Source AttackRecordDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted AttackRecord message
//   - Error if conversion fails
func AttackRecordFromAttackRecordDatastore(
	dest *models.AttackRecord,
	src *AttackRecordDatastore,
	decorator func(*models.AttackRecord, *AttackRecordDatastore) error,
) (out *models.AttackRecord, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.AttackRecord{}
	}

	// Initialize struct with inline values
	*dest = models.AttackRecord{
		Q:          src.Q,
		R:          src.R,
		IsRanged:   src.IsRanged,
		TurnNumber: src.TurnNumber,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldToWorldDatastore converts a World to WorldDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source World message to convert from
//   - dest: Destination WorldDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted WorldDatastore entity
//   - Error if conversion fails
func WorldToWorldDatastore(
	src *models.World,
	dest *WorldDatastore,
	decorator func(*models.World, *WorldDatastore) error,
) (out *WorldDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &WorldDatastore{}
	}

	// Initialize struct with inline values
	*dest = WorldDatastore{
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	if src.CreatedAt != nil {
		out.CreatedAt = converters.TimestampToTime(src.CreatedAt)
	}

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.DefaultGameConfig != nil {
		_, err = GameConfigurationToGameConfigurationDatastore(src.DefaultGameConfig, &out.DefaultGameConfig, nil)
		if err != nil {
			return nil, fmt.Errorf("converting DefaultGameConfig: %w", err)
		}
	}
	if src.SearchIndexInfo != nil {
		_, err = IndexInfoToIndexInfoDatastore(src.SearchIndexInfo, &out.SearchIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldFromWorldDatastore converts a WorldDatastore back to World.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination World message (if nil, a new one is created)
//   - src: Source WorldDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted World message
//   - Error if conversion fails
func WorldFromWorldDatastore(
	dest *models.World,
	src *WorldDatastore,
	decorator func(*models.World, *WorldDatastore) error,
) (out *models.World, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.World{}
	}

	// Initialize struct with inline values
	*dest = models.World{
		CreatedAt:   converters.TimeToTimestamp(src.CreatedAt),
		UpdatedAt:   converters.TimeToTimestamp(src.UpdatedAt),
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	out.DefaultGameConfig, err = GameConfigurationFromGameConfigurationDatastore(nil, &src.DefaultGameConfig, nil)
	if err != nil {
		return nil, fmt.Errorf("converting DefaultGameConfig: %w", err)
	}

	out.SearchIndexInfo, err = IndexInfoFromIndexInfoDatastore(nil, &src.SearchIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldDataToWorldDataDatastore converts a WorldData to WorldDataDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source WorldData message to convert from
//   - dest: Destination WorldDataDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted WorldDataDatastore entity
//   - Error if conversion fails
func WorldDataToWorldDataDatastore(
	src *models.WorldData,
	dest *WorldDataDatastore,
	decorator func(*models.WorldData, *WorldDataDatastore) error,
) (out *WorldDataDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &WorldDataDatastore{}
	}

	// Initialize struct with inline values
	*dest = WorldDataDatastore{
		ContentHash: src.ContentHash,
		Version:     src.Version,
	}
	out = dest

	if src.ScreenshotIndexInfo != nil {
		_, err = IndexInfoToIndexInfoDatastore(src.ScreenshotIndexInfo, &out.ScreenshotIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting ScreenshotIndexInfo: %w", err)
		}
	}

	if src.TilesMap != nil {
		out.TilesMap = make(map[string]TileDatastore, len(src.TilesMap))
		for key, value := range src.TilesMap {
			var converted TileDatastore
			_, err = TileToTileDatastore(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting TilesMap[%v]: %w", key, err)
			}
			out.TilesMap[key] = converted
		}
	}
	if src.UnitsMap != nil {
		out.UnitsMap = make(map[string]UnitDatastore, len(src.UnitsMap))
		for key, value := range src.UnitsMap {
			var converted UnitDatastore
			_, err = UnitToUnitDatastore(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting UnitsMap[%v]: %w", key, err)
			}
			out.UnitsMap[key] = converted
		}
	}
	if src.Crossings != nil {
		out.Crossings = make(map[string]CrossingDatastore, len(src.Crossings))
		for key, value := range src.Crossings {
			var converted CrossingDatastore
			_, err = CrossingToCrossingDatastore(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Crossings[%v]: %w", key, err)
			}
			out.Crossings[key] = converted
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldDataFromWorldDataDatastore converts a WorldDataDatastore back to WorldData.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination WorldData message (if nil, a new one is created)
//   - src: Source WorldDataDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted WorldData message
//   - Error if conversion fails
func WorldDataFromWorldDataDatastore(
	dest *models.WorldData,
	src *WorldDataDatastore,
	decorator func(*models.WorldData, *WorldDataDatastore) error,
) (out *models.WorldData, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.WorldData{}
	}

	// Initialize struct with inline values
	*dest = models.WorldData{
		ContentHash: src.ContentHash,
		Version:     src.Version,
	}
	out = dest

	out.ScreenshotIndexInfo, err = IndexInfoFromIndexInfoDatastore(nil, &src.ScreenshotIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting ScreenshotIndexInfo: %w", err)
	}

	if src.TilesMap != nil {
		out.TilesMap = make(map[string]*models.Tile, len(src.TilesMap))
		for key, value := range src.TilesMap {
			out.TilesMap[key], err = TileFromTileDatastore(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting TilesMap[%v]: %w", key, err)
			}
		}
	}
	if src.UnitsMap != nil {
		out.UnitsMap = make(map[string]*models.Unit, len(src.UnitsMap))
		for key, value := range src.UnitsMap {
			out.UnitsMap[key], err = UnitFromUnitDatastore(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting UnitsMap[%v]: %w", key, err)
			}
		}
	}
	if src.Crossings != nil {
		out.Crossings = make(map[string]*models.Crossing, len(src.Crossings))
		for key, value := range src.Crossings {
			out.Crossings[key], err = CrossingFromCrossingDatastore(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Crossings[%v]: %w", key, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameToGameDatastore converts a Game to GameDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source Game message to convert from
//   - dest: Destination GameDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameDatastore entity
//   - Error if conversion fails
func GameToGameDatastore(
	src *models.Game,
	dest *GameDatastore,
	decorator func(*models.Game, *GameDatastore) error,
) (out *GameDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameDatastore{}
	}

	// Initialize struct with inline values
	*dest = GameDatastore{
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		WorldId:     src.WorldId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	if src.CreatedAt != nil {
		out.CreatedAt = converters.TimestampToTime(src.CreatedAt)
	}

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.Config != nil {
		_, err = GameConfigurationToGameConfigurationDatastore(src.Config, &out.Config, nil)
		if err != nil {
			return nil, fmt.Errorf("converting Config: %w", err)
		}
	}
	if src.SearchIndexInfo != nil {
		_, err = IndexInfoToIndexInfoDatastore(src.SearchIndexInfo, &out.SearchIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameFromGameDatastore converts a GameDatastore back to Game.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination Game message (if nil, a new one is created)
//   - src: Source GameDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted Game message
//   - Error if conversion fails
func GameFromGameDatastore(
	dest *models.Game,
	src *GameDatastore,
	decorator func(*models.Game, *GameDatastore) error,
) (out *models.Game, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Game{}
	}

	// Initialize struct with inline values
	*dest = models.Game{
		CreatedAt:   converters.TimeToTimestamp(src.CreatedAt),
		UpdatedAt:   converters.TimeToTimestamp(src.UpdatedAt),
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		WorldId:     src.WorldId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	out.Config, err = GameConfigurationFromGameConfigurationDatastore(nil, &src.Config, nil)
	if err != nil {
		return nil, fmt.Errorf("converting Config: %w", err)
	}

	out.SearchIndexInfo, err = IndexInfoFromIndexInfoDatastore(nil, &src.SearchIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameStateToGameStateDatastore converts a GameState to GameStateDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source GameState message to convert from
//   - dest: Destination GameStateDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameStateDatastore entity
//   - Error if conversion fails
func GameStateToGameStateDatastore(
	src *models.GameState,
	dest *GameStateDatastore,
	decorator func(*models.GameState, *GameStateDatastore) error,
) (out *GameStateDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameStateDatastore{}
	}

	// Initialize struct with inline values
	*dest = GameStateDatastore{
		GameId:             src.GameId,
		TurnCounter:        src.TurnCounter,
		CurrentPlayer:      src.CurrentPlayer,
		StateHash:          src.StateHash,
		Version:            src.Version,
		Status:             src.Status,
		Finished:           src.Finished,
		WinningPlayer:      src.WinningPlayer,
		WinningTeam:        src.WinningTeam,
		CurrentGroupNumber: src.CurrentGroupNumber,
	}
	out = dest

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.WorldData != nil {
		_, err = WorldDataToWorldDataDatastore(src.WorldData, &out.WorldData, nil)
		if err != nil {
			return nil, fmt.Errorf("converting WorldData: %w", err)
		}
	}

	if src.PlayerStates != nil {
		out.PlayerStates = make(map[int32]PlayerStateDatastore, len(src.PlayerStates))
		for key, value := range src.PlayerStates {
			var converted PlayerStateDatastore
			_, err = PlayerStateToPlayerStateDatastore(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting PlayerStates[%v]: %w", key, err)
			}
			out.PlayerStates[key] = converted
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameStateFromGameStateDatastore converts a GameStateDatastore back to GameState.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination GameState message (if nil, a new one is created)
//   - src: Source GameStateDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameState message
//   - Error if conversion fails
func GameStateFromGameStateDatastore(
	dest *models.GameState,
	src *GameStateDatastore,
	decorator func(*models.GameState, *GameStateDatastore) error,
) (out *models.GameState, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameState{}
	}

	// Initialize struct with inline values
	*dest = models.GameState{
		UpdatedAt:          converters.TimeToTimestamp(src.UpdatedAt),
		GameId:             src.GameId,
		TurnCounter:        src.TurnCounter,
		CurrentPlayer:      src.CurrentPlayer,
		StateHash:          src.StateHash,
		Version:            src.Version,
		Status:             src.Status,
		Finished:           src.Finished,
		WinningPlayer:      src.WinningPlayer,
		WinningTeam:        src.WinningTeam,
		CurrentGroupNumber: src.CurrentGroupNumber,
	}
	out = dest

	out.WorldData, err = WorldDataFromWorldDataDatastore(nil, &src.WorldData, nil)
	if err != nil {
		return nil, fmt.Errorf("converting WorldData: %w", err)
	}

	if src.PlayerStates != nil {
		out.PlayerStates = make(map[int32]*models.PlayerState, len(src.PlayerStates))
		for key, value := range src.PlayerStates {
			out.PlayerStates[key], err = PlayerStateFromPlayerStateDatastore(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting PlayerStates[%v]: %w", key, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameConfigurationToGameConfigurationDatastore converts a GameConfiguration to GameConfigurationDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source GameConfiguration message to convert from
//   - dest: Destination GameConfigurationDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameConfigurationDatastore entity
//   - Error if conversion fails
func GameConfigurationToGameConfigurationDatastore(
	src *models.GameConfiguration,
	dest *GameConfigurationDatastore,
	decorator func(*models.GameConfiguration, *GameConfigurationDatastore) error,
) (out *GameConfigurationDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameConfigurationDatastore{}
	}

	// Initialize struct with inline values
	*dest = GameConfigurationDatastore{}
	out = dest

	if src.IncomeConfigs != nil {
		_, err = IncomeConfigToIncomeConfigDatastore(src.IncomeConfigs, &out.IncomeConfigs, nil)
		if err != nil {
			return nil, fmt.Errorf("converting IncomeConfigs: %w", err)
		}
	}
	if src.Settings != nil {
		_, err = GameSettingsToGameSettingsDatastore(src.Settings, &out.Settings, nil)
		if err != nil {
			return nil, fmt.Errorf("converting Settings: %w", err)
		}
	}

	if src.Players != nil {
		out.Players = make([]GamePlayerDatastore, len(src.Players))
		for i, item := range src.Players {
			_, err = GamePlayerToGamePlayerDatastore(item, &out.Players[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Players[%d]: %w", i, err)
			}
		}
	}
	if src.Teams != nil {
		out.Teams = make([]GameTeamDatastore, len(src.Teams))
		for i, item := range src.Teams {
			_, err = GameTeamToGameTeamDatastore(item, &out.Teams[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Teams[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameConfigurationFromGameConfigurationDatastore converts a GameConfigurationDatastore back to GameConfiguration.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination GameConfiguration message (if nil, a new one is created)
//   - src: Source GameConfigurationDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameConfiguration message
//   - Error if conversion fails
func GameConfigurationFromGameConfigurationDatastore(
	dest *models.GameConfiguration,
	src *GameConfigurationDatastore,
	decorator func(*models.GameConfiguration, *GameConfigurationDatastore) error,
) (out *models.GameConfiguration, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameConfiguration{}
	}

	// Initialize struct with inline values
	*dest = models.GameConfiguration{}
	out = dest

	out.IncomeConfigs, err = IncomeConfigFromIncomeConfigDatastore(nil, &src.IncomeConfigs, nil)
	if err != nil {
		return nil, fmt.Errorf("converting IncomeConfigs: %w", err)
	}

	out.Settings, err = GameSettingsFromGameSettingsDatastore(nil, &src.Settings, nil)
	if err != nil {
		return nil, fmt.Errorf("converting Settings: %w", err)
	}

	if src.Players != nil {
		out.Players = make([]*models.GamePlayer, len(src.Players))
		for i, item := range src.Players {
			out.Players[i], err = GamePlayerFromGamePlayerDatastore(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Players[%d]: %w", i, err)
			}
		}
	}
	if src.Teams != nil {
		out.Teams = make([]*models.GameTeam, len(src.Teams))
		for i, item := range src.Teams {
			out.Teams[i], err = GameTeamFromGameTeamDatastore(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Teams[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IncomeConfigToIncomeConfigDatastore converts a IncomeConfig to IncomeConfigDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source IncomeConfig message to convert from
//   - dest: Destination IncomeConfigDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IncomeConfigDatastore entity
//   - Error if conversion fails
func IncomeConfigToIncomeConfigDatastore(
	src *models.IncomeConfig,
	dest *IncomeConfigDatastore,
	decorator func(*models.IncomeConfig, *IncomeConfigDatastore) error,
) (out *IncomeConfigDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IncomeConfigDatastore{}
	}

	// Initialize struct with inline values
	*dest = IncomeConfigDatastore{
		StartingCoins:     src.StartingCoins,
		GameIncome:        src.GameIncome,
		LandbaseIncome:    src.LandbaseIncome,
		NavalbaseIncome:   src.NavalbaseIncome,
		AirportbaseIncome: src.AirportbaseIncome,
		MissilesiloIncome: src.MissilesiloIncome,
		MinesIncome:       src.MinesIncome,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IncomeConfigFromIncomeConfigDatastore converts a IncomeConfigDatastore back to IncomeConfig.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination IncomeConfig message (if nil, a new one is created)
//   - src: Source IncomeConfigDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted IncomeConfig message
//   - Error if conversion fails
func IncomeConfigFromIncomeConfigDatastore(
	dest *models.IncomeConfig,
	src *IncomeConfigDatastore,
	decorator func(*models.IncomeConfig, *IncomeConfigDatastore) error,
) (out *models.IncomeConfig, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IncomeConfig{}
	}

	// Initialize struct with inline values
	*dest = models.IncomeConfig{
		StartingCoins:     src.StartingCoins,
		GameIncome:        src.GameIncome,
		LandbaseIncome:    src.LandbaseIncome,
		NavalbaseIncome:   src.NavalbaseIncome,
		AirportbaseIncome: src.AirportbaseIncome,
		MissilesiloIncome: src.MissilesiloIncome,
		MinesIncome:       src.MinesIncome,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GamePlayerToGamePlayerDatastore converts a GamePlayer to GamePlayerDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source GamePlayer message to convert from
//   - dest: Destination GamePlayerDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GamePlayerDatastore entity
//   - Error if conversion fails
func GamePlayerToGamePlayerDatastore(
	src *models.GamePlayer,
	dest *GamePlayerDatastore,
	decorator func(*models.GamePlayer, *GamePlayerDatastore) error,
) (out *GamePlayerDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GamePlayerDatastore{}
	}

	// Initialize struct with inline values
	*dest = GamePlayerDatastore{
		PlayerId:      src.PlayerId,
		UserId:        src.UserId,
		PlayerType:    src.PlayerType,
		Color:         src.Color,
		TeamId:        src.TeamId,
		Name:          src.Name,
		IsActive:      src.IsActive,
		StartingCoins: src.StartingCoins,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GamePlayerFromGamePlayerDatastore converts a GamePlayerDatastore back to GamePlayer.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination GamePlayer message (if nil, a new one is created)
//   - src: Source GamePlayerDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GamePlayer message
//   - Error if conversion fails
func GamePlayerFromGamePlayerDatastore(
	dest *models.GamePlayer,
	src *GamePlayerDatastore,
	decorator func(*models.GamePlayer, *GamePlayerDatastore) error,
) (out *models.GamePlayer, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GamePlayer{}
	}

	// Initialize struct with inline values
	*dest = models.GamePlayer{
		PlayerId:      src.PlayerId,
		UserId:        src.UserId,
		PlayerType:    src.PlayerType,
		Color:         src.Color,
		TeamId:        src.TeamId,
		Name:          src.Name,
		IsActive:      src.IsActive,
		StartingCoins: src.StartingCoins,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameTeamToGameTeamDatastore converts a GameTeam to GameTeamDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source GameTeam message to convert from
//   - dest: Destination GameTeamDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameTeamDatastore entity
//   - Error if conversion fails
func GameTeamToGameTeamDatastore(
	src *models.GameTeam,
	dest *GameTeamDatastore,
	decorator func(*models.GameTeam, *GameTeamDatastore) error,
) (out *GameTeamDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameTeamDatastore{}
	}

	// Initialize struct with inline values
	*dest = GameTeamDatastore{
		TeamId:   src.TeamId,
		Name:     src.Name,
		Color:    src.Color,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameTeamFromGameTeamDatastore converts a GameTeamDatastore back to GameTeam.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination GameTeam message (if nil, a new one is created)
//   - src: Source GameTeamDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameTeam message
//   - Error if conversion fails
func GameTeamFromGameTeamDatastore(
	dest *models.GameTeam,
	src *GameTeamDatastore,
	decorator func(*models.GameTeam, *GameTeamDatastore) error,
) (out *models.GameTeam, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameTeam{}
	}

	// Initialize struct with inline values
	*dest = models.GameTeam{
		TeamId:   src.TeamId,
		Name:     src.Name,
		Color:    src.Color,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameSettingsToGameSettingsDatastore converts a GameSettings to GameSettingsDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source GameSettings message to convert from
//   - dest: Destination GameSettingsDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameSettingsDatastore entity
//   - Error if conversion fails
func GameSettingsToGameSettingsDatastore(
	src *models.GameSettings,
	dest *GameSettingsDatastore,
	decorator func(*models.GameSettings, *GameSettingsDatastore) error,
) (out *GameSettingsDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameSettingsDatastore{}
	}

	// Initialize struct with inline values
	*dest = GameSettingsDatastore{
		AllowedUnits:  src.AllowedUnits,
		TurnTimeLimit: src.TurnTimeLimit,
		TeamMode:      src.TeamMode,
		MaxTurns:      src.MaxTurns,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameSettingsFromGameSettingsDatastore converts a GameSettingsDatastore back to GameSettings.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination GameSettings message (if nil, a new one is created)
//   - src: Source GameSettingsDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameSettings message
//   - Error if conversion fails
func GameSettingsFromGameSettingsDatastore(
	dest *models.GameSettings,
	src *GameSettingsDatastore,
	decorator func(*models.GameSettings, *GameSettingsDatastore) error,
) (out *models.GameSettings, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameSettings{}
	}

	// Initialize struct with inline values
	*dest = models.GameSettings{
		AllowedUnits:  src.AllowedUnits,
		TurnTimeLimit: src.TurnTimeLimit,
		TeamMode:      src.TeamMode,
		MaxTurns:      src.MaxTurns,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// PlayerStateToPlayerStateDatastore converts a PlayerState to PlayerStateDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source PlayerState message to convert from
//   - dest: Destination PlayerStateDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted PlayerStateDatastore entity
//   - Error if conversion fails
func PlayerStateToPlayerStateDatastore(
	src *models.PlayerState,
	dest *PlayerStateDatastore,
	decorator func(*models.PlayerState, *PlayerStateDatastore) error,
) (out *PlayerStateDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &PlayerStateDatastore{}
	}

	// Initialize struct with inline values
	*dest = PlayerStateDatastore{
		Coins:    src.Coins,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// PlayerStateFromPlayerStateDatastore converts a PlayerStateDatastore back to PlayerState.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination PlayerState message (if nil, a new one is created)
//   - src: Source PlayerStateDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted PlayerState message
//   - Error if conversion fails
func PlayerStateFromPlayerStateDatastore(
	dest *models.PlayerState,
	src *PlayerStateDatastore,
	decorator func(*models.PlayerState, *PlayerStateDatastore) error,
) (out *models.PlayerState, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.PlayerState{}
	}

	// Initialize struct with inline values
	*dest = models.PlayerState{
		Coins:    src.Coins,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameMoveToGameMoveDatastore converts a GameMove to GameMoveDatastore.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - src: Source GameMove message to convert from
//   - dest: Destination GameMoveDatastore entity (if nil, a new one is created)
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameMoveDatastore entity
//   - Error if conversion fails
func GameMoveToGameMoveDatastore(
	src *models.GameMove,
	dest *GameMoveDatastore,
	decorator func(*models.GameMove, *GameMoveDatastore) error,
) (out *GameMoveDatastore, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameMoveDatastore{}
	}

	// Initialize struct with inline values
	*dest = GameMoveDatastore{
		Player:      src.Player,
		GroupNumber: src.GroupNumber,
		MoveNumber:  src.MoveNumber,
		SequenceNum: src.SequenceNum,
		IsPermanent: src.IsPermanent,
		Description: src.Description,
	}
	out = dest

	if src.Timestamp != nil {
		out.Timestamp = converters.TimestampToTime(src.Timestamp)
	}

	if src.Changes != nil {
		out.Changes = make([][]byte, len(src.Changes))
		for i, item := range src.Changes {
			_, err = converters.MessageToAnyBytesConverter(item, &out.Changes[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Changes[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameMoveFromGameMoveDatastore converts a GameMoveDatastore back to GameMove.
//
// The optional decorator function allows custom field transformations after conversion.
//
// Parameters:
//   - dest: Destination GameMove message (if nil, a new one is created)
//   - src: Source GameMoveDatastore entity to convert from
//   - decorator: Optional function for custom transformations
//
// Returns:
//   - Converted GameMove message
//   - Error if conversion fails
func GameMoveFromGameMoveDatastore(
	dest *models.GameMove,
	src *GameMoveDatastore,
	decorator func(*models.GameMove, *GameMoveDatastore) error,
) (out *models.GameMove, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameMove{}
	}

	// Initialize struct with inline values
	*dest = models.GameMove{
		Player:      src.Player,
		GroupNumber: src.GroupNumber,
		MoveNumber:  src.MoveNumber,
		Timestamp:   converters.TimeToTimestamp(src.Timestamp),
		SequenceNum: src.SequenceNum,
		IsPermanent: src.IsPermanent,
		Description: src.Description,
	}
	out = dest

	if src.Changes != nil {
		out.Changes = make([]*models.WorldChange, len(src.Changes))
		for i, item := range src.Changes {
			out.Changes[i], err = converters.AnyBytesToMessageConverter[*models.WorldChange](nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Changes[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return dest, nil
}
