// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: lilbattle/v1/models/models.proto

package lilbattlev1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Crossing types for terrain improvements (roads on land, bridges on water)
type CrossingType int32

const (
	CrossingType_CROSSING_TYPE_UNSPECIFIED CrossingType = 0
	CrossingType_CROSSING_TYPE_ROAD        CrossingType = 1 // Road on land terrain
	CrossingType_CROSSING_TYPE_BRIDGE      CrossingType = 2 // Bridge over water terrain
)

// Enum value maps for CrossingType.
var (
	CrossingType_name = map[int32]string{
		0: "CROSSING_TYPE_UNSPECIFIED",
		1: "CROSSING_TYPE_ROAD",
		2: "CROSSING_TYPE_BRIDGE",
	}
	CrossingType_value = map[string]int32{
		"CROSSING_TYPE_UNSPECIFIED": 0,
		"CROSSING_TYPE_ROAD":        1,
		"CROSSING_TYPE_BRIDGE":      2,
	}
)

func (x CrossingType) Enum() *CrossingType {
	p := new(CrossingType)
	*p = x
	return p
}

func (x CrossingType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CrossingType) Descriptor() protoreflect.EnumDescriptor {
	return file_lilbattle_v1_models_models_proto_enumTypes[0].Descriptor()
}

func (CrossingType) Type() protoreflect.EnumType {
	return &file_lilbattle_v1_models_models_proto_enumTypes[0]
}

func (x CrossingType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CrossingType.Descriptor instead.
func (CrossingType) EnumDescriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{0}
}

// Terrain type classification - used for gameplay logic
type TerrainType int32

const (
	TerrainType_TERRAIN_TYPE_UNSPECIFIED TerrainType = 0
	TerrainType_TERRAIN_TYPE_CITY        TerrainType = 1 // Player-owned structures (bases, hospitals, etc.)
	TerrainType_TERRAIN_TYPE_NATURE      TerrainType = 2 // Neutral natural terrain (grass, mountains, etc.)
	TerrainType_TERRAIN_TYPE_BRIDGE      TerrainType = 3 // Bridge crossings
	TerrainType_TERRAIN_TYPE_WATER       TerrainType = 4 // Water tiles
	TerrainType_TERRAIN_TYPE_ROAD        TerrainType = 5 // Road tiles
)

// Enum value maps for TerrainType.
var (
	TerrainType_name = map[int32]string{
		0: "TERRAIN_TYPE_UNSPECIFIED",
		1: "TERRAIN_TYPE_CITY",
		2: "TERRAIN_TYPE_NATURE",
		3: "TERRAIN_TYPE_BRIDGE",
		4: "TERRAIN_TYPE_WATER",
		5: "TERRAIN_TYPE_ROAD",
	}
	TerrainType_value = map[string]int32{
		"TERRAIN_TYPE_UNSPECIFIED": 0,
		"TERRAIN_TYPE_CITY":        1,
		"TERRAIN_TYPE_NATURE":      2,
		"TERRAIN_TYPE_BRIDGE":      3,
		"TERRAIN_TYPE_WATER":       4,
		"TERRAIN_TYPE_ROAD":        5,
	}
)

func (x TerrainType) Enum() *TerrainType {
	p := new(TerrainType)
	*p = x
	return p
}

func (x TerrainType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TerrainType) Descriptor() protoreflect.EnumDescriptor {
	return file_lilbattle_v1_models_models_proto_enumTypes[1].Descriptor()
}

func (TerrainType) Type() protoreflect.EnumType {
	return &file_lilbattle_v1_models_models_proto_enumTypes[1]
}

func (x TerrainType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TerrainType.Descriptor instead.
func (TerrainType) EnumDescriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{1}
}

// /////// Game related models
type GameStatus int32

const (
	GameStatus_GAME_STATUS_UNSPECIFIED GameStatus = 0
	GameStatus_GAME_STATUS_PLAYING     GameStatus = 1
	GameStatus_GAME_STATUS_PAUSED      GameStatus = 2
	GameStatus_GAME_STATUS_ENDED       GameStatus = 3
)

// Enum value maps for GameStatus.
var (
	GameStatus_name = map[int32]string{
		0: "GAME_STATUS_UNSPECIFIED",
		1: "GAME_STATUS_PLAYING",
		2: "GAME_STATUS_PAUSED",
		3: "GAME_STATUS_ENDED",
	}
	GameStatus_value = map[string]int32{
		"GAME_STATUS_UNSPECIFIED": 0,
		"GAME_STATUS_PLAYING":     1,
		"GAME_STATUS_PAUSED":      2,
		"GAME_STATUS_ENDED":       3,
	}
)

func (x GameStatus) Enum() *GameStatus {
	p := new(GameStatus)
	*p = x
	return p
}

func (x GameStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_lilbattle_v1_models_models_proto_enumTypes[2].Descriptor()
}

func (GameStatus) Type() protoreflect.EnumType {
	return &file_lilbattle_v1_models_models_proto_enumTypes[2]
}

func (x GameStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameStatus.Descriptor instead.
func (GameStatus) EnumDescriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{2}
}

type PathDirection int32

const (
	PathDirection_PATH_DIRECTION_UNSPECIFIED  PathDirection = 0
	PathDirection_PATH_DIRECTION_LEFT         PathDirection = 1
	PathDirection_PATH_DIRECTION_TOP_LEFT     PathDirection = 2
	PathDirection_PATH_DIRECTION_TOP_RIGHT    PathDirection = 3
	PathDirection_PATH_DIRECTION_RIGHT        PathDirection = 4
	PathDirection_PATH_DIRECTION_BOTTOM_RIGHT PathDirection = 5
	PathDirection_PATH_DIRECTION_BOTTOM_LEFT  PathDirection = 6
)

// Enum value maps for PathDirection.
var (
	PathDirection_name = map[int32]string{
		0: "PATH_DIRECTION_UNSPECIFIED",
		1: "PATH_DIRECTION_LEFT",
		2: "PATH_DIRECTION_TOP_LEFT",
		3: "PATH_DIRECTION_TOP_RIGHT",
		4: "PATH_DIRECTION_RIGHT",
		5: "PATH_DIRECTION_BOTTOM_RIGHT",
		6: "PATH_DIRECTION_BOTTOM_LEFT",
	}
	PathDirection_value = map[string]int32{
		"PATH_DIRECTION_UNSPECIFIED":  0,
		"PATH_DIRECTION_LEFT":         1,
		"PATH_DIRECTION_TOP_LEFT":     2,
		"PATH_DIRECTION_TOP_RIGHT":    3,
		"PATH_DIRECTION_RIGHT":        4,
		"PATH_DIRECTION_BOTTOM_RIGHT": 5,
		"PATH_DIRECTION_BOTTOM_LEFT":  6,
	}
)

func (x PathDirection) Enum() *PathDirection {
	p := new(PathDirection)
	*p = x
	return p
}

func (x PathDirection) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PathDirection) Descriptor() protoreflect.EnumDescriptor {
	return file_lilbattle_v1_models_models_proto_enumTypes[3].Descriptor()
}

func (PathDirection) Type() protoreflect.EnumType {
	return &file_lilbattle_v1_models_models_proto_enumTypes[3]
}

func (x PathDirection) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PathDirection.Descriptor instead.
func (PathDirection) EnumDescriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{3}
}

type IndexInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// We maintain an IndexInfo for each type of "indexing" operation needed
	// For example one update may change the keywords (so we need to update indexes for search)
	// Another might update the "units" so we may need a new screenshot
	// Each one's updates - updated and indexed timestamps separately so they can be tracked sepately
	LastUpdatedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	LastIndexedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_indexed_at,json=lastIndexedAt,proto3" json:"last_indexed_at,omitempty"`
	NeedsIndexing bool                   `protobuf:"varint,3,opt,name=needs_indexing,json=needsIndexing,proto3" json:"needs_indexing,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexInfo) Reset() {
	*x = IndexInfo{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexInfo) ProtoMessage() {}

func (x *IndexInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexInfo.ProtoReflect.Descriptor instead.
func (*IndexInfo) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{0}
}

func (x *IndexInfo) GetLastUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdatedAt
	}
	return nil
}

func (x *IndexInfo) GetLastIndexedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LastIndexedAt
	}
	return nil
}

func (x *IndexInfo) GetNeedsIndexing() bool {
	if x != nil {
		return x.NeedsIndexing
	}
	return false
}

type Pagination struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Instead of an offset an abstract  "page" key is provided that offers
	// an opaque "pointer" into some offset in a result set.
	PageKey string `protobuf:"bytes,1,opt,name=page_key,json=pageKey,proto3" json:"page_key,omitempty"`
	// *
	// If a pagekey is not supported we can also support a direct integer offset
	// for cases where it makes sense.
	PageOffset int32 `protobuf:"varint,2,opt,name=page_offset,json=pageOffset,proto3" json:"page_offset,omitempty"`
	// *
	// Number of results to return.
	PageSize      int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Pagination) Reset() {
	*x = Pagination{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Pagination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pagination) ProtoMessage() {}

func (x *Pagination) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Pagination.ProtoReflect.Descriptor instead.
func (*Pagination) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{1}
}

func (x *Pagination) GetPageKey() string {
	if x != nil {
		return x.PageKey
	}
	return ""
}

func (x *Pagination) GetPageOffset() int32 {
	if x != nil {
		return x.PageOffset
	}
	return 0
}

func (x *Pagination) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

type PaginationResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The key/pointer string that subsequent List requests should pass to
	// continue the pagination.
	NextPageKey string `protobuf:"bytes,2,opt,name=next_page_key,json=nextPageKey,proto3" json:"next_page_key,omitempty"`
	// *
	// Also support an integer offset if possible
	NextPageOffset int32 `protobuf:"varint,3,opt,name=next_page_offset,json=nextPageOffset,proto3" json:"next_page_offset,omitempty"`
	// *
	// Whether theere are more results.
	HasMore bool `protobuf:"varint,4,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	// *
	// Total number of results.
	TotalResults  int32 `protobuf:"varint,5,opt,name=total_results,json=totalResults,proto3" json:"total_results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PaginationResponse) Reset() {
	*x = PaginationResponse{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PaginationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaginationResponse) ProtoMessage() {}

func (x *PaginationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaginationResponse.ProtoReflect.Descriptor instead.
func (*PaginationResponse) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{2}
}

func (x *PaginationResponse) GetNextPageKey() string {
	if x != nil {
		return x.NextPageKey
	}
	return ""
}

func (x *PaginationResponse) GetNextPageOffset() int32 {
	if x != nil {
		return x.NextPageOffset
	}
	return 0
}

func (x *PaginationResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

func (x *PaginationResponse) GetTotalResults() int32 {
	if x != nil {
		return x.TotalResults
	}
	return 0
}

type World struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// Version for Optimistic concurrent locking
	Version int64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// Unique ID for the world
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// User that created the world
	CreatorId string `protobuf:"bytes,5,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// Name if items have names
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Description if world has a description
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	// Some tags
	Tags []string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty"`
	// A possible image url
	ImageUrl string `protobuf:"bytes,9,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	// Difficulty - example attribute
	Difficulty string `protobuf:"bytes,10,opt,name=difficulty,proto3" json:"difficulty,omitempty"`
	// URL to screenshot/preview image (defaults to /worlds/{id}/screenshots/{screenshotName})
	// Can be overridden to point to CDN or external hosting
	PreviewUrls []string `protobuf:"bytes,11,rep,name=preview_urls,json=previewUrls,proto3" json:"preview_urls,omitempty"`
	// Default game configs
	DefaultGameConfig *GameConfiguration `protobuf:"bytes,12,opt,name=default_game_config,json=defaultGameConfig,proto3" json:"default_game_config,omitempty"`
	SearchIndexInfo   *IndexInfo         `protobuf:"bytes,13,opt,name=search_index_info,json=searchIndexInfo,proto3" json:"search_index_info,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *World) Reset() {
	*x = World{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *World) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*World) ProtoMessage() {}

func (x *World) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use World.ProtoReflect.Descriptor instead.
func (*World) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{3}
}

func (x *World) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *World) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *World) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *World) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *World) GetCreatorId() string {
	if x != nil {
		return x.CreatorId
	}
	return ""
}

func (x *World) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *World) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *World) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *World) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

func (x *World) GetDifficulty() string {
	if x != nil {
		return x.Difficulty
	}
	return ""
}

func (x *World) GetPreviewUrls() []string {
	if x != nil {
		return x.PreviewUrls
	}
	return nil
}

func (x *World) GetDefaultGameConfig() *GameConfiguration {
	if x != nil {
		return x.DefaultGameConfig
	}
	return nil
}

func (x *World) GetSearchIndexInfo() *IndexInfo {
	if x != nil {
		return x.SearchIndexInfo
	}
	return nil
}

type WorldData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// New map-based storage (key = "q,r" coordinate string)
	TilesMap map[string]*Tile `protobuf:"bytes,1,rep,name=tiles_map,json=tilesMap,proto3" json:"tiles_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	UnitsMap map[string]*Unit `protobuf:"bytes,2,rep,name=units_map,json=unitsMap,proto3" json:"units_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// When this world data was updated (may have happened without world updating)
	ScreenshotIndexInfo *IndexInfo `protobuf:"bytes,3,opt,name=screenshot_index_info,json=screenshotIndexInfo,proto3" json:"screenshot_index_info,omitempty"`
	// We will only update if hash's are different
	ContentHash string `protobuf:"bytes,4,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
	// Version for Optimistic concurrent locking
	Version int64 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	// Improvement layer - crossings (roads on land, bridges on water)
	Crossings     map[string]*Crossing `protobuf:"bytes,8,rep,name=crossings,proto3" json:"crossings,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // key = "q,r", value = crossing with connectivity
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorldData) Reset() {
	*x = WorldData{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorldData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorldData) ProtoMessage() {}

func (x *WorldData) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorldData.ProtoReflect.Descriptor instead.
func (*WorldData) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{4}
}

func (x *WorldData) GetTilesMap() map[string]*Tile {
	if x != nil {
		return x.TilesMap
	}
	return nil
}

func (x *WorldData) GetUnitsMap() map[string]*Unit {
	if x != nil {
		return x.UnitsMap
	}
	return nil
}

func (x *WorldData) GetScreenshotIndexInfo() *IndexInfo {
	if x != nil {
		return x.ScreenshotIndexInfo
	}
	return nil
}

func (x *WorldData) GetContentHash() string {
	if x != nil {
		return x.ContentHash
	}
	return ""
}

func (x *WorldData) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *WorldData) GetCrossings() map[string]*Crossing {
	if x != nil {
		return x.Crossings
	}
	return nil
}

// Crossing with explicit connectivity data
// Each crossing stores which of its 6 hex neighbors it connects to
type Crossing struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Type  CrossingType           `protobuf:"varint,1,opt,name=type,proto3,enum=lilbattle.v1.CrossingType" json:"type,omitempty"`
	// 6 booleans for hex neighbors in order matching AxialNeighborDeltas:
	// 0: LEFT (-1,0), 1: TOP_LEFT (0,-1), 2: TOP_RIGHT (1,-1),
	// 3: RIGHT (1,0), 4: BOTTOM_RIGHT (0,1), 5: BOTTOM_LEFT (-1,1)
	ConnectsTo    []bool `protobuf:"varint,2,rep,packed,name=connects_to,json=connectsTo,proto3" json:"connects_to,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Crossing) Reset() {
	*x = Crossing{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Crossing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Crossing) ProtoMessage() {}

func (x *Crossing) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Crossing.ProtoReflect.Descriptor instead.
func (*Crossing) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{5}
}

func (x *Crossing) GetType() CrossingType {
	if x != nil {
		return x.Type
	}
	return CrossingType_CROSSING_TYPE_UNSPECIFIED
}

func (x *Crossing) GetConnectsTo() []bool {
	if x != nil {
		return x.ConnectsTo
	}
	return nil
}

type Tile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Q and R in Cubed coordinates
	Q        int32 `protobuf:"varint,1,opt,name=q,proto3" json:"q,omitempty"`
	R        int32 `protobuf:"varint,2,opt,name=r,proto3" json:"r,omitempty"`
	TileType int32 `protobuf:"varint,3,opt,name=tile_type,json=tileType,proto3" json:"tile_type,omitempty"` // Tile type
	// Whether the tile itself belongs to a player
	Player   int32  `protobuf:"varint,4,opt,name=player,proto3" json:"player,omitempty"`
	Shortcut string `protobuf:"bytes,5,opt,name=shortcut,proto3" json:"shortcut,omitempty"` // A short cut like A1 or S2 etc for quick access
	// Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
	// This helps us not having to "top up" or "reset" the stats at the end
	// of each turn.  Instead as the game turn is incremented we can do a
	// lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
	// So we just have to increment the game_turn and the unit is automaticaly flagged as
	// needing a top up of its health/balance/movement etc
	LastActedTurn    int32 `protobuf:"varint,6,opt,name=last_acted_turn,json=lastActedTurn,proto3" json:"last_acted_turn,omitempty"`          // Which turn this unit was created/last acted on (ie movemade)
	LastToppedupTurn int32 `protobuf:"varint,7,opt,name=last_toppedup_turn,json=lastToppedupTurn,proto3" json:"last_toppedup_turn,omitempty"` // When the last top up happened
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Tile) Reset() {
	*x = Tile{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Tile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tile) ProtoMessage() {}

func (x *Tile) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tile.ProtoReflect.Descriptor instead.
func (*Tile) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{6}
}

func (x *Tile) GetQ() int32 {
	if x != nil {
		return x.Q
	}
	return 0
}

func (x *Tile) GetR() int32 {
	if x != nil {
		return x.R
	}
	return 0
}

func (x *Tile) GetTileType() int32 {
	if x != nil {
		return x.TileType
	}
	return 0
}

func (x *Tile) GetPlayer() int32 {
	if x != nil {
		return x.Player
	}
	return 0
}

func (x *Tile) GetShortcut() string {
	if x != nil {
		return x.Shortcut
	}
	return ""
}

func (x *Tile) GetLastActedTurn() int32 {
	if x != nil {
		return x.LastActedTurn
	}
	return 0
}

func (x *Tile) GetLastToppedupTurn() int32 {
	if x != nil {
		return x.LastToppedupTurn
	}
	return 0
}

type Unit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Q and R in Cubed coordinates
	Q        int32  `protobuf:"varint,1,opt,name=q,proto3" json:"q,omitempty"`
	R        int32  `protobuf:"varint,2,opt,name=r,proto3" json:"r,omitempty"`
	Player   int32  `protobuf:"varint,3,opt,name=player,proto3" json:"player,omitempty"`
	UnitType int32  `protobuf:"varint,4,opt,name=unit_type,json=unitType,proto3" json:"unit_type,omitempty"`
	Shortcut string `protobuf:"bytes,5,opt,name=shortcut,proto3" json:"shortcut,omitempty"` // A short cut like A1 or S2 etc for quick access
	// Runtime state fields
	AvailableHealth int32   `protobuf:"varint,6,opt,name=available_health,json=availableHealth,proto3" json:"available_health,omitempty"` // Current health points
	DistanceLeft    float64 `protobuf:"fixed64,7,opt,name=distance_left,json=distanceLeft,proto3" json:"distance_left,omitempty"`         // Movement points remaining this turn
	// Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
	// This helps us not having to "top up" or "reset" the stats at the end
	// of each turn.  Instead as the game turn is incremented we can do a
	// lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
	// So we just have to increment the game_turn and the unit is automaticaly flagged as
	// needing a top up of its health/balance/movement etc
	LastActedTurn    int32 `protobuf:"varint,8,opt,name=last_acted_turn,json=lastActedTurn,proto3" json:"last_acted_turn,omitempty"`          // Which turn this unit was created/last acted on (ie movemade)
	LastToppedupTurn int32 `protobuf:"varint,9,opt,name=last_toppedup_turn,json=lastToppedupTurn,proto3" json:"last_toppedup_turn,omitempty"` // When the last top up happened
	// Details around wound bonus tracking for this turn
	AttacksReceivedThisTurn int32           `protobuf:"varint,10,opt,name=attacks_received_this_turn,json=attacksReceivedThisTurn,proto3" json:"attacks_received_this_turn,omitempty"` // Total number of attacks received this turn
	AttackHistory           []*AttackRecord `protobuf:"bytes,11,rep,name=attack_history,json=attackHistory,proto3" json:"attack_history,omitempty"`                                    // Detailed attack history for wound bonus calculation
	// Action progression tracking - index into UnitDefinition.action_order
	// Indicates which step in the action sequence the unit is currently on
	// Reset to 0 at turn start via TopUpUnitIfNeeded()
	ProgressionStep int32 `protobuf:"varint,12,opt,name=progression_step,json=progressionStep,proto3" json:"progression_step,omitempty"`
	// When current step has pipe-separated alternatives (e.g., "attack|capture"),
	// this tracks which alternative the user chose, preventing switching mid-step
	// Cleared when advancing to next step
	ChosenAlternative string `protobuf:"bytes,13,opt,name=chosen_alternative,json=chosenAlternative,proto3" json:"chosen_alternative,omitempty"`
	// Turn when this unit started capturing a building (0 = not capturing)
	// Capture completes at the start of the capturing player's next turn
	// if the unit is still alive on the tile
	CaptureStartedTurn int32 `protobuf:"varint,14,opt,name=capture_started_turn,json=captureStartedTurn,proto3" json:"capture_started_turn,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Unit) Reset() {
	*x = Unit{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Unit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Unit) ProtoMessage() {}

func (x *Unit) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Unit.ProtoReflect.Descriptor instead.
func (*Unit) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{7}
}

func (x *Unit) GetQ() int32 {
	if x != nil {
		return x.Q
	}
	return 0
}

func (x *Unit) GetR() int32 {
	if x != nil {
		return x.R
	}
	return 0
}

func (x *Unit) GetPlayer() int32 {
	if x != nil {
		return x.Player
	}
	return 0
}

func (x *Unit) GetUnitType() int32 {
	if x != nil {
		return x.UnitType
	}
	return 0
}

func (x *Unit) GetShortcut() string {
	if x != nil {
		return x.Shortcut
	}
	return ""
}

func (x *Unit) GetAvailableHealth() int32 {
	if x != nil {
		return x.AvailableHealth
	}
	return 0
}

func (x *Unit) GetDistanceLeft() float64 {
	if x != nil {
		return x.DistanceLeft
	}
	return 0
}

func (x *Unit) GetLastActedTurn() int32 {
	if x != nil {
		return x.LastActedTurn
	}
	return 0
}

func (x *Unit) GetLastToppedupTurn() int32 {
	if x != nil {
		return x.LastToppedupTurn
	}
	return 0
}

func (x *Unit) GetAttacksReceivedThisTurn() int32 {
	if x != nil {
		return x.AttacksReceivedThisTurn
	}
	return 0
}

func (x *Unit) GetAttackHistory() []*AttackRecord {
	if x != nil {
		return x.AttackHistory
	}
	return nil
}

func (x *Unit) GetProgressionStep() int32 {
	if x != nil {
		return x.ProgressionStep
	}
	return 0
}

func (x *Unit) GetChosenAlternative() string {
	if x != nil {
		return x.ChosenAlternative
	}
	return ""
}

func (x *Unit) GetCaptureStartedTurn() int32 {
	if x != nil {
		return x.CaptureStartedTurn
	}
	return 0
}

type AttackRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Q             int32                  `protobuf:"varint,1,opt,name=q,proto3" json:"q,omitempty"`                                     // Attacker's Q coordinate
	R             int32                  `protobuf:"varint,2,opt,name=r,proto3" json:"r,omitempty"`                                     // Attacker's R coordinate
	IsRanged      bool                   `protobuf:"varint,3,opt,name=is_ranged,json=isRanged,proto3" json:"is_ranged,omitempty"`       // Whether attacker is ranged 2+ tiles away
	TurnNumber    int32                  `protobuf:"varint,4,opt,name=turn_number,json=turnNumber,proto3" json:"turn_number,omitempty"` // Which turn this attack occured
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttackRecord) Reset() {
	*x = AttackRecord{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttackRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttackRecord) ProtoMessage() {}

func (x *AttackRecord) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttackRecord.ProtoReflect.Descriptor instead.
func (*AttackRecord) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{8}
}

func (x *AttackRecord) GetQ() int32 {
	if x != nil {
		return x.Q
	}
	return 0
}

func (x *AttackRecord) GetR() int32 {
	if x != nil {
		return x.R
	}
	return 0
}

func (x *AttackRecord) GetIsRanged() bool {
	if x != nil {
		return x.IsRanged
	}
	return false
}

func (x *AttackRecord) GetTurnNumber() int32 {
	if x != nil {
		return x.TurnNumber
	}
	return 0
}

// Rules engine terrain definition
type TerrainDefinition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`    // Terrain type ID
	Name  string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"` // Display name (e.g., "Grass", "Mountain")
	// double base_move_cost = 3;     // Base movement cost
	// double defense_bonus = 4;      // Defense bonus multiplier (0.0 to 1.0)
	Type        int32  `protobuf:"varint,5,opt,name=type,proto3" json:"type,omitempty"`              // Terrain category type
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"` // Human-readable description
	// How this terrain impacts
	UnitProperties map[int32]*TerrainUnitProperties `protobuf:"bytes,7,rep,name=unit_properties,json=unitProperties,proto3" json:"unit_properties,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of units that can be built on this terrain
	BuildableUnitIds []int32 `protobuf:"varint,8,rep,packed,name=buildable_unit_ids,json=buildableUnitIds,proto3" json:"buildable_unit_ids,omitempty"`
	IncomePerTurn    int32   `protobuf:"varint,9,opt,name=income_per_turn,json=incomePerTurn,proto3" json:"income_per_turn,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TerrainDefinition) Reset() {
	*x = TerrainDefinition{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TerrainDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TerrainDefinition) ProtoMessage() {}

func (x *TerrainDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TerrainDefinition.ProtoReflect.Descriptor instead.
func (*TerrainDefinition) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{9}
}

func (x *TerrainDefinition) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *TerrainDefinition) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TerrainDefinition) GetType() int32 {
	if x != nil {
		return x.Type
	}
	return 0
}

func (x *TerrainDefinition) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *TerrainDefinition) GetUnitProperties() map[int32]*TerrainUnitProperties {
	if x != nil {
		return x.UnitProperties
	}
	return nil
}

func (x *TerrainDefinition) GetBuildableUnitIds() []int32 {
	if x != nil {
		return x.BuildableUnitIds
	}
	return nil
}

func (x *TerrainDefinition) GetIncomePerTurn() int32 {
	if x != nil {
		return x.IncomePerTurn
	}
	return 0
}

// Rules engine unit definition
type UnitDefinition struct {
	state             protoimpl.MessageState           `protogen:"open.v1"`
	Id                int32                            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`                                                  // Unit type ID
	Name              string                           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`                                               // Display name (e.g., "Infantry", "Tank")
	Description       string                           `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`                                 //
	Health            int32                            `protobuf:"varint,4,opt,name=health,proto3" json:"health,omitempty"`                                          // Maximum health points
	Coins             int32                            `protobuf:"varint,5,opt,name=coins,proto3" json:"coins,omitempty"`                                            // how much it costs to build
	MovementPoints    float64                          `protobuf:"fixed64,6,opt,name=movement_points,json=movementPoints,proto3" json:"movement_points,omitempty"`   // Maximum movement per turn
	RetreatPoints     float64                          `protobuf:"fixed64,7,opt,name=retreat_points,json=retreatPoints,proto3" json:"retreat_points,omitempty"`      // Movement points available after attacking
	Defense           int32                            `protobuf:"varint,8,opt,name=defense,proto3" json:"defense,omitempty"`                                        // Base defense value
	AttackRange       int32                            `protobuf:"varint,9,opt,name=attack_range,json=attackRange,proto3" json:"attack_range,omitempty"`             // Max Attack range in tiles
	MinAttackRange    int32                            `protobuf:"varint,10,opt,name=min_attack_range,json=minAttackRange,proto3" json:"min_attack_range,omitempty"` // Minimum attack range in tile radius if specified (otherwise - will be 1
	SplashDamage      int32                            `protobuf:"varint,11,opt,name=splash_damage,json=splashDamage,proto3" json:"splash_damage,omitempty"`         // Splash damage amount
	TerrainProperties map[int32]*TerrainUnitProperties `protobuf:"bytes,12,rep,name=terrain_properties,json=terrainProperties,proto3" json:"terrain_properties,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Properties        []string                         `protobuf:"bytes,13,rep,name=properties,proto3" json:"properties,omitempty"` // Special properties/abilities
	// Unit classification for attack calculations
	UnitClass   string `protobuf:"bytes,14,opt,name=unit_class,json=unitClass,proto3" json:"unit_class,omitempty"`       // "Light", "Heavy", or "Stealth"
	UnitTerrain string `protobuf:"bytes,15,opt,name=unit_terrain,json=unitTerrain,proto3" json:"unit_terrain,omitempty"` // "Air", "Land", or "Water"
	// Attack table: base attack values against different unit classes
	// Key format: "Light:Air", "Heavy:Land", "Stealth:Water", etc.
	// Value 0 or missing key means "n/a" (cannot attack)
	AttackVsClass map[string]int32 `protobuf:"bytes,16,rep,name=attack_vs_class,json=attackVsClass,proto3" json:"attack_vs_class,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Ordered list of allowed actions this turn
	// Examples:
	//
	//	["move", "attack"] - can move then attack
	//	["move", "attack|capture"] - can move then either attack or capture
	//	["attack"] - can only attack (no movement)
	//
	// Default if empty: ["move", "attack|capture"]
	ActionOrder []string `protobuf:"bytes,17,rep,name=action_order,json=actionOrder,proto3" json:"action_order,omitempty"`
	// How many times each action type can be performed per turn
	// Key: action name, Value: max count
	// Example: {"attack": 2} means can attack twice
	// Default if not specified: 1 per action type
	ActionLimits map[string]int32 `protobuf:"bytes,18,rep,name=action_limits,json=actionLimits,proto3" json:"action_limits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Fix value for units that can repair other units (Medic, Engineer, etc.)
	// Used in fix calculation: p = 0.05 * fix_value
	// Default 0 means unit cannot fix
	FixValue      int32 `protobuf:"varint,19,opt,name=fix_value,json=fixValue,proto3" json:"fix_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnitDefinition) Reset() {
	*x = UnitDefinition{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitDefinition) ProtoMessage() {}

func (x *UnitDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitDefinition.ProtoReflect.Descriptor instead.
func (*UnitDefinition) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{10}
}

func (x *UnitDefinition) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *UnitDefinition) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UnitDefinition) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *UnitDefinition) GetHealth() int32 {
	if x != nil {
		return x.Health
	}
	return 0
}

func (x *UnitDefinition) GetCoins() int32 {
	if x != nil {
		return x.Coins
	}
	return 0
}

func (x *UnitDefinition) GetMovementPoints() float64 {
	if x != nil {
		return x.MovementPoints
	}
	return 0
}

func (x *UnitDefinition) GetRetreatPoints() float64 {
	if x != nil {
		return x.RetreatPoints
	}
	return 0
}

func (x *UnitDefinition) GetDefense() int32 {
	if x != nil {
		return x.Defense
	}
	return 0
}

func (x *UnitDefinition) GetAttackRange() int32 {
	if x != nil {
		return x.AttackRange
	}
	return 0
}

func (x *UnitDefinition) GetMinAttackRange() int32 {
	if x != nil {
		return x.MinAttackRange
	}
	return 0
}

func (x *UnitDefinition) GetSplashDamage() int32 {
	if x != nil {
		return x.SplashDamage
	}
	return 0
}

func (x *UnitDefinition) GetTerrainProperties() map[int32]*TerrainUnitProperties {
	if x != nil {
		return x.TerrainProperties
	}
	return nil
}

func (x *UnitDefinition) GetProperties() []string {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *UnitDefinition) GetUnitClass() string {
	if x != nil {
		return x.UnitClass
	}
	return ""
}

func (x *UnitDefinition) GetUnitTerrain() string {
	if x != nil {
		return x.UnitTerrain
	}
	return ""
}

func (x *UnitDefinition) GetAttackVsClass() map[string]int32 {
	if x != nil {
		return x.AttackVsClass
	}
	return nil
}

func (x *UnitDefinition) GetActionOrder() []string {
	if x != nil {
		return x.ActionOrder
	}
	return nil
}

func (x *UnitDefinition) GetActionLimits() map[string]int32 {
	if x != nil {
		return x.ActionLimits
	}
	return nil
}

func (x *UnitDefinition) GetFixValue() int32 {
	if x != nil {
		return x.FixValue
	}
	return 0
}

// Properties that are specific to unit on a particular terrain
type TerrainUnitProperties struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	TerrainId      int32                  `protobuf:"varint,1,opt,name=terrain_id,json=terrainId,proto3" json:"terrain_id,omitempty"` // Renamed from tile_id for clarity
	UnitId         int32                  `protobuf:"varint,2,opt,name=unit_id,json=unitId,proto3" json:"unit_id,omitempty"`
	MovementCost   float64                `protobuf:"fixed64,3,opt,name=movement_cost,json=movementCost,proto3" json:"movement_cost,omitempty"`         // Movement cost for this unit on this terrain
	HealingBonus   int32                  `protobuf:"varint,4,opt,name=healing_bonus,json=healingBonus,proto3" json:"healing_bonus,omitempty"`          // How much healing per turn this tile would offer this unit
	CanBuild       bool                   `protobuf:"varint,5,opt,name=can_build,json=canBuild,proto3" json:"can_build,omitempty"`                      // Whether this particular terrain can build this given unit
	CanCapture     bool                   `protobuf:"varint,6,opt,name=can_capture,json=canCapture,proto3" json:"can_capture,omitempty"`                // Whether this particular unit can capture this terrain/building type
	AttackBonus    int32                  `protobuf:"varint,7,opt,name=attack_bonus,json=attackBonus,proto3" json:"attack_bonus,omitempty"`             // How much more attack this terrain gives to this unit
	DefenseBonus   int32                  `protobuf:"varint,8,opt,name=defense_bonus,json=defenseBonus,proto3" json:"defense_bonus,omitempty"`          // How much more defense this terrain gives to this unit
	AttackRange    int32                  `protobuf:"varint,9,opt,name=attack_range,json=attackRange,proto3" json:"attack_range,omitempty"`             // Max Attack range in tiles
	MinAttackRange int32                  `protobuf:"varint,10,opt,name=min_attack_range,json=minAttackRange,proto3" json:"min_attack_range,omitempty"` // Minimum attack range in tile radius if specified (otherwise - will be 1
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TerrainUnitProperties) Reset() {
	*x = TerrainUnitProperties{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TerrainUnitProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TerrainUnitProperties) ProtoMessage() {}

func (x *TerrainUnitProperties) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TerrainUnitProperties.ProtoReflect.Descriptor instead.
func (*TerrainUnitProperties) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{11}
}

func (x *TerrainUnitProperties) GetTerrainId() int32 {
	if x != nil {
		return x.TerrainId
	}
	return 0
}

func (x *TerrainUnitProperties) GetUnitId() int32 {
	if x != nil {
		return x.UnitId
	}
	return 0
}

func (x *TerrainUnitProperties) GetMovementCost() float64 {
	if x != nil {
		return x.MovementCost
	}
	return 0
}

func (x *TerrainUnitProperties) GetHealingBonus() int32 {
	if x != nil {
		return x.HealingBonus
	}
	return 0
}

func (x *TerrainUnitProperties) GetCanBuild() bool {
	if x != nil {
		return x.CanBuild
	}
	return false
}

func (x *TerrainUnitProperties) GetCanCapture() bool {
	if x != nil {
		return x.CanCapture
	}
	return false
}

func (x *TerrainUnitProperties) GetAttackBonus() int32 {
	if x != nil {
		return x.AttackBonus
	}
	return 0
}

func (x *TerrainUnitProperties) GetDefenseBonus() int32 {
	if x != nil {
		return x.DefenseBonus
	}
	return 0
}

func (x *TerrainUnitProperties) GetAttackRange() int32 {
	if x != nil {
		return x.AttackRange
	}
	return 0
}

func (x *TerrainUnitProperties) GetMinAttackRange() int32 {
	if x != nil {
		return x.MinAttackRange
	}
	return 0
}

// Properties for unit-vs-unit combat interactions
type UnitUnitProperties struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	AttackerId      int32                  `protobuf:"varint,1,opt,name=attacker_id,json=attackerId,proto3" json:"attacker_id,omitempty"`
	DefenderId      int32                  `protobuf:"varint,2,opt,name=defender_id,json=defenderId,proto3" json:"defender_id,omitempty"`
	AttackOverride  *int32                 `protobuf:"varint,3,opt,name=attack_override,json=attackOverride,proto3,oneof" json:"attack_override,omitempty"`    // Optional attack override for this Attacker/Defender combo
	DefenseOverride *int32                 `protobuf:"varint,4,opt,name=defense_override,json=defenseOverride,proto3,oneof" json:"defense_override,omitempty"` // Optional defense override for this Attacker/Defender combo
	Damage          *DamageDistribution    `protobuf:"bytes,5,opt,name=damage,proto3" json:"damage,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *UnitUnitProperties) Reset() {
	*x = UnitUnitProperties{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitUnitProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitUnitProperties) ProtoMessage() {}

func (x *UnitUnitProperties) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitUnitProperties.ProtoReflect.Descriptor instead.
func (*UnitUnitProperties) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{12}
}

func (x *UnitUnitProperties) GetAttackerId() int32 {
	if x != nil {
		return x.AttackerId
	}
	return 0
}

func (x *UnitUnitProperties) GetDefenderId() int32 {
	if x != nil {
		return x.DefenderId
	}
	return 0
}

func (x *UnitUnitProperties) GetAttackOverride() int32 {
	if x != nil && x.AttackOverride != nil {
		return *x.AttackOverride
	}
	return 0
}

func (x *UnitUnitProperties) GetDefenseOverride() int32 {
	if x != nil && x.DefenseOverride != nil {
		return *x.DefenseOverride
	}
	return 0
}

func (x *UnitUnitProperties) GetDamage() *DamageDistribution {
	if x != nil {
		return x.Damage
	}
	return nil
}

// Damage distribution for combat calculations
type DamageDistribution struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	MinDamage      float64                `protobuf:"fixed64,1,opt,name=min_damage,json=minDamage,proto3" json:"min_damage,omitempty"`
	MaxDamage      float64                `protobuf:"fixed64,2,opt,name=max_damage,json=maxDamage,proto3" json:"max_damage,omitempty"`
	ExpectedDamage float64                `protobuf:"fixed64,3,opt,name=expected_damage,json=expectedDamage,proto3" json:"expected_damage,omitempty"`
	Ranges         []*DamageRange         `protobuf:"bytes,4,rep,name=ranges,proto3" json:"ranges,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DamageDistribution) Reset() {
	*x = DamageDistribution{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DamageDistribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DamageDistribution) ProtoMessage() {}

func (x *DamageDistribution) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DamageDistribution.ProtoReflect.Descriptor instead.
func (*DamageDistribution) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{13}
}

func (x *DamageDistribution) GetMinDamage() float64 {
	if x != nil {
		return x.MinDamage
	}
	return 0
}

func (x *DamageDistribution) GetMaxDamage() float64 {
	if x != nil {
		return x.MaxDamage
	}
	return 0
}

func (x *DamageDistribution) GetExpectedDamage() float64 {
	if x != nil {
		return x.ExpectedDamage
	}
	return 0
}

func (x *DamageDistribution) GetRanges() []*DamageRange {
	if x != nil {
		return x.Ranges
	}
	return nil
}

type DamageRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinValue      float64                `protobuf:"fixed64,1,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	MaxValue      float64                `protobuf:"fixed64,2,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	Probability   float64                `protobuf:"fixed64,3,opt,name=probability,proto3" json:"probability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DamageRange) Reset() {
	*x = DamageRange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DamageRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DamageRange) ProtoMessage() {}

func (x *DamageRange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DamageRange.ProtoReflect.Descriptor instead.
func (*DamageRange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{14}
}

func (x *DamageRange) GetMinValue() float64 {
	if x != nil {
		return x.MinValue
	}
	return 0
}

func (x *DamageRange) GetMaxValue() float64 {
	if x != nil {
		return x.MaxValue
	}
	return 0
}

func (x *DamageRange) GetProbability() float64 {
	if x != nil {
		return x.Probability
	}
	return 0
}

// Main rules engine definition - centralized source of truth
type RulesEngine struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Core entity definitions
	Units    map[int32]*UnitDefinition    `protobuf:"bytes,1,rep,name=units,proto3" json:"units,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Terrains map[int32]*TerrainDefinition `protobuf:"bytes,2,rep,name=terrains,proto3" json:"terrains,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Centralized property definitions (source of truth)
	// Key format: "terrain_id:unit_id" (e.g., "1:3" for terrain 1, unit 3)
	TerrainUnitProperties map[string]*TerrainUnitProperties `protobuf:"bytes,3,rep,name=terrain_unit_properties,json=terrainUnitProperties,proto3" json:"terrain_unit_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Key format: "attacker_id:defender_id" (e.g., "1:2" for unit 1 attacking unit 2)
	UnitUnitProperties map[string]*UnitUnitProperties `protobuf:"bytes,4,rep,name=unit_unit_properties,json=unitUnitProperties,proto3" json:"unit_unit_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Terrain type classifications (terrain_id -> TerrainType)
	// Used to determine if a terrain is city, nature, bridge, water, or road
	TerrainTypes  map[int32]TerrainType `protobuf:"bytes,5,rep,name=terrain_types,json=terrainTypes,proto3" json:"terrain_types,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=lilbattle.v1.TerrainType"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RulesEngine) Reset() {
	*x = RulesEngine{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RulesEngine) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RulesEngine) ProtoMessage() {}

func (x *RulesEngine) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RulesEngine.ProtoReflect.Descriptor instead.
func (*RulesEngine) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{15}
}

func (x *RulesEngine) GetUnits() map[int32]*UnitDefinition {
	if x != nil {
		return x.Units
	}
	return nil
}

func (x *RulesEngine) GetTerrains() map[int32]*TerrainDefinition {
	if x != nil {
		return x.Terrains
	}
	return nil
}

func (x *RulesEngine) GetTerrainUnitProperties() map[string]*TerrainUnitProperties {
	if x != nil {
		return x.TerrainUnitProperties
	}
	return nil
}

func (x *RulesEngine) GetUnitUnitProperties() map[string]*UnitUnitProperties {
	if x != nil {
		return x.UnitUnitProperties
	}
	return nil
}

func (x *RulesEngine) GetTerrainTypes() map[int32]TerrainType {
	if x != nil {
		return x.TerrainTypes
	}
	return nil
}

// Describes a game and its metadata
type Game struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// Version number for optimistic locking
	Version int64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// Unique ID for the game
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// User who started/created the game
	CreatorId string `protobuf:"bytes,5,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// The world this game was created from
	WorldId string `protobuf:"bytes,6,opt,name=world_id,json=worldId,proto3" json:"world_id,omitempty"`
	// Name if items have names
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// Description if game has a description
	Description string `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	// Some tags
	Tags []string `protobuf:"bytes,9,rep,name=tags,proto3" json:"tags,omitempty"`
	// A possible image url
	ImageUrl string `protobuf:"bytes,10,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	// Difficulty - example attribute
	Difficulty string `protobuf:"bytes,11,opt,name=difficulty,proto3" json:"difficulty,omitempty"`
	// Game configuration
	Config *GameConfiguration `protobuf:"bytes,12,opt,name=config,proto3" json:"config,omitempty"`
	// URL to screenshot/preview image (defaults to /games/{id}/screenshots/{screenshotName})
	// Can be overridden to point to CDN or external hosting
	PreviewUrls     []string   `protobuf:"bytes,13,rep,name=preview_urls,json=previewUrls,proto3" json:"preview_urls,omitempty"`
	SearchIndexInfo *IndexInfo `protobuf:"bytes,15,opt,name=search_index_info,json=searchIndexInfo,proto3" json:"search_index_info,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Game) Reset() {
	*x = Game{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Game) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Game) ProtoMessage() {}

func (x *Game) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Game.ProtoReflect.Descriptor instead.
func (*Game) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{16}
}

func (x *Game) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Game) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *Game) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Game) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Game) GetCreatorId() string {
	if x != nil {
		return x.CreatorId
	}
	return ""
}

func (x *Game) GetWorldId() string {
	if x != nil {
		return x.WorldId
	}
	return ""
}

func (x *Game) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Game) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Game) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *Game) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

func (x *Game) GetDifficulty() string {
	if x != nil {
		return x.Difficulty
	}
	return ""
}

func (x *Game) GetConfig() *GameConfiguration {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *Game) GetPreviewUrls() []string {
	if x != nil {
		return x.PreviewUrls
	}
	return nil
}

func (x *Game) GetSearchIndexInfo() *IndexInfo {
	if x != nil {
		return x.SearchIndexInfo
	}
	return nil
}

type GameConfiguration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Player configuration
	Players []*GamePlayer `protobuf:"bytes,1,rep,name=players,proto3" json:"players,omitempty"`
	// Team configuration
	Teams []*GameTeam `protobuf:"bytes,2,rep,name=teams,proto3" json:"teams,omitempty"`
	// Various kinds of per turn income configs
	IncomeConfigs *IncomeConfig `protobuf:"bytes,3,opt,name=income_configs,json=incomeConfigs,proto3" json:"income_configs,omitempty"`
	// Game settings
	Settings      *GameSettings `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameConfiguration) Reset() {
	*x = GameConfiguration{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameConfiguration) ProtoMessage() {}

func (x *GameConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameConfiguration.ProtoReflect.Descriptor instead.
func (*GameConfiguration) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{17}
}

func (x *GameConfiguration) GetPlayers() []*GamePlayer {
	if x != nil {
		return x.Players
	}
	return nil
}

func (x *GameConfiguration) GetTeams() []*GameTeam {
	if x != nil {
		return x.Teams
	}
	return nil
}

func (x *GameConfiguration) GetIncomeConfigs() *IncomeConfig {
	if x != nil {
		return x.IncomeConfigs
	}
	return nil
}

func (x *GameConfiguration) GetSettings() *GameSettings {
	if x != nil {
		return x.Settings
	}
	return nil
}

type IncomeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// How much starting coins to give each player at the start of the agme
	StartingCoins int32 `protobuf:"varint,1,opt,name=starting_coins,json=startingCoins,proto3" json:"starting_coins,omitempty"`
	// Income each player just for being in the game each turn
	GameIncome int32 `protobuf:"varint,2,opt,name=game_income,json=gameIncome,proto3" json:"game_income,omitempty"`
	// Income from each landbase per turn
	LandbaseIncome int32 `protobuf:"varint,3,opt,name=landbase_income,json=landbaseIncome,proto3" json:"landbase_income,omitempty"`
	// Income from each navalbase per turn
	NavalbaseIncome int32 `protobuf:"varint,4,opt,name=navalbase_income,json=navalbaseIncome,proto3" json:"navalbase_income,omitempty"`
	// Income from each airport base per turn
	AirportbaseIncome int32 `protobuf:"varint,5,opt,name=airportbase_income,json=airportbaseIncome,proto3" json:"airportbase_income,omitempty"`
	// Income from each missile silo per turn
	MissilesiloIncome int32 `protobuf:"varint,6,opt,name=missilesilo_income,json=missilesiloIncome,proto3" json:"missilesilo_income,omitempty"`
	// Income from each mine per turn
	MinesIncome   int32 `protobuf:"varint,7,opt,name=mines_income,json=minesIncome,proto3" json:"mines_income,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncomeConfig) Reset() {
	*x = IncomeConfig{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncomeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncomeConfig) ProtoMessage() {}

func (x *IncomeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncomeConfig.ProtoReflect.Descriptor instead.
func (*IncomeConfig) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{18}
}

func (x *IncomeConfig) GetStartingCoins() int32 {
	if x != nil {
		return x.StartingCoins
	}
	return 0
}

func (x *IncomeConfig) GetGameIncome() int32 {
	if x != nil {
		return x.GameIncome
	}
	return 0
}

func (x *IncomeConfig) GetLandbaseIncome() int32 {
	if x != nil {
		return x.LandbaseIncome
	}
	return 0
}

func (x *IncomeConfig) GetNavalbaseIncome() int32 {
	if x != nil {
		return x.NavalbaseIncome
	}
	return 0
}

func (x *IncomeConfig) GetAirportbaseIncome() int32 {
	if x != nil {
		return x.AirportbaseIncome
	}
	return 0
}

func (x *IncomeConfig) GetMissilesiloIncome() int32 {
	if x != nil {
		return x.MissilesiloIncome
	}
	return 0
}

func (x *IncomeConfig) GetMinesIncome() int32 {
	if x != nil {
		return x.MinesIncome
	}
	return 0
}

type GamePlayer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Player ID (1-based)
	PlayerId int32 `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	// ID of the system user that is assigned to this game player.  This is the "auth" user
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Player type
	PlayerType string `protobuf:"bytes,3,opt,name=player_type,json=playerType,proto3" json:"player_type,omitempty"` // "human", "ai", "open"
	// Player color
	Color string `protobuf:"bytes,4,opt,name=color,proto3" json:"color,omitempty"`
	// Team ID (0 = no team, 1+ = team number)
	TeamId int32 `protobuf:"varint,5,opt,name=team_id,json=teamId,proto3" json:"team_id,omitempty"`
	// Nickname for the player in this game
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Whether play is still in the game - can this just be inferred?
	IsActive bool `protobuf:"varint,7,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// How many coins the player started off with
	StartingCoins int32 `protobuf:"varint,8,opt,name=starting_coins,json=startingCoins,proto3" json:"starting_coins,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GamePlayer) Reset() {
	*x = GamePlayer{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GamePlayer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GamePlayer) ProtoMessage() {}

func (x *GamePlayer) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GamePlayer.ProtoReflect.Descriptor instead.
func (*GamePlayer) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{19}
}

func (x *GamePlayer) GetPlayerId() int32 {
	if x != nil {
		return x.PlayerId
	}
	return 0
}

func (x *GamePlayer) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GamePlayer) GetPlayerType() string {
	if x != nil {
		return x.PlayerType
	}
	return ""
}

func (x *GamePlayer) GetColor() string {
	if x != nil {
		return x.Color
	}
	return ""
}

func (x *GamePlayer) GetTeamId() int32 {
	if x != nil {
		return x.TeamId
	}
	return 0
}

func (x *GamePlayer) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GamePlayer) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

func (x *GamePlayer) GetStartingCoins() int32 {
	if x != nil {
		return x.StartingCoins
	}
	return 0
}

type GameTeam struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID of the team within the game (unique to the game)
	TeamId int32 `protobuf:"varint,1,opt,name=team_id,json=teamId,proto3" json:"team_id,omitempty"`
	// Name of the team - in a game
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Just a color for this team
	Color string `protobuf:"bytes,3,opt,name=color,proto3" json:"color,omitempty"`
	// Whether team has active players - can also be inferred
	IsActive      bool `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameTeam) Reset() {
	*x = GameTeam{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameTeam) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameTeam) ProtoMessage() {}

func (x *GameTeam) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameTeam.ProtoReflect.Descriptor instead.
func (*GameTeam) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{20}
}

func (x *GameTeam) GetTeamId() int32 {
	if x != nil {
		return x.TeamId
	}
	return 0
}

func (x *GameTeam) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GameTeam) GetColor() string {
	if x != nil {
		return x.Color
	}
	return ""
}

func (x *GameTeam) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

type GameSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of allowed unit type IDs
	AllowedUnits []int32 `protobuf:"varint,1,rep,packed,name=allowed_units,json=allowedUnits,proto3" json:"allowed_units,omitempty"`
	// Turn time limit in seconds (0 = no limit)
	TurnTimeLimit int32 `protobuf:"varint,2,opt,name=turn_time_limit,json=turnTimeLimit,proto3" json:"turn_time_limit,omitempty"`
	// Team mode
	TeamMode string `protobuf:"bytes,3,opt,name=team_mode,json=teamMode,proto3" json:"team_mode,omitempty"` // "ffa" or "teams"
	// Maximum number of turns (0 = unlimited)
	MaxTurns      int32 `protobuf:"varint,4,opt,name=max_turns,json=maxTurns,proto3" json:"max_turns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameSettings) Reset() {
	*x = GameSettings{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameSettings) ProtoMessage() {}

func (x *GameSettings) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameSettings.ProtoReflect.Descriptor instead.
func (*GameSettings) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{21}
}

func (x *GameSettings) GetAllowedUnits() []int32 {
	if x != nil {
		return x.AllowedUnits
	}
	return nil
}

func (x *GameSettings) GetTurnTimeLimit() int32 {
	if x != nil {
		return x.TurnTimeLimit
	}
	return 0
}

func (x *GameSettings) GetTeamMode() string {
	if x != nil {
		return x.TeamMode
	}
	return ""
}

func (x *GameSettings) GetMaxTurns() int32 {
	if x != nil {
		return x.MaxTurns
	}
	return 0
}

// Runtime state for a player during the game
// This is separate from GamePlayer (which is player configuration)
// PlayerState is indexed by player_id in the player_states map
type PlayerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current coin balance (changes during gameplay via building, income, etc.)
	Coins int32 `protobuf:"varint,1,opt,name=coins,proto3" json:"coins,omitempty"`
	// Whether player is still active in the game (not eliminated)
	IsActive      bool `protobuf:"varint,2,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlayerState) Reset() {
	*x = PlayerState{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlayerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlayerState) ProtoMessage() {}

func (x *PlayerState) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlayerState.ProtoReflect.Descriptor instead.
func (*PlayerState) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{22}
}

func (x *PlayerState) GetCoins() int32 {
	if x != nil {
		return x.Coins
	}
	return 0
}

func (x *PlayerState) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

// Holds the game's Active/Current state (eg world state)
type GameState struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// ID of the game whos state is being tracked
	GameId        string `protobuf:"bytes,3,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	TurnCounter   int32  `protobuf:"varint,4,opt,name=turn_counter,json=turnCounter,proto3" json:"turn_counter,omitempty"`
	CurrentPlayer int32  `protobuf:"varint,5,opt,name=current_player,json=currentPlayer,proto3" json:"current_player,omitempty"`
	// Current world state
	WorldData *WorldData `protobuf:"bytes,6,opt,name=world_data,json=worldData,proto3" json:"world_data,omitempty"`
	// Current state hash for validation
	StateHash string `protobuf:"bytes,8,opt,name=state_hash,json=stateHash,proto3" json:"state_hash,omitempty"`
	// Version number for optimistic locking
	Version int64      `protobuf:"varint,9,opt,name=version,proto3" json:"version,omitempty"`
	Status  GameStatus `protobuf:"varint,10,opt,name=status,proto3,enum=lilbattle.v1.GameStatus" json:"status,omitempty"`
	// Only set after a win has been possible
	Finished           bool  `protobuf:"varint,11,opt,name=finished,proto3" json:"finished,omitempty"`
	WinningPlayer      int32 `protobuf:"varint,12,opt,name=winning_player,json=winningPlayer,proto3" json:"winning_player,omitempty"`
	WinningTeam        int32 `protobuf:"varint,13,opt,name=winning_team,json=winningTeam,proto3" json:"winning_team,omitempty"`
	CurrentGroupNumber int64 `protobuf:"varint,14,opt,name=current_group_number,json=currentGroupNumber,proto3" json:"current_group_number,omitempty"`
	// Per-player runtime state, keyed by player_id (1-based)
	// This holds mutable player state like coins that changes during gameplay
	PlayerStates  map[int32]*PlayerState `protobuf:"bytes,15,rep,name=player_states,json=playerStates,proto3" json:"player_states,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameState) Reset() {
	*x = GameState{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameState) ProtoMessage() {}

func (x *GameState) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameState.ProtoReflect.Descriptor instead.
func (*GameState) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{23}
}

func (x *GameState) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *GameState) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *GameState) GetTurnCounter() int32 {
	if x != nil {
		return x.TurnCounter
	}
	return 0
}

func (x *GameState) GetCurrentPlayer() int32 {
	if x != nil {
		return x.CurrentPlayer
	}
	return 0
}

func (x *GameState) GetWorldData() *WorldData {
	if x != nil {
		return x.WorldData
	}
	return nil
}

func (x *GameState) GetStateHash() string {
	if x != nil {
		return x.StateHash
	}
	return ""
}

func (x *GameState) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *GameState) GetStatus() GameStatus {
	if x != nil {
		return x.Status
	}
	return GameStatus_GAME_STATUS_UNSPECIFIED
}

func (x *GameState) GetFinished() bool {
	if x != nil {
		return x.Finished
	}
	return false
}

func (x *GameState) GetWinningPlayer() int32 {
	if x != nil {
		return x.WinningPlayer
	}
	return 0
}

func (x *GameState) GetWinningTeam() int32 {
	if x != nil {
		return x.WinningTeam
	}
	return 0
}

func (x *GameState) GetCurrentGroupNumber() int64 {
	if x != nil {
		return x.CurrentGroupNumber
	}
	return 0
}

func (x *GameState) GetPlayerStates() map[int32]*PlayerState {
	if x != nil {
		return x.PlayerStates
	}
	return nil
}

// Holds the game's move history (can be used as a replay log)
type GameMoveHistory struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Move history for the game
	GameId string `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	// Each entry in our history is a "group" of moves
	Groups        []*GameMoveGroup `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameMoveHistory) Reset() {
	*x = GameMoveHistory{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameMoveHistory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameMoveHistory) ProtoMessage() {}

func (x *GameMoveHistory) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameMoveHistory.ProtoReflect.Descriptor instead.
func (*GameMoveHistory) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{24}
}

func (x *GameMoveHistory) GetGameId() string {
	if x != nil {
		return x.GameId
	}
	return ""
}

func (x *GameMoveHistory) GetGroups() []*GameMoveGroup {
	if x != nil {
		return x.Groups
	}
	return nil
}

// A move group - we can allow X moves in one "tick"
type GameMoveGroup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When the moves happened (or were submitted)
	StartedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	EndedAt   *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=ended_at,json=endedAt,proto3" json:"ended_at,omitempty"`
	// Group number within the game - will be monotonically increasing
	GroupNumber int64 `protobuf:"varint,4,opt,name=group_number,json=groupNumber,proto3" json:"group_number,omitempty"`
	// *
	// List of moves to add -
	Moves         []*GameMove `protobuf:"bytes,5,rep,name=moves,proto3" json:"moves,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameMoveGroup) Reset() {
	*x = GameMoveGroup{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameMoveGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameMoveGroup) ProtoMessage() {}

func (x *GameMoveGroup) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameMoveGroup.ProtoReflect.Descriptor instead.
func (*GameMoveGroup) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{25}
}

func (x *GameMoveGroup) GetStartedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.StartedAt
	}
	return nil
}

func (x *GameMoveGroup) GetEndedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.EndedAt
	}
	return nil
}

func (x *GameMoveGroup) GetGroupNumber() int64 {
	if x != nil {
		return x.GroupNumber
	}
	return 0
}

func (x *GameMoveGroup) GetMoves() []*GameMove {
	if x != nil {
		return x.Moves
	}
	return nil
}

// *
// Represents a single move which can be one of many actions in the game
type GameMove struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Player int32                  `protobuf:"varint,1,opt,name=player,proto3" json:"player,omitempty"` // The player making the move
	// Generated by the server
	GroupNumber int64 `protobuf:"varint,2,opt,name=group_number,json=groupNumber,proto3" json:"group_number,omitempty"`
	// Generated by the server - will be monotonically increasing within the group
	MoveNumber int64                  `protobuf:"varint,3,opt,name=move_number,json=moveNumber,proto3" json:"move_number,omitempty"`
	Timestamp  *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to MoveType:
	//
	//	*GameMove_MoveUnit
	//	*GameMove_AttackUnit
	//	*GameMove_EndTurn
	//	*GameMove_BuildUnit
	//	*GameMove_CaptureBuilding
	//	*GameMove_HealUnit
	//	*GameMove_FixUnit
	MoveType isGameMove_MoveType `protobuf_oneof:"move_type"`
	// A monotonically increasing and unique (within the game) sequence number for the move
	// This is generated by the server
	SequenceNum int64 `protobuf:"varint,9,opt,name=sequence_num,json=sequenceNum,proto3" json:"sequence_num,omitempty"`
	// Whether the result is permenant and can be undone.
	// Just moving a unit for example is not permanent, but attacking a unit
	// would be (ie a player cannot undo it).  This is also determined by the server/validator
	IsPermanent bool `protobuf:"varint,10,opt,name=is_permanent,json=isPermanent,proto3" json:"is_permanent,omitempty"`
	// The corresponding "result" for the move.  This can be "proposed" or can be evaluated.
	// Keeping this colocated with the Move for consistency and simplicity
	Changes []*WorldChange `protobuf:"bytes,11,rep,name=changes,proto3" json:"changes,omitempty"`
	// Human redable description for say recording "commands" if any
	Description   string `protobuf:"bytes,12,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameMove) Reset() {
	*x = GameMove{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameMove) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameMove) ProtoMessage() {}

func (x *GameMove) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameMove.ProtoReflect.Descriptor instead.
func (*GameMove) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{26}
}

func (x *GameMove) GetPlayer() int32 {
	if x != nil {
		return x.Player
	}
	return 0
}

func (x *GameMove) GetGroupNumber() int64 {
	if x != nil {
		return x.GroupNumber
	}
	return 0
}

func (x *GameMove) GetMoveNumber() int64 {
	if x != nil {
		return x.MoveNumber
	}
	return 0
}

func (x *GameMove) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *GameMove) GetMoveType() isGameMove_MoveType {
	if x != nil {
		return x.MoveType
	}
	return nil
}

func (x *GameMove) GetMoveUnit() *MoveUnitAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_MoveUnit); ok {
			return x.MoveUnit
		}
	}
	return nil
}

func (x *GameMove) GetAttackUnit() *AttackUnitAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_AttackUnit); ok {
			return x.AttackUnit
		}
	}
	return nil
}

func (x *GameMove) GetEndTurn() *EndTurnAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_EndTurn); ok {
			return x.EndTurn
		}
	}
	return nil
}

func (x *GameMove) GetBuildUnit() *BuildUnitAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_BuildUnit); ok {
			return x.BuildUnit
		}
	}
	return nil
}

func (x *GameMove) GetCaptureBuilding() *CaptureBuildingAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_CaptureBuilding); ok {
			return x.CaptureBuilding
		}
	}
	return nil
}

func (x *GameMove) GetHealUnit() *HealUnitAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_HealUnit); ok {
			return x.HealUnit
		}
	}
	return nil
}

func (x *GameMove) GetFixUnit() *FixUnitAction {
	if x != nil {
		if x, ok := x.MoveType.(*GameMove_FixUnit); ok {
			return x.FixUnit
		}
	}
	return nil
}

func (x *GameMove) GetSequenceNum() int64 {
	if x != nil {
		return x.SequenceNum
	}
	return 0
}

func (x *GameMove) GetIsPermanent() bool {
	if x != nil {
		return x.IsPermanent
	}
	return false
}

func (x *GameMove) GetChanges() []*WorldChange {
	if x != nil {
		return x.Changes
	}
	return nil
}

func (x *GameMove) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type isGameMove_MoveType interface {
	isGameMove_MoveType()
}

type GameMove_MoveUnit struct {
	MoveUnit *MoveUnitAction `protobuf:"bytes,5,opt,name=move_unit,json=moveUnit,proto3,oneof"`
}

type GameMove_AttackUnit struct {
	AttackUnit *AttackUnitAction `protobuf:"bytes,6,opt,name=attack_unit,json=attackUnit,proto3,oneof"`
}

type GameMove_EndTurn struct {
	EndTurn *EndTurnAction `protobuf:"bytes,7,opt,name=end_turn,json=endTurn,proto3,oneof"`
}

type GameMove_BuildUnit struct {
	BuildUnit *BuildUnitAction `protobuf:"bytes,8,opt,name=build_unit,json=buildUnit,proto3,oneof"`
}

type GameMove_CaptureBuilding struct {
	CaptureBuilding *CaptureBuildingAction `protobuf:"bytes,13,opt,name=capture_building,json=captureBuilding,proto3,oneof"`
}

type GameMove_HealUnit struct {
	HealUnit *HealUnitAction `protobuf:"bytes,14,opt,name=heal_unit,json=healUnit,proto3,oneof"`
}

type GameMove_FixUnit struct {
	FixUnit *FixUnitAction `protobuf:"bytes,15,opt,name=fix_unit,json=fixUnit,proto3,oneof"`
}

func (*GameMove_MoveUnit) isGameMove_MoveType() {}

func (*GameMove_AttackUnit) isGameMove_MoveType() {}

func (*GameMove_EndTurn) isGameMove_MoveType() {}

func (*GameMove_BuildUnit) isGameMove_MoveType() {}

func (*GameMove_CaptureBuilding) isGameMove_MoveType() {}

func (*GameMove_HealUnit) isGameMove_MoveType() {}

func (*GameMove_FixUnit) isGameMove_MoveType() {}

// A unified "Position" type that can be used to
// specify locations via "string shortcuts" like A1, "3,2", "r2,4" (for row/col)
// or even "relative" positions like "L,TL,TR,R"  in the shortcut field.
// Or string q/r coordinates in the q and r fields.  This can also be used
// in the "response" to resolve a shortcut -> q,r
type Position struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Label         string                 `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Q             int32                  `protobuf:"varint,2,opt,name=q,proto3" json:"q,omitempty"`
	R             int32                  `protobuf:"varint,3,opt,name=r,proto3" json:"r,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Position) Reset() {
	*x = Position{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{27}
}

func (x *Position) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Position) GetQ() int32 {
	if x != nil {
		return x.Q
	}
	return 0
}

func (x *Position) GetR() int32 {
	if x != nil {
		return x.R
	}
	return 0
}

// *
// Move unit from one position to another
type MoveUnitAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	From  *Position              `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To    *Position              `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	// Optional fields that can be used for showing move options as well as debugging
	MovementCost float64 `protobuf:"fixed64,3,opt,name=movement_cost,json=movementCost,proto3" json:"movement_cost,omitempty"`
	// Debug fields
	ReconstructedPath *Path `protobuf:"bytes,4,opt,name=reconstructed_path,json=reconstructedPath,proto3" json:"reconstructed_path,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *MoveUnitAction) Reset() {
	*x = MoveUnitAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MoveUnitAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MoveUnitAction) ProtoMessage() {}

func (x *MoveUnitAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MoveUnitAction.ProtoReflect.Descriptor instead.
func (*MoveUnitAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{28}
}

func (x *MoveUnitAction) GetFrom() *Position {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *MoveUnitAction) GetTo() *Position {
	if x != nil {
		return x.To
	}
	return nil
}

func (x *MoveUnitAction) GetMovementCost() float64 {
	if x != nil {
		return x.MovementCost
	}
	return 0
}

func (x *MoveUnitAction) GetReconstructedPath() *Path {
	if x != nil {
		return x.ReconstructedPath
	}
	return nil
}

// *
// Attack with one unit against another
type AttackUnitAction struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Attacker *Position              `protobuf:"bytes,1,opt,name=attacker,proto3" json:"attacker,omitempty"`
	Defender *Position              `protobuf:"bytes,2,opt,name=defender,proto3" json:"defender,omitempty"`
	// Optional fields for presenting during "options" and debugging
	TargetUnitType   int32 `protobuf:"varint,7,opt,name=target_unit_type,json=targetUnitType,proto3" json:"target_unit_type,omitempty"`
	TargetUnitHealth int32 `protobuf:"varint,8,opt,name=target_unit_health,json=targetUnitHealth,proto3" json:"target_unit_health,omitempty"`
	CanAttack        bool  `protobuf:"varint,9,opt,name=can_attack,json=canAttack,proto3" json:"can_attack,omitempty"`
	DamageEstimate   int32 `protobuf:"varint,10,opt,name=damage_estimate,json=damageEstimate,proto3" json:"damage_estimate,omitempty"` // Estimated damage this attack would deal
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AttackUnitAction) Reset() {
	*x = AttackUnitAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttackUnitAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttackUnitAction) ProtoMessage() {}

func (x *AttackUnitAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttackUnitAction.ProtoReflect.Descriptor instead.
func (*AttackUnitAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{29}
}

func (x *AttackUnitAction) GetAttacker() *Position {
	if x != nil {
		return x.Attacker
	}
	return nil
}

func (x *AttackUnitAction) GetDefender() *Position {
	if x != nil {
		return x.Defender
	}
	return nil
}

func (x *AttackUnitAction) GetTargetUnitType() int32 {
	if x != nil {
		return x.TargetUnitType
	}
	return 0
}

func (x *AttackUnitAction) GetTargetUnitHealth() int32 {
	if x != nil {
		return x.TargetUnitHealth
	}
	return 0
}

func (x *AttackUnitAction) GetCanAttack() bool {
	if x != nil {
		return x.CanAttack
	}
	return false
}

func (x *AttackUnitAction) GetDamageEstimate() int32 {
	if x != nil {
		return x.DamageEstimate
	}
	return 0
}

// *
// An action to build a unit (at a city tile)
type BuildUnitAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pos           *Position              `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`
	UnitType      int32                  `protobuf:"varint,2,opt,name=unit_type,json=unitType,proto3" json:"unit_type,omitempty"`
	Cost          int32                  `protobuf:"varint,3,opt,name=cost,proto3" json:"cost,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildUnitAction) Reset() {
	*x = BuildUnitAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildUnitAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildUnitAction) ProtoMessage() {}

func (x *BuildUnitAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildUnitAction.ProtoReflect.Descriptor instead.
func (*BuildUnitAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{30}
}

func (x *BuildUnitAction) GetPos() *Position {
	if x != nil {
		return x.Pos
	}
	return nil
}

func (x *BuildUnitAction) GetUnitType() int32 {
	if x != nil {
		return x.UnitType
	}
	return 0
}

func (x *BuildUnitAction) GetCost() int32 {
	if x != nil {
		return x.Cost
	}
	return 0
}

// *
// A move where a unit can capture a building
type CaptureBuildingAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pos           *Position              `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`
	TileType      int32                  `protobuf:"varint,3,opt,name=tile_type,json=tileType,proto3" json:"tile_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CaptureBuildingAction) Reset() {
	*x = CaptureBuildingAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CaptureBuildingAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CaptureBuildingAction) ProtoMessage() {}

func (x *CaptureBuildingAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CaptureBuildingAction.ProtoReflect.Descriptor instead.
func (*CaptureBuildingAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{31}
}

func (x *CaptureBuildingAction) GetPos() *Position {
	if x != nil {
		return x.Pos
	}
	return nil
}

func (x *CaptureBuildingAction) GetTileType() int32 {
	if x != nil {
		return x.TileType
	}
	return 0
}

// *
// End current player's turn
type EndTurnAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndTurnAction) Reset() {
	*x = EndTurnAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndTurnAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndTurnAction) ProtoMessage() {}

func (x *EndTurnAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndTurnAction.ProtoReflect.Descriptor instead.
func (*EndTurnAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{32}
}

// *
// Heal a unit - player manually chooses to heal instead of attacking/moving
// Auto-healing at turn start is handled separately in TopUpUnitIfNeeded
type HealUnitAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pos           *Position              `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`                                  // Position of unit to heal
	HealAmount    int32                  `protobuf:"varint,2,opt,name=heal_amount,json=healAmount,proto3" json:"heal_amount,omitempty"` // Amount of health to restore
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealUnitAction) Reset() {
	*x = HealUnitAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealUnitAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealUnitAction) ProtoMessage() {}

func (x *HealUnitAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealUnitAction.ProtoReflect.Descriptor instead.
func (*HealUnitAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{33}
}

func (x *HealUnitAction) GetPos() *Position {
	if x != nil {
		return x.Pos
	}
	return nil
}

func (x *HealUnitAction) GetHealAmount() int32 {
	if x != nil {
		return x.HealAmount
	}
	return 0
}

// *
// Fix (repair) another friendly unit - used by Medic, Engineer, Stratotanker, Tugboat, Aircraft Carrier
// The fixer must be adjacent to the target unit
type FixUnitAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fixer         *Position              `protobuf:"bytes,1,opt,name=fixer,proto3" json:"fixer,omitempty"`                           // Position of the unit doing the fixing
	Target        *Position              `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`                         // Position of the friendly unit being fixed
	FixAmount     int32                  `protobuf:"varint,3,opt,name=fix_amount,json=fixAmount,proto3" json:"fix_amount,omitempty"` // Amount of health to restore (optional, server calculates if not provided)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FixUnitAction) Reset() {
	*x = FixUnitAction{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FixUnitAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FixUnitAction) ProtoMessage() {}

func (x *FixUnitAction) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FixUnitAction.ProtoReflect.Descriptor instead.
func (*FixUnitAction) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{34}
}

func (x *FixUnitAction) GetFixer() *Position {
	if x != nil {
		return x.Fixer
	}
	return nil
}

func (x *FixUnitAction) GetTarget() *Position {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *FixUnitAction) GetFixAmount() int32 {
	if x != nil {
		return x.FixAmount
	}
	return 0
}

// *
// Represents a change to the game world
type WorldChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When did this change happen
	//
	// Types that are valid to be assigned to ChangeType:
	//
	//	*WorldChange_UnitMoved
	//	*WorldChange_UnitDamaged
	//	*WorldChange_UnitKilled
	//	*WorldChange_PlayerChanged
	//	*WorldChange_UnitBuilt
	//	*WorldChange_CoinsChanged
	//	*WorldChange_TileCaptured
	//	*WorldChange_CaptureStarted
	//	*WorldChange_UnitHealed
	//	*WorldChange_UnitFixed
	ChangeType    isWorldChange_ChangeType `protobuf_oneof:"change_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorldChange) Reset() {
	*x = WorldChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorldChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorldChange) ProtoMessage() {}

func (x *WorldChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorldChange.ProtoReflect.Descriptor instead.
func (*WorldChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{35}
}

func (x *WorldChange) GetChangeType() isWorldChange_ChangeType {
	if x != nil {
		return x.ChangeType
	}
	return nil
}

func (x *WorldChange) GetUnitMoved() *UnitMovedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_UnitMoved); ok {
			return x.UnitMoved
		}
	}
	return nil
}

func (x *WorldChange) GetUnitDamaged() *UnitDamagedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_UnitDamaged); ok {
			return x.UnitDamaged
		}
	}
	return nil
}

func (x *WorldChange) GetUnitKilled() *UnitKilledChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_UnitKilled); ok {
			return x.UnitKilled
		}
	}
	return nil
}

func (x *WorldChange) GetPlayerChanged() *PlayerChangedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_PlayerChanged); ok {
			return x.PlayerChanged
		}
	}
	return nil
}

func (x *WorldChange) GetUnitBuilt() *UnitBuiltChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_UnitBuilt); ok {
			return x.UnitBuilt
		}
	}
	return nil
}

func (x *WorldChange) GetCoinsChanged() *CoinsChangedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_CoinsChanged); ok {
			return x.CoinsChanged
		}
	}
	return nil
}

func (x *WorldChange) GetTileCaptured() *TileCapturedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_TileCaptured); ok {
			return x.TileCaptured
		}
	}
	return nil
}

func (x *WorldChange) GetCaptureStarted() *CaptureStartedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_CaptureStarted); ok {
			return x.CaptureStarted
		}
	}
	return nil
}

func (x *WorldChange) GetUnitHealed() *UnitHealedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_UnitHealed); ok {
			return x.UnitHealed
		}
	}
	return nil
}

func (x *WorldChange) GetUnitFixed() *UnitFixedChange {
	if x != nil {
		if x, ok := x.ChangeType.(*WorldChange_UnitFixed); ok {
			return x.UnitFixed
		}
	}
	return nil
}

type isWorldChange_ChangeType interface {
	isWorldChange_ChangeType()
}

type WorldChange_UnitMoved struct {
	UnitMoved *UnitMovedChange `protobuf:"bytes,1,opt,name=unit_moved,json=unitMoved,proto3,oneof"`
}

type WorldChange_UnitDamaged struct {
	UnitDamaged *UnitDamagedChange `protobuf:"bytes,2,opt,name=unit_damaged,json=unitDamaged,proto3,oneof"`
}

type WorldChange_UnitKilled struct {
	UnitKilled *UnitKilledChange `protobuf:"bytes,3,opt,name=unit_killed,json=unitKilled,proto3,oneof"`
}

type WorldChange_PlayerChanged struct {
	PlayerChanged *PlayerChangedChange `protobuf:"bytes,4,opt,name=player_changed,json=playerChanged,proto3,oneof"`
}

type WorldChange_UnitBuilt struct {
	UnitBuilt *UnitBuiltChange `protobuf:"bytes,5,opt,name=unit_built,json=unitBuilt,proto3,oneof"`
}

type WorldChange_CoinsChanged struct {
	CoinsChanged *CoinsChangedChange `protobuf:"bytes,6,opt,name=coins_changed,json=coinsChanged,proto3,oneof"`
}

type WorldChange_TileCaptured struct {
	TileCaptured *TileCapturedChange `protobuf:"bytes,7,opt,name=tile_captured,json=tileCaptured,proto3,oneof"`
}

type WorldChange_CaptureStarted struct {
	CaptureStarted *CaptureStartedChange `protobuf:"bytes,8,opt,name=capture_started,json=captureStarted,proto3,oneof"`
}

type WorldChange_UnitHealed struct {
	UnitHealed *UnitHealedChange `protobuf:"bytes,9,opt,name=unit_healed,json=unitHealed,proto3,oneof"`
}

type WorldChange_UnitFixed struct {
	UnitFixed *UnitFixedChange `protobuf:"bytes,10,opt,name=unit_fixed,json=unitFixed,proto3,oneof"`
}

func (*WorldChange_UnitMoved) isWorldChange_ChangeType() {}

func (*WorldChange_UnitDamaged) isWorldChange_ChangeType() {}

func (*WorldChange_UnitKilled) isWorldChange_ChangeType() {}

func (*WorldChange_PlayerChanged) isWorldChange_ChangeType() {}

func (*WorldChange_UnitBuilt) isWorldChange_ChangeType() {}

func (*WorldChange_CoinsChanged) isWorldChange_ChangeType() {}

func (*WorldChange_TileCaptured) isWorldChange_ChangeType() {}

func (*WorldChange_CaptureStarted) isWorldChange_ChangeType() {}

func (*WorldChange_UnitHealed) isWorldChange_ChangeType() {}

func (*WorldChange_UnitFixed) isWorldChange_ChangeType() {}

// *
// A unit was healed
type UnitHealedChange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PreviousUnit  *Unit                  `protobuf:"bytes,1,opt,name=previous_unit,json=previousUnit,proto3" json:"previous_unit,omitempty"` // Unit state before healing
	UpdatedUnit   *Unit                  `protobuf:"bytes,2,opt,name=updated_unit,json=updatedUnit,proto3" json:"updated_unit,omitempty"`    // Unit state after healing
	HealAmount    int32                  `protobuf:"varint,3,opt,name=heal_amount,json=healAmount,proto3" json:"heal_amount,omitempty"`      // Amount healed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnitHealedChange) Reset() {
	*x = UnitHealedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitHealedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitHealedChange) ProtoMessage() {}

func (x *UnitHealedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitHealedChange.ProtoReflect.Descriptor instead.
func (*UnitHealedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{36}
}

func (x *UnitHealedChange) GetPreviousUnit() *Unit {
	if x != nil {
		return x.PreviousUnit
	}
	return nil
}

func (x *UnitHealedChange) GetUpdatedUnit() *Unit {
	if x != nil {
		return x.UpdatedUnit
	}
	return nil
}

func (x *UnitHealedChange) GetHealAmount() int32 {
	if x != nil {
		return x.HealAmount
	}
	return 0
}

// *
// A unit was fixed (repaired) by another unit
type UnitFixedChange struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	FixerUnit      *Unit                  `protobuf:"bytes,1,opt,name=fixer_unit,json=fixerUnit,proto3" json:"fixer_unit,omitempty"`                // Unit that performed the fix
	PreviousTarget *Unit                  `protobuf:"bytes,2,opt,name=previous_target,json=previousTarget,proto3" json:"previous_target,omitempty"` // Target unit state before fix
	UpdatedTarget  *Unit                  `protobuf:"bytes,3,opt,name=updated_target,json=updatedTarget,proto3" json:"updated_target,omitempty"`    // Target unit state after fix
	FixAmount      int32                  `protobuf:"varint,4,opt,name=fix_amount,json=fixAmount,proto3" json:"fix_amount,omitempty"`               // Amount of health restored
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *UnitFixedChange) Reset() {
	*x = UnitFixedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitFixedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitFixedChange) ProtoMessage() {}

func (x *UnitFixedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitFixedChange.ProtoReflect.Descriptor instead.
func (*UnitFixedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{37}
}

func (x *UnitFixedChange) GetFixerUnit() *Unit {
	if x != nil {
		return x.FixerUnit
	}
	return nil
}

func (x *UnitFixedChange) GetPreviousTarget() *Unit {
	if x != nil {
		return x.PreviousTarget
	}
	return nil
}

func (x *UnitFixedChange) GetUpdatedTarget() *Unit {
	if x != nil {
		return x.UpdatedTarget
	}
	return nil
}

func (x *UnitFixedChange) GetFixAmount() int32 {
	if x != nil {
		return x.FixAmount
	}
	return 0
}

// *
// A unit moved from one position to another
type UnitMovedChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Complete unit state before the move
	PreviousUnit *Unit `protobuf:"bytes,6,opt,name=previous_unit,json=previousUnit,proto3" json:"previous_unit,omitempty"`
	// Complete unit state after the move (includes updated position, distanceLeft, etc.)
	UpdatedUnit   *Unit `protobuf:"bytes,7,opt,name=updated_unit,json=updatedUnit,proto3" json:"updated_unit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnitMovedChange) Reset() {
	*x = UnitMovedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitMovedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitMovedChange) ProtoMessage() {}

func (x *UnitMovedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitMovedChange.ProtoReflect.Descriptor instead.
func (*UnitMovedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{38}
}

func (x *UnitMovedChange) GetPreviousUnit() *Unit {
	if x != nil {
		return x.PreviousUnit
	}
	return nil
}

func (x *UnitMovedChange) GetUpdatedUnit() *Unit {
	if x != nil {
		return x.UpdatedUnit
	}
	return nil
}

// *
// A unit took damage
type UnitDamagedChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Complete unit state before taking damage
	PreviousUnit *Unit `protobuf:"bytes,6,opt,name=previous_unit,json=previousUnit,proto3" json:"previous_unit,omitempty"`
	// Complete unit state after taking damage
	UpdatedUnit   *Unit `protobuf:"bytes,7,opt,name=updated_unit,json=updatedUnit,proto3" json:"updated_unit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnitDamagedChange) Reset() {
	*x = UnitDamagedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitDamagedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitDamagedChange) ProtoMessage() {}

func (x *UnitDamagedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitDamagedChange.ProtoReflect.Descriptor instead.
func (*UnitDamagedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{39}
}

func (x *UnitDamagedChange) GetPreviousUnit() *Unit {
	if x != nil {
		return x.PreviousUnit
	}
	return nil
}

func (x *UnitDamagedChange) GetUpdatedUnit() *Unit {
	if x != nil {
		return x.UpdatedUnit
	}
	return nil
}

// *
// A unit was killed
type UnitKilledChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Complete unit state before being killed
	PreviousUnit  *Unit `protobuf:"bytes,6,opt,name=previous_unit,json=previousUnit,proto3" json:"previous_unit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnitKilledChange) Reset() {
	*x = UnitKilledChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitKilledChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitKilledChange) ProtoMessage() {}

func (x *UnitKilledChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitKilledChange.ProtoReflect.Descriptor instead.
func (*UnitKilledChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{40}
}

func (x *UnitKilledChange) GetPreviousUnit() *Unit {
	if x != nil {
		return x.PreviousUnit
	}
	return nil
}

// *
// Active player changed
type PlayerChangedChange struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	PreviousPlayer int32                  `protobuf:"varint,1,opt,name=previous_player,json=previousPlayer,proto3" json:"previous_player,omitempty"`
	NewPlayer      int32                  `protobuf:"varint,2,opt,name=new_player,json=newPlayer,proto3" json:"new_player,omitempty"`
	PreviousTurn   int32                  `protobuf:"varint,3,opt,name=previous_turn,json=previousTurn,proto3" json:"previous_turn,omitempty"`
	NewTurn        int32                  `protobuf:"varint,4,opt,name=new_turn,json=newTurn,proto3" json:"new_turn,omitempty"`
	// Units that had their movement/health reset for the new turn
	ResetUnits    []*Unit `protobuf:"bytes,5,rep,name=reset_units,json=resetUnits,proto3" json:"reset_units,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlayerChangedChange) Reset() {
	*x = PlayerChangedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlayerChangedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlayerChangedChange) ProtoMessage() {}

func (x *PlayerChangedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlayerChangedChange.ProtoReflect.Descriptor instead.
func (*PlayerChangedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{41}
}

func (x *PlayerChangedChange) GetPreviousPlayer() int32 {
	if x != nil {
		return x.PreviousPlayer
	}
	return 0
}

func (x *PlayerChangedChange) GetNewPlayer() int32 {
	if x != nil {
		return x.NewPlayer
	}
	return 0
}

func (x *PlayerChangedChange) GetPreviousTurn() int32 {
	if x != nil {
		return x.PreviousTurn
	}
	return 0
}

func (x *PlayerChangedChange) GetNewTurn() int32 {
	if x != nil {
		return x.NewTurn
	}
	return 0
}

func (x *PlayerChangedChange) GetResetUnits() []*Unit {
	if x != nil {
		return x.ResetUnits
	}
	return nil
}

// *
// A new unit was built at a tile
type UnitBuiltChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The newly created unit
	Unit *Unit `protobuf:"bytes,1,opt,name=unit,proto3" json:"unit,omitempty"`
	// Tile coordinates where unit was built
	TileQ int32 `protobuf:"varint,2,opt,name=tile_q,json=tileQ,proto3" json:"tile_q,omitempty"`
	TileR int32 `protobuf:"varint,3,opt,name=tile_r,json=tileR,proto3" json:"tile_r,omitempty"`
	// Cost in coins
	CoinsCost int32 `protobuf:"varint,4,opt,name=coins_cost,json=coinsCost,proto3" json:"coins_cost,omitempty"`
	// Player's remaining coins after build
	PlayerCoins   int32 `protobuf:"varint,5,opt,name=player_coins,json=playerCoins,proto3" json:"player_coins,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnitBuiltChange) Reset() {
	*x = UnitBuiltChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnitBuiltChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnitBuiltChange) ProtoMessage() {}

func (x *UnitBuiltChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnitBuiltChange.ProtoReflect.Descriptor instead.
func (*UnitBuiltChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{42}
}

func (x *UnitBuiltChange) GetUnit() *Unit {
	if x != nil {
		return x.Unit
	}
	return nil
}

func (x *UnitBuiltChange) GetTileQ() int32 {
	if x != nil {
		return x.TileQ
	}
	return 0
}

func (x *UnitBuiltChange) GetTileR() int32 {
	if x != nil {
		return x.TileR
	}
	return 0
}

func (x *UnitBuiltChange) GetCoinsCost() int32 {
	if x != nil {
		return x.CoinsCost
	}
	return 0
}

func (x *UnitBuiltChange) GetPlayerCoins() int32 {
	if x != nil {
		return x.PlayerCoins
	}
	return 0
}

// *
// A player's coin balance changed
type CoinsChangedChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Which player's coins changed
	PlayerId int32 `protobuf:"varint,1,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	// Previous coin balance
	PreviousCoins int32 `protobuf:"varint,2,opt,name=previous_coins,json=previousCoins,proto3" json:"previous_coins,omitempty"`
	// New coin balance
	NewCoins int32 `protobuf:"varint,3,opt,name=new_coins,json=newCoins,proto3" json:"new_coins,omitempty"`
	// Reason for change: "build", "income", "repair", etc.
	Reason        string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CoinsChangedChange) Reset() {
	*x = CoinsChangedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CoinsChangedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CoinsChangedChange) ProtoMessage() {}

func (x *CoinsChangedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CoinsChangedChange.ProtoReflect.Descriptor instead.
func (*CoinsChangedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{43}
}

func (x *CoinsChangedChange) GetPlayerId() int32 {
	if x != nil {
		return x.PlayerId
	}
	return 0
}

func (x *CoinsChangedChange) GetPreviousCoins() int32 {
	if x != nil {
		return x.PreviousCoins
	}
	return 0
}

func (x *CoinsChangedChange) GetNewCoins() int32 {
	if x != nil {
		return x.NewCoins
	}
	return 0
}

func (x *CoinsChangedChange) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// *
// A tile was captured by a unit
type TileCapturedChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unit that captured the tile
	CapturingUnit *Unit `protobuf:"bytes,1,opt,name=capturing_unit,json=capturingUnit,proto3" json:"capturing_unit,omitempty"`
	// Tile coordinates
	TileQ int32 `protobuf:"varint,2,opt,name=tile_q,json=tileQ,proto3" json:"tile_q,omitempty"`
	TileR int32 `protobuf:"varint,3,opt,name=tile_r,json=tileR,proto3" json:"tile_r,omitempty"`
	// Tile type
	TileType int32 `protobuf:"varint,4,opt,name=tile_type,json=tileType,proto3" json:"tile_type,omitempty"`
	// Previous owner (0 for neutral)
	PreviousOwner int32 `protobuf:"varint,5,opt,name=previous_owner,json=previousOwner,proto3" json:"previous_owner,omitempty"`
	// New owner
	NewOwner      int32 `protobuf:"varint,6,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TileCapturedChange) Reset() {
	*x = TileCapturedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TileCapturedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TileCapturedChange) ProtoMessage() {}

func (x *TileCapturedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TileCapturedChange.ProtoReflect.Descriptor instead.
func (*TileCapturedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{44}
}

func (x *TileCapturedChange) GetCapturingUnit() *Unit {
	if x != nil {
		return x.CapturingUnit
	}
	return nil
}

func (x *TileCapturedChange) GetTileQ() int32 {
	if x != nil {
		return x.TileQ
	}
	return 0
}

func (x *TileCapturedChange) GetTileR() int32 {
	if x != nil {
		return x.TileR
	}
	return 0
}

func (x *TileCapturedChange) GetTileType() int32 {
	if x != nil {
		return x.TileType
	}
	return 0
}

func (x *TileCapturedChange) GetPreviousOwner() int32 {
	if x != nil {
		return x.PreviousOwner
	}
	return 0
}

func (x *TileCapturedChange) GetNewOwner() int32 {
	if x != nil {
		return x.NewOwner
	}
	return 0
}

// *
// A unit started capturing a building (capture not yet complete)
type CaptureStartedChange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unit starting the capture
	CapturingUnit *Unit `protobuf:"bytes,1,opt,name=capturing_unit,json=capturingUnit,proto3" json:"capturing_unit,omitempty"`
	// Tile coordinates
	TileQ int32 `protobuf:"varint,2,opt,name=tile_q,json=tileQ,proto3" json:"tile_q,omitempty"`
	TileR int32 `protobuf:"varint,3,opt,name=tile_r,json=tileR,proto3" json:"tile_r,omitempty"`
	// Tile type
	TileType int32 `protobuf:"varint,4,opt,name=tile_type,json=tileType,proto3" json:"tile_type,omitempty"`
	// Current owner (0 for neutral)
	CurrentOwner  int32 `protobuf:"varint,5,opt,name=current_owner,json=currentOwner,proto3" json:"current_owner,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CaptureStartedChange) Reset() {
	*x = CaptureStartedChange{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CaptureStartedChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CaptureStartedChange) ProtoMessage() {}

func (x *CaptureStartedChange) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CaptureStartedChange.ProtoReflect.Descriptor instead.
func (*CaptureStartedChange) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{45}
}

func (x *CaptureStartedChange) GetCapturingUnit() *Unit {
	if x != nil {
		return x.CapturingUnit
	}
	return nil
}

func (x *CaptureStartedChange) GetTileQ() int32 {
	if x != nil {
		return x.TileQ
	}
	return 0
}

func (x *CaptureStartedChange) GetTileR() int32 {
	if x != nil {
		return x.TileR
	}
	return 0
}

func (x *CaptureStartedChange) GetTileType() int32 {
	if x != nil {
		return x.TileType
	}
	return 0
}

func (x *CaptureStartedChange) GetCurrentOwner() int32 {
	if x != nil {
		return x.CurrentOwner
	}
	return 0
}

// Compact representation of all reachable paths from a source
type AllPaths struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Starting coordinate for all paths
	SourceQ int32 `protobuf:"varint,1,opt,name=source_q,json=sourceQ,proto3" json:"source_q,omitempty"`
	SourceR int32 `protobuf:"varint,2,opt,name=source_r,json=sourceR,proto3" json:"source_r,omitempty"`
	// Map of edges: key is "toQ,toR" for quick parent lookup
	// Each edge represents the optimal way to reach 'to' from its parent
	Edges         map[string]*PathEdge `protobuf:"bytes,3,rep,name=edges,proto3" json:"edges,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllPaths) Reset() {
	*x = AllPaths{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllPaths) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllPaths) ProtoMessage() {}

func (x *AllPaths) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllPaths.ProtoReflect.Descriptor instead.
func (*AllPaths) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{46}
}

func (x *AllPaths) GetSourceQ() int32 {
	if x != nil {
		return x.SourceQ
	}
	return 0
}

func (x *AllPaths) GetSourceR() int32 {
	if x != nil {
		return x.SourceR
	}
	return 0
}

func (x *AllPaths) GetEdges() map[string]*PathEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

// A single edge in a path with movement details
type PathEdge struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FromQ         int32                  `protobuf:"varint,1,opt,name=from_q,json=fromQ,proto3" json:"from_q,omitempty"`                       // Parent coordinate Q
	FromR         int32                  `protobuf:"varint,2,opt,name=from_r,json=fromR,proto3" json:"from_r,omitempty"`                       // Parent coordinate R
	ToQ           int32                  `protobuf:"varint,3,opt,name=to_q,json=toQ,proto3" json:"to_q,omitempty"`                             // Destination coordinate Q
	ToR           int32                  `protobuf:"varint,4,opt,name=to_r,json=toR,proto3" json:"to_r,omitempty"`                             // Destination coordinate R
	MovementCost  float64                `protobuf:"fixed64,5,opt,name=movement_cost,json=movementCost,proto3" json:"movement_cost,omitempty"` // Cost to move from 'from' to 'to' (edge cost)
	TotalCost     float64                `protobuf:"fixed64,6,opt,name=total_cost,json=totalCost,proto3" json:"total_cost,omitempty"`          // Total cumulative cost from source to 'to'
	TerrainType   string                 `protobuf:"bytes,7,opt,name=terrain_type,json=terrainType,proto3" json:"terrain_type,omitempty"`      // e.g., "mountain", "plains", "forest"
	Explanation   string                 `protobuf:"bytes,8,opt,name=explanation,proto3" json:"explanation,omitempty"`                         // e.g., "Mountain costs Soldier 4 movement points"
	IsOccupied    bool                   `protobuf:"varint,9,opt,name=is_occupied,json=isOccupied,proto3" json:"is_occupied,omitempty"`        // True if destination tile has a friendly unit (pass-through only, cannot land)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PathEdge) Reset() {
	*x = PathEdge{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PathEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathEdge) ProtoMessage() {}

func (x *PathEdge) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathEdge.ProtoReflect.Descriptor instead.
func (*PathEdge) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{47}
}

func (x *PathEdge) GetFromQ() int32 {
	if x != nil {
		return x.FromQ
	}
	return 0
}

func (x *PathEdge) GetFromR() int32 {
	if x != nil {
		return x.FromR
	}
	return 0
}

func (x *PathEdge) GetToQ() int32 {
	if x != nil {
		return x.ToQ
	}
	return 0
}

func (x *PathEdge) GetToR() int32 {
	if x != nil {
		return x.ToR
	}
	return 0
}

func (x *PathEdge) GetMovementCost() float64 {
	if x != nil {
		return x.MovementCost
	}
	return 0
}

func (x *PathEdge) GetTotalCost() float64 {
	if x != nil {
		return x.TotalCost
	}
	return 0
}

func (x *PathEdge) GetTerrainType() string {
	if x != nil {
		return x.TerrainType
	}
	return ""
}

func (x *PathEdge) GetExplanation() string {
	if x != nil {
		return x.Explanation
	}
	return ""
}

func (x *PathEdge) GetIsOccupied() bool {
	if x != nil {
		return x.IsOccupied
	}
	return false
}

// Full path from source to destination (constructed on-demand from AllPaths)
type Path struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Edges in order from source to destination
	Edges []*PathEdge `protobuf:"bytes,1,rep,name=edges,proto3" json:"edges,omitempty"`
	// len(directions) = len(edges) - 1
	// and directions[i] = direction from edge[i - 1] -> edge[i]
	Directions []PathDirection `protobuf:"varint,2,rep,packed,name=directions,proto3,enum=lilbattle.v1.PathDirection" json:"directions,omitempty"`
	// Sum of all edge costs
	TotalCost     float64 `protobuf:"fixed64,3,opt,name=total_cost,json=totalCost,proto3" json:"total_cost,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Path) Reset() {
	*x = Path{}
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Path) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Path) ProtoMessage() {}

func (x *Path) ProtoReflect() protoreflect.Message {
	mi := &file_lilbattle_v1_models_models_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Path.ProtoReflect.Descriptor instead.
func (*Path) Descriptor() ([]byte, []int) {
	return file_lilbattle_v1_models_models_proto_rawDescGZIP(), []int{48}
}

func (x *Path) GetEdges() []*PathEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

func (x *Path) GetDirections() []PathDirection {
	if x != nil {
		return x.Directions
	}
	return nil
}

func (x *Path) GetTotalCost() float64 {
	if x != nil {
		return x.TotalCost
	}
	return 0
}

var File_lilbattle_v1_models_models_proto protoreflect.FileDescriptor

const file_lilbattle_v1_models_models_proto_rawDesc = "" +
	"\n" +
	" lilbattle/v1/models/models.proto\x12\flilbattle.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xba\x01\n" +
	"\tIndexInfo\x12B\n" +
	"\x0flast_updated_at\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\rlastUpdatedAt\x12B\n" +
	"\x0flast_indexed_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\rlastIndexedAt\x12%\n" +
	"\x0eneeds_indexing\x18\x03 \x01(\bR\rneedsIndexing\"e\n" +
	"\n" +
	"Pagination\x12\x19\n" +
	"\bpage_key\x18\x01 \x01(\tR\apageKey\x12\x1f\n" +
	"\vpage_offset\x18\x02 \x01(\x05R\n" +
	"pageOffset\x12\x1b\n" +
	"\tpage_size\x18\x03 \x01(\x05R\bpageSize\"\xa2\x01\n" +
	"\x12PaginationResponse\x12\"\n" +
	"\rnext_page_key\x18\x02 \x01(\tR\vnextPageKey\x12(\n" +
	"\x10next_page_offset\x18\x03 \x01(\x05R\x0enextPageOffset\x12\x19\n" +
	"\bhas_more\x18\x04 \x01(\bR\ahasMore\x12#\n" +
	"\rtotal_results\x18\x05 \x01(\x05R\ftotalResults\"\x86\x04\n" +
	"\x05World\x129\n" +
	"\n" +
	"created_at\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x03R\aversion\x12\x0e\n" +
	"\x02id\x18\x04 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"creator_id\x18\x05 \x01(\tR\tcreatorId\x12\x12\n" +
	"\x04name\x18\x06 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\a \x01(\tR\vdescription\x12\x12\n" +
	"\x04tags\x18\b \x03(\tR\x04tags\x12\x1b\n" +
	"\timage_url\x18\t \x01(\tR\bimageUrl\x12\x1e\n" +
	"\n" +
	"difficulty\x18\n" +
	" \x01(\tR\n" +
	"difficulty\x12!\n" +
	"\fpreview_urls\x18\v \x03(\tR\vpreviewUrls\x12O\n" +
	"\x13default_game_config\x18\f \x01(\v2\x1f.lilbattle.v1.GameConfigurationR\x11defaultGameConfig\x12C\n" +
	"\x11search_index_info\x18\r \x01(\v2\x17.lilbattle.v1.IndexInfoR\x0fsearchIndexInfo\"\xdb\x04\n" +
	"\tWorldData\x12B\n" +
	"\ttiles_map\x18\x01 \x03(\v2%.lilbattle.v1.WorldData.TilesMapEntryR\btilesMap\x12B\n" +
	"\tunits_map\x18\x02 \x03(\v2%.lilbattle.v1.WorldData.UnitsMapEntryR\bunitsMap\x12K\n" +
	"\x15screenshot_index_info\x18\x03 \x01(\v2\x17.lilbattle.v1.IndexInfoR\x13screenshotIndexInfo\x12!\n" +
	"\fcontent_hash\x18\x04 \x01(\tR\vcontentHash\x12\x18\n" +
	"\aversion\x18\x05 \x01(\x03R\aversion\x12D\n" +
	"\tcrossings\x18\b \x03(\v2&.lilbattle.v1.WorldData.CrossingsEntryR\tcrossings\x1aO\n" +
	"\rTilesMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.lilbattle.v1.TileR\x05value:\x028\x01\x1aO\n" +
	"\rUnitsMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.lilbattle.v1.UnitR\x05value:\x028\x01\x1aT\n" +
	"\x0eCrossingsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12,\n" +
	"\x05value\x18\x02 \x01(\v2\x16.lilbattle.v1.CrossingR\x05value:\x028\x01\"[\n" +
	"\bCrossing\x12.\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1a.lilbattle.v1.CrossingTypeR\x04type\x12\x1f\n" +
	"\vconnects_to\x18\x02 \x03(\bR\n" +
	"connectsTo\"\xc9\x01\n" +
	"\x04Tile\x12\f\n" +
	"\x01q\x18\x01 \x01(\x05R\x01q\x12\f\n" +
	"\x01r\x18\x02 \x01(\x05R\x01r\x12\x1b\n" +
	"\ttile_type\x18\x03 \x01(\x05R\btileType\x12\x16\n" +
	"\x06player\x18\x04 \x01(\x05R\x06player\x12\x1a\n" +
	"\bshortcut\x18\x05 \x01(\tR\bshortcut\x12&\n" +
	"\x0flast_acted_turn\x18\x06 \x01(\x05R\rlastActedTurn\x12,\n" +
	"\x12last_toppedup_turn\x18\a \x01(\x05R\x10lastToppedupTurn\"\xa5\x04\n" +
	"\x04Unit\x12\f\n" +
	"\x01q\x18\x01 \x01(\x05R\x01q\x12\f\n" +
	"\x01r\x18\x02 \x01(\x05R\x01r\x12\x16\n" +
	"\x06player\x18\x03 \x01(\x05R\x06player\x12\x1b\n" +
	"\tunit_type\x18\x04 \x01(\x05R\bunitType\x12\x1a\n" +
	"\bshortcut\x18\x05 \x01(\tR\bshortcut\x12)\n" +
	"\x10available_health\x18\x06 \x01(\x05R\x0favailableHealth\x12#\n" +
	"\rdistance_left\x18\a \x01(\x01R\fdistanceLeft\x12&\n" +
	"\x0flast_acted_turn\x18\b \x01(\x05R\rlastActedTurn\x12,\n" +
	"\x12last_toppedup_turn\x18\t \x01(\x05R\x10lastToppedupTurn\x12;\n" +
	"\x1aattacks_received_this_turn\x18\n" +
	" \x01(\x05R\x17attacksReceivedThisTurn\x12A\n" +
	"\x0eattack_history\x18\v \x03(\v2\x1a.lilbattle.v1.AttackRecordR\rattackHistory\x12)\n" +
	"\x10progression_step\x18\f \x01(\x05R\x0fprogressionStep\x12-\n" +
	"\x12chosen_alternative\x18\r \x01(\tR\x11chosenAlternative\x120\n" +
	"\x14capture_started_turn\x18\x0e \x01(\x05R\x12captureStartedTurn\"h\n" +
	"\fAttackRecord\x12\f\n" +
	"\x01q\x18\x01 \x01(\x05R\x01q\x12\f\n" +
	"\x01r\x18\x02 \x01(\x05R\x01r\x12\x1b\n" +
	"\tis_ranged\x18\x03 \x01(\bR\bisRanged\x12\x1f\n" +
	"\vturn_number\x18\x04 \x01(\x05R\n" +
	"turnNumber\"\x89\x03\n" +
	"\x11TerrainDefinition\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x05R\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04type\x18\x05 \x01(\x05R\x04type\x12 \n" +
	"\vdescription\x18\x06 \x01(\tR\vdescription\x12\\\n" +
	"\x0funit_properties\x18\a \x03(\v23.lilbattle.v1.TerrainDefinition.UnitPropertiesEntryR\x0eunitProperties\x12,\n" +
	"\x12buildable_unit_ids\x18\b \x03(\x05R\x10buildableUnitIds\x12&\n" +
	"\x0fincome_per_turn\x18\t \x01(\x05R\rincomePerTurn\x1af\n" +
	"\x13UnitPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x129\n" +
	"\x05value\x18\x02 \x01(\v2#.lilbattle.v1.TerrainUnitPropertiesR\x05value:\x028\x01\"\x82\b\n" +
	"\x0eUnitDefinition\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x05R\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x16\n" +
	"\x06health\x18\x04 \x01(\x05R\x06health\x12\x14\n" +
	"\x05coins\x18\x05 \x01(\x05R\x05coins\x12'\n" +
	"\x0fmovement_points\x18\x06 \x01(\x01R\x0emovementPoints\x12%\n" +
	"\x0eretreat_points\x18\a \x01(\x01R\rretreatPoints\x12\x18\n" +
	"\adefense\x18\b \x01(\x05R\adefense\x12!\n" +
	"\fattack_range\x18\t \x01(\x05R\vattackRange\x12(\n" +
	"\x10min_attack_range\x18\n" +
	" \x01(\x05R\x0eminAttackRange\x12#\n" +
	"\rsplash_damage\x18\v \x01(\x05R\fsplashDamage\x12b\n" +
	"\x12terrain_properties\x18\f \x03(\v23.lilbattle.v1.UnitDefinition.TerrainPropertiesEntryR\x11terrainProperties\x12\x1e\n" +
	"\n" +
	"properties\x18\r \x03(\tR\n" +
	"properties\x12\x1d\n" +
	"\n" +
	"unit_class\x18\x0e \x01(\tR\tunitClass\x12!\n" +
	"\funit_terrain\x18\x0f \x01(\tR\vunitTerrain\x12W\n" +
	"\x0fattack_vs_class\x18\x10 \x03(\v2/.lilbattle.v1.UnitDefinition.AttackVsClassEntryR\rattackVsClass\x12!\n" +
	"\faction_order\x18\x11 \x03(\tR\vactionOrder\x12S\n" +
	"\raction_limits\x18\x12 \x03(\v2..lilbattle.v1.UnitDefinition.ActionLimitsEntryR\factionLimits\x12\x1b\n" +
	"\tfix_value\x18\x13 \x01(\x05R\bfixValue\x1ai\n" +
	"\x16TerrainPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x129\n" +
	"\x05value\x18\x02 \x01(\v2#.lilbattle.v1.TerrainUnitPropertiesR\x05value:\x028\x01\x1a@\n" +
	"\x12AttackVsClassEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\x1a?\n" +
	"\x11ActionLimitsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xec\x02\n" +
	"\x15TerrainUnitProperties\x12\x1d\n" +
	"\n" +
	"terrain_id\x18\x01 \x01(\x05R\tterrainId\x12\x17\n" +
	"\aunit_id\x18\x02 \x01(\x05R\x06unitId\x12#\n" +
	"\rmovement_cost\x18\x03 \x01(\x01R\fmovementCost\x12#\n" +
	"\rhealing_bonus\x18\x04 \x01(\x05R\fhealingBonus\x12\x1b\n" +
	"\tcan_build\x18\x05 \x01(\bR\bcanBuild\x12\x1f\n" +
	"\vcan_capture\x18\x06 \x01(\bR\n" +
	"canCapture\x12!\n" +
	"\fattack_bonus\x18\a \x01(\x05R\vattackBonus\x12#\n" +
	"\rdefense_bonus\x18\b \x01(\x05R\fdefenseBonus\x12!\n" +
	"\fattack_range\x18\t \x01(\x05R\vattackRange\x12(\n" +
	"\x10min_attack_range\x18\n" +
	" \x01(\x05R\x0eminAttackRange\"\x97\x02\n" +
	"\x12UnitUnitProperties\x12\x1f\n" +
	"\vattacker_id\x18\x01 \x01(\x05R\n" +
	"attackerId\x12\x1f\n" +
	"\vdefender_id\x18\x02 \x01(\x05R\n" +
	"defenderId\x12,\n" +
	"\x0fattack_override\x18\x03 \x01(\x05H\x00R\x0eattackOverride\x88\x01\x01\x12.\n" +
	"\x10defense_override\x18\x04 \x01(\x05H\x01R\x0fdefenseOverride\x88\x01\x01\x128\n" +
	"\x06damage\x18\x05 \x01(\v2 .lilbattle.v1.DamageDistributionR\x06damageB\x12\n" +
	"\x10_attack_overrideB\x13\n" +
	"\x11_defense_override\"\xae\x01\n" +
	"\x12DamageDistribution\x12\x1d\n" +
	"\n" +
	"min_damage\x18\x01 \x01(\x01R\tminDamage\x12\x1d\n" +
	"\n" +
	"max_damage\x18\x02 \x01(\x01R\tmaxDamage\x12'\n" +
	"\x0fexpected_damage\x18\x03 \x01(\x01R\x0eexpectedDamage\x121\n" +
	"\x06ranges\x18\x04 \x03(\v2\x19.lilbattle.v1.DamageRangeR\x06ranges\"i\n" +
	"\vDamageRange\x12\x1b\n" +
	"\tmin_value\x18\x01 \x01(\x01R\bminValue\x12\x1b\n" +
	"\tmax_value\x18\x02 \x01(\x01R\bmaxValue\x12 \n" +
	"\vprobability\x18\x03 \x01(\x01R\vprobability\"\x9d\a\n" +
	"\vRulesEngine\x12:\n" +
	"\x05units\x18\x01 \x03(\v2$.lilbattle.v1.RulesEngine.UnitsEntryR\x05units\x12C\n" +
	"\bterrains\x18\x02 \x03(\v2'.lilbattle.v1.RulesEngine.TerrainsEntryR\bterrains\x12l\n" +
	"\x17terrain_unit_properties\x18\x03 \x03(\v24.lilbattle.v1.RulesEngine.TerrainUnitPropertiesEntryR\x15terrainUnitProperties\x12c\n" +
	"\x14unit_unit_properties\x18\x04 \x03(\v21.lilbattle.v1.RulesEngine.UnitUnitPropertiesEntryR\x12unitUnitProperties\x12P\n" +
	"\rterrain_types\x18\x05 \x03(\v2+.lilbattle.v1.RulesEngine.TerrainTypesEntryR\fterrainTypes\x1aV\n" +
	"\n" +
	"UnitsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x122\n" +
	"\x05value\x18\x02 \x01(\v2\x1c.lilbattle.v1.UnitDefinitionR\x05value:\x028\x01\x1a\\\n" +
	"\rTerrainsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.lilbattle.v1.TerrainDefinitionR\x05value:\x028\x01\x1am\n" +
	"\x1aTerrainUnitPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x129\n" +
	"\x05value\x18\x02 \x01(\v2#.lilbattle.v1.TerrainUnitPropertiesR\x05value:\x028\x01\x1ag\n" +
	"\x17UnitUnitPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .lilbattle.v1.UnitUnitPropertiesR\x05value:\x028\x01\x1aZ\n" +
	"\x11TerrainTypesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\x0e2\x19.lilbattle.v1.TerrainTypeR\x05value:\x028\x01\"\x88\x04\n" +
	"\x04Game\x129\n" +
	"\n" +
	"created_at\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x03R\aversion\x12\x0e\n" +
	"\x02id\x18\x04 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"creator_id\x18\x05 \x01(\tR\tcreatorId\x12\x19\n" +
	"\bworld_id\x18\x06 \x01(\tR\aworldId\x12\x12\n" +
	"\x04name\x18\a \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\b \x01(\tR\vdescription\x12\x12\n" +
	"\x04tags\x18\t \x03(\tR\x04tags\x12\x1b\n" +
	"\timage_url\x18\n" +
	" \x01(\tR\bimageUrl\x12\x1e\n" +
	"\n" +
	"difficulty\x18\v \x01(\tR\n" +
	"difficulty\x127\n" +
	"\x06config\x18\f \x01(\v2\x1f.lilbattle.v1.GameConfigurationR\x06config\x12!\n" +
	"\fpreview_urls\x18\r \x03(\tR\vpreviewUrls\x12C\n" +
	"\x11search_index_info\x18\x0f \x01(\v2\x17.lilbattle.v1.IndexInfoR\x0fsearchIndexInfo\"\xf0\x01\n" +
	"\x11GameConfiguration\x122\n" +
	"\aplayers\x18\x01 \x03(\v2\x18.lilbattle.v1.GamePlayerR\aplayers\x12,\n" +
	"\x05teams\x18\x02 \x03(\v2\x16.lilbattle.v1.GameTeamR\x05teams\x12A\n" +
	"\x0eincome_configs\x18\x03 \x01(\v2\x1a.lilbattle.v1.IncomeConfigR\rincomeConfigs\x126\n" +
	"\bsettings\x18\x04 \x01(\v2\x1a.lilbattle.v1.GameSettingsR\bsettings\"\xab\x02\n" +
	"\fIncomeConfig\x12%\n" +
	"\x0estarting_coins\x18\x01 \x01(\x05R\rstartingCoins\x12\x1f\n" +
	"\vgame_income\x18\x02 \x01(\x05R\n" +
	"gameIncome\x12'\n" +
	"\x0flandbase_income\x18\x03 \x01(\x05R\x0elandbaseIncome\x12)\n" +
	"\x10navalbase_income\x18\x04 \x01(\x05R\x0fnavalbaseIncome\x12-\n" +
	"\x12airportbase_income\x18\x05 \x01(\x05R\x11airportbaseIncome\x12-\n" +
	"\x12missilesilo_income\x18\x06 \x01(\x05R\x11missilesiloIncome\x12!\n" +
	"\fmines_income\x18\a \x01(\x05R\vminesIncome\"\xea\x01\n" +
	"\n" +
	"GamePlayer\x12\x1b\n" +
	"\tplayer_id\x18\x01 \x01(\x05R\bplayerId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x1f\n" +
	"\vplayer_type\x18\x03 \x01(\tR\n" +
	"playerType\x12\x14\n" +
	"\x05color\x18\x04 \x01(\tR\x05color\x12\x17\n" +
	"\ateam_id\x18\x05 \x01(\x05R\x06teamId\x12\x12\n" +
	"\x04name\x18\x06 \x01(\tR\x04name\x12\x1b\n" +
	"\tis_active\x18\a \x01(\bR\bisActive\x12%\n" +
	"\x0estarting_coins\x18\b \x01(\x05R\rstartingCoins\"j\n" +
	"\bGameTeam\x12\x17\n" +
	"\ateam_id\x18\x01 \x01(\x05R\x06teamId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05color\x18\x03 \x01(\tR\x05color\x12\x1b\n" +
	"\tis_active\x18\x04 \x01(\bR\bisActive\"\x95\x01\n" +
	"\fGameSettings\x12#\n" +
	"\rallowed_units\x18\x01 \x03(\x05R\fallowedUnits\x12&\n" +
	"\x0fturn_time_limit\x18\x02 \x01(\x05R\rturnTimeLimit\x12\x1b\n" +
	"\tteam_mode\x18\x03 \x01(\tR\bteamMode\x12\x1b\n" +
	"\tmax_turns\x18\x04 \x01(\x05R\bmaxTurns\"@\n" +
	"\vPlayerState\x12\x14\n" +
	"\x05coins\x18\x01 \x01(\x05R\x05coins\x12\x1b\n" +
	"\tis_active\x18\x02 \x01(\bR\bisActive\"\x90\x05\n" +
	"\tGameState\x129\n" +
	"\n" +
	"updated_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\x17\n" +
	"\agame_id\x18\x03 \x01(\tR\x06gameId\x12!\n" +
	"\fturn_counter\x18\x04 \x01(\x05R\vturnCounter\x12%\n" +
	"\x0ecurrent_player\x18\x05 \x01(\x05R\rcurrentPlayer\x126\n" +
	"\n" +
	"world_data\x18\x06 \x01(\v2\x17.lilbattle.v1.WorldDataR\tworldData\x12\x1d\n" +
	"\n" +
	"state_hash\x18\b \x01(\tR\tstateHash\x12\x18\n" +
	"\aversion\x18\t \x01(\x03R\aversion\x120\n" +
	"\x06status\x18\n" +
	" \x01(\x0e2\x18.lilbattle.v1.GameStatusR\x06status\x12\x1a\n" +
	"\bfinished\x18\v \x01(\bR\bfinished\x12%\n" +
	"\x0ewinning_player\x18\f \x01(\x05R\rwinningPlayer\x12!\n" +
	"\fwinning_team\x18\r \x01(\x05R\vwinningTeam\x120\n" +
	"\x14current_group_number\x18\x0e \x01(\x03R\x12currentGroupNumber\x12N\n" +
	"\rplayer_states\x18\x0f \x03(\v2).lilbattle.v1.GameState.PlayerStatesEntryR\fplayerStates\x1aZ\n" +
	"\x11PlayerStatesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.lilbattle.v1.PlayerStateR\x05value:\x028\x01\"_\n" +
	"\x0fGameMoveHistory\x12\x17\n" +
	"\agame_id\x18\x01 \x01(\tR\x06gameId\x123\n" +
	"\x06groups\x18\x02 \x03(\v2\x1b.lilbattle.v1.GameMoveGroupR\x06groups\"\xd2\x01\n" +
	"\rGameMoveGroup\x129\n" +
	"\n" +
	"started_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tstartedAt\x125\n" +
	"\bended_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\aendedAt\x12!\n" +
	"\fgroup_number\x18\x04 \x01(\x03R\vgroupNumber\x12,\n" +
	"\x05moves\x18\x05 \x03(\v2\x16.lilbattle.v1.GameMoveR\x05moves\"\x8d\x06\n" +
	"\bGameMove\x12\x16\n" +
	"\x06player\x18\x01 \x01(\x05R\x06player\x12!\n" +
	"\fgroup_number\x18\x02 \x01(\x03R\vgroupNumber\x12\x1f\n" +
	"\vmove_number\x18\x03 \x01(\x03R\n" +
	"moveNumber\x128\n" +
	"\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12;\n" +
	"\tmove_unit\x18\x05 \x01(\v2\x1c.lilbattle.v1.MoveUnitActionH\x00R\bmoveUnit\x12A\n" +
	"\vattack_unit\x18\x06 \x01(\v2\x1e.lilbattle.v1.AttackUnitActionH\x00R\n" +
	"attackUnit\x128\n" +
	"\bend_turn\x18\a \x01(\v2\x1b.lilbattle.v1.EndTurnActionH\x00R\aendTurn\x12>\n" +
	"\n" +
	"build_unit\x18\b \x01(\v2\x1d.lilbattle.v1.BuildUnitActionH\x00R\tbuildUnit\x12P\n" +
	"\x10capture_building\x18\r \x01(\v2#.lilbattle.v1.CaptureBuildingActionH\x00R\x0fcaptureBuilding\x12;\n" +
	"\theal_unit\x18\x0e \x01(\v2\x1c.lilbattle.v1.HealUnitActionH\x00R\bhealUnit\x128\n" +
	"\bfix_unit\x18\x0f \x01(\v2\x1b.lilbattle.v1.FixUnitActionH\x00R\afixUnit\x12!\n" +
	"\fsequence_num\x18\t \x01(\x03R\vsequenceNum\x12!\n" +
	"\fis_permanent\x18\n" +
	" \x01(\bR\visPermanent\x123\n" +
	"\achanges\x18\v \x03(\v2\x19.lilbattle.v1.WorldChangeR\achanges\x12 \n" +
	"\vdescription\x18\f \x01(\tR\vdescriptionB\v\n" +
	"\tmove_type\"<\n" +
	"\bPosition\x12\x14\n" +
	"\x05label\x18\x01 \x01(\tR\x05label\x12\f\n" +
	"\x01q\x18\x02 \x01(\x05R\x01q\x12\f\n" +
	"\x01r\x18\x03 \x01(\x05R\x01r\"\xcc\x01\n" +
	"\x0eMoveUnitAction\x12*\n" +
	"\x04from\x18\x01 \x01(\v2\x16.lilbattle.v1.PositionR\x04from\x12&\n" +
	"\x02to\x18\x02 \x01(\v2\x16.lilbattle.v1.PositionR\x02to\x12#\n" +
	"\rmovement_cost\x18\x03 \x01(\x01R\fmovementCost\x12A\n" +
	"\x12reconstructed_path\x18\x04 \x01(\v2\x12.lilbattle.v1.PathR\x11reconstructedPath\"\x9a\x02\n" +
	"\x10AttackUnitAction\x122\n" +
	"\battacker\x18\x01 \x01(\v2\x16.lilbattle.v1.PositionR\battacker\x122\n" +
	"\bdefender\x18\x02 \x01(\v2\x16.lilbattle.v1.PositionR\bdefender\x12(\n" +
	"\x10target_unit_type\x18\a \x01(\x05R\x0etargetUnitType\x12,\n" +
	"\x12target_unit_health\x18\b \x01(\x05R\x10targetUnitHealth\x12\x1d\n" +
	"\n" +
	"can_attack\x18\t \x01(\bR\tcanAttack\x12'\n" +
	"\x0fdamage_estimate\x18\n" +
	" \x01(\x05R\x0edamageEstimate\"l\n" +
	"\x0fBuildUnitAction\x12(\n" +
	"\x03pos\x18\x01 \x01(\v2\x16.lilbattle.v1.PositionR\x03pos\x12\x1b\n" +
	"\tunit_type\x18\x02 \x01(\x05R\bunitType\x12\x12\n" +
	"\x04cost\x18\x03 \x01(\x05R\x04cost\"^\n" +
	"\x15CaptureBuildingAction\x12(\n" +
	"\x03pos\x18\x01 \x01(\v2\x16.lilbattle.v1.PositionR\x03pos\x12\x1b\n" +
	"\ttile_type\x18\x03 \x01(\x05R\btileType\"\x0f\n" +
	"\rEndTurnAction\"[\n" +
	"\x0eHealUnitAction\x12(\n" +
	"\x03pos\x18\x01 \x01(\v2\x16.lilbattle.v1.PositionR\x03pos\x12\x1f\n" +
	"\vheal_amount\x18\x02 \x01(\x05R\n" +
	"healAmount\"\x8c\x01\n" +
	"\rFixUnitAction\x12,\n" +
	"\x05fixer\x18\x01 \x01(\v2\x16.lilbattle.v1.PositionR\x05fixer\x12.\n" +
	"\x06target\x18\x02 \x01(\v2\x16.lilbattle.v1.PositionR\x06target\x12\x1d\n" +
	"\n" +
	"fix_amount\x18\x03 \x01(\x05R\tfixAmount\"\xd5\x05\n" +
	"\vWorldChange\x12>\n" +
	"\n" +
	"unit_moved\x18\x01 \x01(\v2\x1d.lilbattle.v1.UnitMovedChangeH\x00R\tunitMoved\x12D\n" +
	"\funit_damaged\x18\x02 \x01(\v2\x1f.lilbattle.v1.UnitDamagedChangeH\x00R\vunitDamaged\x12A\n" +
	"\vunit_killed\x18\x03 \x01(\v2\x1e.lilbattle.v1.UnitKilledChangeH\x00R\n" +
	"unitKilled\x12J\n" +
	"\x0eplayer_changed\x18\x04 \x01(\v2!.lilbattle.v1.PlayerChangedChangeH\x00R\rplayerChanged\x12>\n" +
	"\n" +
	"unit_built\x18\x05 \x01(\v2\x1d.lilbattle.v1.UnitBuiltChangeH\x00R\tunitBuilt\x12G\n" +
	"\rcoins_changed\x18\x06 \x01(\v2 .lilbattle.v1.CoinsChangedChangeH\x00R\fcoinsChanged\x12G\n" +
	"\rtile_captured\x18\a \x01(\v2 .lilbattle.v1.TileCapturedChangeH\x00R\ftileCaptured\x12M\n" +
	"\x0fcapture_started\x18\b \x01(\v2\".lilbattle.v1.CaptureStartedChangeH\x00R\x0ecaptureStarted\x12A\n" +
	"\vunit_healed\x18\t \x01(\v2\x1e.lilbattle.v1.UnitHealedChangeH\x00R\n" +
	"unitHealed\x12>\n" +
	"\n" +
	"unit_fixed\x18\n" +
	" \x01(\v2\x1d.lilbattle.v1.UnitFixedChangeH\x00R\tunitFixedB\r\n" +
	"\vchange_type\"\xa3\x01\n" +
	"\x10UnitHealedChange\x127\n" +
	"\rprevious_unit\x18\x01 \x01(\v2\x12.lilbattle.v1.UnitR\fpreviousUnit\x125\n" +
	"\fupdated_unit\x18\x02 \x01(\v2\x12.lilbattle.v1.UnitR\vupdatedUnit\x12\x1f\n" +
	"\vheal_amount\x18\x03 \x01(\x05R\n" +
	"healAmount\"\xdb\x01\n" +
	"\x0fUnitFixedChange\x121\n" +
	"\n" +
	"fixer_unit\x18\x01 \x01(\v2\x12.lilbattle.v1.UnitR\tfixerUnit\x12;\n" +
	"\x0fprevious_target\x18\x02 \x01(\v2\x12.lilbattle.v1.UnitR\x0epreviousTarget\x129\n" +
	"\x0eupdated_target\x18\x03 \x01(\v2\x12.lilbattle.v1.UnitR\rupdatedTarget\x12\x1d\n" +
	"\n" +
	"fix_amount\x18\x04 \x01(\x05R\tfixAmount\"\x81\x01\n" +
	"\x0fUnitMovedChange\x127\n" +
	"\rprevious_unit\x18\x06 \x01(\v2\x12.lilbattle.v1.UnitR\fpreviousUnit\x125\n" +
	"\fupdated_unit\x18\a \x01(\v2\x12.lilbattle.v1.UnitR\vupdatedUnit\"\x83\x01\n" +
	"\x11UnitDamagedChange\x127\n" +
	"\rprevious_unit\x18\x06 \x01(\v2\x12.lilbattle.v1.UnitR\fpreviousUnit\x125\n" +
	"\fupdated_unit\x18\a \x01(\v2\x12.lilbattle.v1.UnitR\vupdatedUnit\"K\n" +
	"\x10UnitKilledChange\x127\n" +
	"\rprevious_unit\x18\x06 \x01(\v2\x12.lilbattle.v1.UnitR\fpreviousUnit\"\xd2\x01\n" +
	"\x13PlayerChangedChange\x12'\n" +
	"\x0fprevious_player\x18\x01 \x01(\x05R\x0epreviousPlayer\x12\x1d\n" +
	"\n" +
	"new_player\x18\x02 \x01(\x05R\tnewPlayer\x12#\n" +
	"\rprevious_turn\x18\x03 \x01(\x05R\fpreviousTurn\x12\x19\n" +
	"\bnew_turn\x18\x04 \x01(\x05R\anewTurn\x123\n" +
	"\vreset_units\x18\x05 \x03(\v2\x12.lilbattle.v1.UnitR\n" +
	"resetUnits\"\xa9\x01\n" +
	"\x0fUnitBuiltChange\x12&\n" +
	"\x04unit\x18\x01 \x01(\v2\x12.lilbattle.v1.UnitR\x04unit\x12\x15\n" +
	"\x06tile_q\x18\x02 \x01(\x05R\x05tileQ\x12\x15\n" +
	"\x06tile_r\x18\x03 \x01(\x05R\x05tileR\x12\x1d\n" +
	"\n" +
	"coins_cost\x18\x04 \x01(\x05R\tcoinsCost\x12!\n" +
	"\fplayer_coins\x18\x05 \x01(\x05R\vplayerCoins\"\x8d\x01\n" +
	"\x12CoinsChangedChange\x12\x1b\n" +
	"\tplayer_id\x18\x01 \x01(\x05R\bplayerId\x12%\n" +
	"\x0eprevious_coins\x18\x02 \x01(\x05R\rpreviousCoins\x12\x1b\n" +
	"\tnew_coins\x18\x03 \x01(\x05R\bnewCoins\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\"\xde\x01\n" +
	"\x12TileCapturedChange\x129\n" +
	"\x0ecapturing_unit\x18\x01 \x01(\v2\x12.lilbattle.v1.UnitR\rcapturingUnit\x12\x15\n" +
	"\x06tile_q\x18\x02 \x01(\x05R\x05tileQ\x12\x15\n" +
	"\x06tile_r\x18\x03 \x01(\x05R\x05tileR\x12\x1b\n" +
	"\ttile_type\x18\x04 \x01(\x05R\btileType\x12%\n" +
	"\x0eprevious_owner\x18\x05 \x01(\x05R\rpreviousOwner\x12\x1b\n" +
	"\tnew_owner\x18\x06 \x01(\x05R\bnewOwner\"\xc1\x01\n" +
	"\x14CaptureStartedChange\x129\n" +
	"\x0ecapturing_unit\x18\x01 \x01(\v2\x12.lilbattle.v1.UnitR\rcapturingUnit\x12\x15\n" +
	"\x06tile_q\x18\x02 \x01(\x05R\x05tileQ\x12\x15\n" +
	"\x06tile_r\x18\x03 \x01(\x05R\x05tileR\x12\x1b\n" +
	"\ttile_type\x18\x04 \x01(\x05R\btileType\x12#\n" +
	"\rcurrent_owner\x18\x05 \x01(\x05R\fcurrentOwner\"\xcb\x01\n" +
	"\bAllPaths\x12\x19\n" +
	"\bsource_q\x18\x01 \x01(\x05R\asourceQ\x12\x19\n" +
	"\bsource_r\x18\x02 \x01(\x05R\asourceR\x127\n" +
	"\x05edges\x18\x03 \x03(\v2!.lilbattle.v1.AllPaths.EdgesEntryR\x05edges\x1aP\n" +
	"\n" +
	"EdgesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12,\n" +
	"\x05value\x18\x02 \x01(\v2\x16.lilbattle.v1.PathEdgeR\x05value:\x028\x01\"\x88\x02\n" +
	"\bPathEdge\x12\x15\n" +
	"\x06from_q\x18\x01 \x01(\x05R\x05fromQ\x12\x15\n" +
	"\x06from_r\x18\x02 \x01(\x05R\x05fromR\x12\x11\n" +
	"\x04to_q\x18\x03 \x01(\x05R\x03toQ\x12\x11\n" +
	"\x04to_r\x18\x04 \x01(\x05R\x03toR\x12#\n" +
	"\rmovement_cost\x18\x05 \x01(\x01R\fmovementCost\x12\x1d\n" +
	"\n" +
	"total_cost\x18\x06 \x01(\x01R\ttotalCost\x12!\n" +
	"\fterrain_type\x18\a \x01(\tR\vterrainType\x12 \n" +
	"\vexplanation\x18\b \x01(\tR\vexplanation\x12\x1f\n" +
	"\vis_occupied\x18\t \x01(\bR\n" +
	"isOccupied\"\x90\x01\n" +
	"\x04Path\x12,\n" +
	"\x05edges\x18\x01 \x03(\v2\x16.lilbattle.v1.PathEdgeR\x05edges\x12;\n" +
	"\n" +
	"directions\x18\x02 \x03(\x0e2\x1b.lilbattle.v1.PathDirectionR\n" +
	"directions\x12\x1d\n" +
	"\n" +
	"total_cost\x18\x03 \x01(\x01R\ttotalCost*_\n" +
	"\fCrossingType\x12\x1d\n" +
	"\x19CROSSING_TYPE_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12CROSSING_TYPE_ROAD\x10\x01\x12\x18\n" +
	"\x14CROSSING_TYPE_BRIDGE\x10\x02*\xa3\x01\n" +
	"\vTerrainType\x12\x1c\n" +
	"\x18TERRAIN_TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11TERRAIN_TYPE_CITY\x10\x01\x12\x17\n" +
	"\x13TERRAIN_TYPE_NATURE\x10\x02\x12\x17\n" +
	"\x13TERRAIN_TYPE_BRIDGE\x10\x03\x12\x16\n" +
	"\x12TERRAIN_TYPE_WATER\x10\x04\x12\x15\n" +
	"\x11TERRAIN_TYPE_ROAD\x10\x05*q\n" +
	"\n" +
	"GameStatus\x12\x1b\n" +
	"\x17GAME_STATUS_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13GAME_STATUS_PLAYING\x10\x01\x12\x16\n" +
	"\x12GAME_STATUS_PAUSED\x10\x02\x12\x15\n" +
	"\x11GAME_STATUS_ENDED\x10\x03*\xde\x01\n" +
	"\rPathDirection\x12\x1e\n" +
	"\x1aPATH_DIRECTION_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13PATH_DIRECTION_LEFT\x10\x01\x12\x1b\n" +
	"\x17PATH_DIRECTION_TOP_LEFT\x10\x02\x12\x1c\n" +
	"\x18PATH_DIRECTION_TOP_RIGHT\x10\x03\x12\x18\n" +
	"\x14PATH_DIRECTION_RIGHT\x10\x04\x12\x1f\n" +
	"\x1bPATH_DIRECTION_BOTTOM_RIGHT\x10\x05\x12\x1e\n" +
	"\x1aPATH_DIRECTION_BOTTOM_LEFT\x10\x06B\xb7\x01\n" +
	"\x10com.lilbattle.v1B\vModelsProtoP\x01ZEgithub.com/turnforge/lilbattle/gen/go/lilbattle/v1/models;lilbattlev1\xa2\x02\x03LXX\xaa\x02\fLilbattle.V1\xca\x02\fLilbattle\\V1\xe2\x02\x18Lilbattle\\V1\\GPBMetadata\xea\x02\rLilbattle::V1b\x06proto3"

var (
	file_lilbattle_v1_models_models_proto_rawDescOnce sync.Once
	file_lilbattle_v1_models_models_proto_rawDescData []byte
)

func file_lilbattle_v1_models_models_proto_rawDescGZIP() []byte {
	file_lilbattle_v1_models_models_proto_rawDescOnce.Do(func() {
		file_lilbattle_v1_models_models_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_lilbattle_v1_models_models_proto_rawDesc), len(file_lilbattle_v1_models_models_proto_rawDesc)))
	})
	return file_lilbattle_v1_models_models_proto_rawDescData
}

var file_lilbattle_v1_models_models_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_lilbattle_v1_models_models_proto_msgTypes = make([]protoimpl.MessageInfo, 63)
var file_lilbattle_v1_models_models_proto_goTypes = []any{
	(CrossingType)(0),             // 0: lilbattle.v1.CrossingType
	(TerrainType)(0),              // 1: lilbattle.v1.TerrainType
	(GameStatus)(0),               // 2: lilbattle.v1.GameStatus
	(PathDirection)(0),            // 3: lilbattle.v1.PathDirection
	(*IndexInfo)(nil),             // 4: lilbattle.v1.IndexInfo
	(*Pagination)(nil),            // 5: lilbattle.v1.Pagination
	(*PaginationResponse)(nil),    // 6: lilbattle.v1.PaginationResponse
	(*World)(nil),                 // 7: lilbattle.v1.World
	(*WorldData)(nil),             // 8: lilbattle.v1.WorldData
	(*Crossing)(nil),              // 9: lilbattle.v1.Crossing
	(*Tile)(nil),                  // 10: lilbattle.v1.Tile
	(*Unit)(nil),                  // 11: lilbattle.v1.Unit
	(*AttackRecord)(nil),          // 12: lilbattle.v1.AttackRecord
	(*TerrainDefinition)(nil),     // 13: lilbattle.v1.TerrainDefinition
	(*UnitDefinition)(nil),        // 14: lilbattle.v1.UnitDefinition
	(*TerrainUnitProperties)(nil), // 15: lilbattle.v1.TerrainUnitProperties
	(*UnitUnitProperties)(nil),    // 16: lilbattle.v1.UnitUnitProperties
	(*DamageDistribution)(nil),    // 17: lilbattle.v1.DamageDistribution
	(*DamageRange)(nil),           // 18: lilbattle.v1.DamageRange
	(*RulesEngine)(nil),           // 19: lilbattle.v1.RulesEngine
	(*Game)(nil),                  // 20: lilbattle.v1.Game
	(*GameConfiguration)(nil),     // 21: lilbattle.v1.GameConfiguration
	(*IncomeConfig)(nil),          // 22: lilbattle.v1.IncomeConfig
	(*GamePlayer)(nil),            // 23: lilbattle.v1.GamePlayer
	(*GameTeam)(nil),              // 24: lilbattle.v1.GameTeam
	(*GameSettings)(nil),          // 25: lilbattle.v1.GameSettings
	(*PlayerState)(nil),           // 26: lilbattle.v1.PlayerState
	(*GameState)(nil),             // 27: lilbattle.v1.GameState
	(*GameMoveHistory)(nil),       // 28: lilbattle.v1.GameMoveHistory
	(*GameMoveGroup)(nil),         // 29: lilbattle.v1.GameMoveGroup
	(*GameMove)(nil),              // 30: lilbattle.v1.GameMove
	(*Position)(nil),              // 31: lilbattle.v1.Position
	(*MoveUnitAction)(nil),        // 32: lilbattle.v1.MoveUnitAction
	(*AttackUnitAction)(nil),      // 33: lilbattle.v1.AttackUnitAction
	(*BuildUnitAction)(nil),       // 34: lilbattle.v1.BuildUnitAction
	(*CaptureBuildingAction)(nil), // 35: lilbattle.v1.CaptureBuildingAction
	(*EndTurnAction)(nil),         // 36: lilbattle.v1.EndTurnAction
	(*HealUnitAction)(nil),        // 37: lilbattle.v1.HealUnitAction
	(*FixUnitAction)(nil),         // 38: lilbattle.v1.FixUnitAction
	(*WorldChange)(nil),           // 39: lilbattle.v1.WorldChange
	(*UnitHealedChange)(nil),      // 40: lilbattle.v1.UnitHealedChange
	(*UnitFixedChange)(nil),       // 41: lilbattle.v1.UnitFixedChange
	(*UnitMovedChange)(nil),       // 42: lilbattle.v1.UnitMovedChange
	(*UnitDamagedChange)(nil),     // 43: lilbattle.v1.UnitDamagedChange
	(*UnitKilledChange)(nil),      // 44: lilbattle.v1.UnitKilledChange
	(*PlayerChangedChange)(nil),   // 45: lilbattle.v1.PlayerChangedChange
	(*UnitBuiltChange)(nil),       // 46: lilbattle.v1.UnitBuiltChange
	(*CoinsChangedChange)(nil),    // 47: lilbattle.v1.CoinsChangedChange
	(*TileCapturedChange)(nil),    // 48: lilbattle.v1.TileCapturedChange
	(*CaptureStartedChange)(nil),  // 49: lilbattle.v1.CaptureStartedChange
	(*AllPaths)(nil),              // 50: lilbattle.v1.AllPaths
	(*PathEdge)(nil),              // 51: lilbattle.v1.PathEdge
	(*Path)(nil),                  // 52: lilbattle.v1.Path
	nil,                           // 53: lilbattle.v1.WorldData.TilesMapEntry
	nil,                           // 54: lilbattle.v1.WorldData.UnitsMapEntry
	nil,                           // 55: lilbattle.v1.WorldData.CrossingsEntry
	nil,                           // 56: lilbattle.v1.TerrainDefinition.UnitPropertiesEntry
	nil,                           // 57: lilbattle.v1.UnitDefinition.TerrainPropertiesEntry
	nil,                           // 58: lilbattle.v1.UnitDefinition.AttackVsClassEntry
	nil,                           // 59: lilbattle.v1.UnitDefinition.ActionLimitsEntry
	nil,                           // 60: lilbattle.v1.RulesEngine.UnitsEntry
	nil,                           // 61: lilbattle.v1.RulesEngine.TerrainsEntry
	nil,                           // 62: lilbattle.v1.RulesEngine.TerrainUnitPropertiesEntry
	nil,                           // 63: lilbattle.v1.RulesEngine.UnitUnitPropertiesEntry
	nil,                           // 64: lilbattle.v1.RulesEngine.TerrainTypesEntry
	nil,                           // 65: lilbattle.v1.GameState.PlayerStatesEntry
	nil,                           // 66: lilbattle.v1.AllPaths.EdgesEntry
	(*timestamppb.Timestamp)(nil), // 67: google.protobuf.Timestamp
}
var file_lilbattle_v1_models_models_proto_depIdxs = []int32{
	67, // 0: lilbattle.v1.IndexInfo.last_updated_at:type_name -> google.protobuf.Timestamp
	67, // 1: lilbattle.v1.IndexInfo.last_indexed_at:type_name -> google.protobuf.Timestamp
	67, // 2: lilbattle.v1.World.created_at:type_name -> google.protobuf.Timestamp
	67, // 3: lilbattle.v1.World.updated_at:type_name -> google.protobuf.Timestamp
	21, // 4: lilbattle.v1.World.default_game_config:type_name -> lilbattle.v1.GameConfiguration
	4,  // 5: lilbattle.v1.World.search_index_info:type_name -> lilbattle.v1.IndexInfo
	53, // 6: lilbattle.v1.WorldData.tiles_map:type_name -> lilbattle.v1.WorldData.TilesMapEntry
	54, // 7: lilbattle.v1.WorldData.units_map:type_name -> lilbattle.v1.WorldData.UnitsMapEntry
	4,  // 8: lilbattle.v1.WorldData.screenshot_index_info:type_name -> lilbattle.v1.IndexInfo
	55, // 9: lilbattle.v1.WorldData.crossings:type_name -> lilbattle.v1.WorldData.CrossingsEntry
	0,  // 10: lilbattle.v1.Crossing.type:type_name -> lilbattle.v1.CrossingType
	12, // 11: lilbattle.v1.Unit.attack_history:type_name -> lilbattle.v1.AttackRecord
	56, // 12: lilbattle.v1.TerrainDefinition.unit_properties:type_name -> lilbattle.v1.TerrainDefinition.UnitPropertiesEntry
	57, // 13: lilbattle.v1.UnitDefinition.terrain_properties:type_name -> lilbattle.v1.UnitDefinition.TerrainPropertiesEntry
	58, // 14: lilbattle.v1.UnitDefinition.attack_vs_class:type_name -> lilbattle.v1.UnitDefinition.AttackVsClassEntry
	59, // 15: lilbattle.v1.UnitDefinition.action_limits:type_name -> lilbattle.v1.UnitDefinition.ActionLimitsEntry
	17, // 16: lilbattle.v1.UnitUnitProperties.damage:type_name -> lilbattle.v1.DamageDistribution
	18, // 17: lilbattle.v1.DamageDistribution.ranges:type_name -> lilbattle.v1.DamageRange
	60, // 18: lilbattle.v1.RulesEngine.units:type_name -> lilbattle.v1.RulesEngine.UnitsEntry
	61, // 19: lilbattle.v1.RulesEngine.terrains:type_name -> lilbattle.v1.RulesEngine.TerrainsEntry
	62, // 20: lilbattle.v1.RulesEngine.terrain_unit_properties:type_name -> lilbattle.v1.RulesEngine.TerrainUnitPropertiesEntry
	63, // 21: lilbattle.v1.RulesEngine.unit_unit_properties:type_name -> lilbattle.v1.RulesEngine.UnitUnitPropertiesEntry
	64, // 22: lilbattle.v1.RulesEngine.terrain_types:type_name -> lilbattle.v1.RulesEngine.TerrainTypesEntry
	67, // 23: lilbattle.v1.Game.created_at:type_name -> google.protobuf.Timestamp
	67, // 24: lilbattle.v1.Game.updated_at:type_name -> google.protobuf.Timestamp
	21, // 25: lilbattle.v1.Game.config:type_name -> lilbattle.v1.GameConfiguration
	4,  // 26: lilbattle.v1.Game.search_index_info:type_name -> lilbattle.v1.IndexInfo
	23, // 27: lilbattle.v1.GameConfiguration.players:type_name -> lilbattle.v1.GamePlayer
	24, // 28: lilbattle.v1.GameConfiguration.teams:type_name -> lilbattle.v1.GameTeam
	22, // 29: lilbattle.v1.GameConfiguration.income_configs:type_name -> lilbattle.v1.IncomeConfig
	25, // 30: lilbattle.v1.GameConfiguration.settings:type_name -> lilbattle.v1.GameSettings
	67, // 31: lilbattle.v1.GameState.updated_at:type_name -> google.protobuf.Timestamp
	8,  // 32: lilbattle.v1.GameState.world_data:type_name -> lilbattle.v1.WorldData
	2,  // 33: lilbattle.v1.GameState.status:type_name -> lilbattle.v1.GameStatus
	65, // 34: lilbattle.v1.GameState.player_states:type_name -> lilbattle.v1.GameState.PlayerStatesEntry
	29, // 35: lilbattle.v1.GameMoveHistory.groups:type_name -> lilbattle.v1.GameMoveGroup
	67, // 36: lilbattle.v1.GameMoveGroup.started_at:type_name -> google.protobuf.Timestamp
	67, // 37: lilbattle.v1.GameMoveGroup.ended_at:type_name -> google.protobuf.Timestamp
	30, // 38: lilbattle.v1.GameMoveGroup.moves:type_name -> lilbattle.v1.GameMove
	67, // 39: lilbattle.v1.GameMove.timestamp:type_name -> google.protobuf.Timestamp
	32, // 40: lilbattle.v1.GameMove.move_unit:type_name -> lilbattle.v1.MoveUnitAction
	33, // 41: lilbattle.v1.GameMove.attack_unit:type_name -> lilbattle.v1.AttackUnitAction
	36, // 42: lilbattle.v1.GameMove.end_turn:type_name -> lilbattle.v1.EndTurnAction
	34, // 43: lilbattle.v1.GameMove.build_unit:type_name -> lilbattle.v1.BuildUnitAction
	35, // 44: lilbattle.v1.GameMove.capture_building:type_name -> lilbattle.v1.CaptureBuildingAction
	37, // 45: lilbattle.v1.GameMove.heal_unit:type_name -> lilbattle.v1.HealUnitAction
	38, // 46: lilbattle.v1.GameMove.fix_unit:type_name -> lilbattle.v1.FixUnitAction
	39, // 47: lilbattle.v1.GameMove.changes:type_name -> lilbattle.v1.WorldChange
	31, // 48: lilbattle.v1.MoveUnitAction.from:type_name -> lilbattle.v1.Position
	31, // 49: lilbattle.v1.MoveUnitAction.to:type_name -> lilbattle.v1.Position
	52, // 50: lilbattle.v1.MoveUnitAction.reconstructed_path:type_name -> lilbattle.v1.Path
	31, // 51: lilbattle.v1.AttackUnitAction.attacker:type_name -> lilbattle.v1.Position
	31, // 52: lilbattle.v1.AttackUnitAction.defender:type_name -> lilbattle.v1.Position
	31, // 53: lilbattle.v1.BuildUnitAction.pos:type_name -> lilbattle.v1.Position
	31, // 54: lilbattle.v1.CaptureBuildingAction.pos:type_name -> lilbattle.v1.Position
	31, // 55: lilbattle.v1.HealUnitAction.pos:type_name -> lilbattle.v1.Position
	31, // 56: lilbattle.v1.FixUnitAction.fixer:type_name -> lilbattle.v1.Position
	31, // 57: lilbattle.v1.FixUnitAction.target:type_name -> lilbattle.v1.Position
	42, // 58: lilbattle.v1.WorldChange.unit_moved:type_name -> lilbattle.v1.UnitMovedChange
	43, // 59: lilbattle.v1.WorldChange.unit_damaged:type_name -> lilbattle.v1.UnitDamagedChange
	44, // 60: lilbattle.v1.WorldChange.unit_killed:type_name -> lilbattle.v1.UnitKilledChange
	45, // 61: lilbattle.v1.WorldChange.player_changed:type_name -> lilbattle.v1.PlayerChangedChange
	46, // 62: lilbattle.v1.WorldChange.unit_built:type_name -> lilbattle.v1.UnitBuiltChange
	47, // 63: lilbattle.v1.WorldChange.coins_changed:type_name -> lilbattle.v1.CoinsChangedChange
	48, // 64: lilbattle.v1.WorldChange.tile_captured:type_name -> lilbattle.v1.TileCapturedChange
	49, // 65: lilbattle.v1.WorldChange.capture_started:type_name -> lilbattle.v1.CaptureStartedChange
	40, // 66: lilbattle.v1.WorldChange.unit_healed:type_name -> lilbattle.v1.UnitHealedChange
	41, // 67: lilbattle.v1.WorldChange.unit_fixed:type_name -> lilbattle.v1.UnitFixedChange
	11, // 68: lilbattle.v1.UnitHealedChange.previous_unit:type_name -> lilbattle.v1.Unit
	11, // 69: lilbattle.v1.UnitHealedChange.updated_unit:type_name -> lilbattle.v1.Unit
	11, // 70: lilbattle.v1.UnitFixedChange.fixer_unit:type_name -> lilbattle.v1.Unit
	11, // 71: lilbattle.v1.UnitFixedChange.previous_target:type_name -> lilbattle.v1.Unit
	11, // 72: lilbattle.v1.UnitFixedChange.updated_target:type_name -> lilbattle.v1.Unit
	11, // 73: lilbattle.v1.UnitMovedChange.previous_unit:type_name -> lilbattle.v1.Unit
	11, // 74: lilbattle.v1.UnitMovedChange.updated_unit:type_name -> lilbattle.v1.Unit
	11, // 75: lilbattle.v1.UnitDamagedChange.previous_unit:type_name -> lilbattle.v1.Unit
	11, // 76: lilbattle.v1.UnitDamagedChange.updated_unit:type_name -> lilbattle.v1.Unit
	11, // 77: lilbattle.v1.UnitKilledChange.previous_unit:type_name -> lilbattle.v1.Unit
	11, // 78: lilbattle.v1.PlayerChangedChange.reset_units:type_name -> lilbattle.v1.Unit
	11, // 79: lilbattle.v1.UnitBuiltChange.unit:type_name -> lilbattle.v1.Unit
	11, // 80: lilbattle.v1.TileCapturedChange.capturing_unit:type_name -> lilbattle.v1.Unit
	11, // 81: lilbattle.v1.CaptureStartedChange.capturing_unit:type_name -> lilbattle.v1.Unit
	66, // 82: lilbattle.v1.AllPaths.edges:type_name -> lilbattle.v1.AllPaths.EdgesEntry
	51, // 83: lilbattle.v1.Path.edges:type_name -> lilbattle.v1.PathEdge
	3,  // 84: lilbattle.v1.Path.directions:type_name -> lilbattle.v1.PathDirection
	10, // 85: lilbattle.v1.WorldData.TilesMapEntry.value:type_name -> lilbattle.v1.Tile
	11, // 86: lilbattle.v1.WorldData.UnitsMapEntry.value:type_name -> lilbattle.v1.Unit
	9,  // 87: lilbattle.v1.WorldData.CrossingsEntry.value:type_name -> lilbattle.v1.Crossing
	15, // 88: lilbattle.v1.TerrainDefinition.UnitPropertiesEntry.value:type_name -> lilbattle.v1.TerrainUnitProperties
	15, // 89: lilbattle.v1.UnitDefinition.TerrainPropertiesEntry.value:type_name -> lilbattle.v1.TerrainUnitProperties
	14, // 90: lilbattle.v1.RulesEngine.UnitsEntry.value:type_name -> lilbattle.v1.UnitDefinition
	13, // 91: lilbattle.v1.RulesEngine.TerrainsEntry.value:type_name -> lilbattle.v1.TerrainDefinition
	15, // 92: lilbattle.v1.RulesEngine.TerrainUnitPropertiesEntry.value:type_name -> lilbattle.v1.TerrainUnitProperties
	16, // 93: lilbattle.v1.RulesEngine.UnitUnitPropertiesEntry.value:type_name -> lilbattle.v1.UnitUnitProperties
	1,  // 94: lilbattle.v1.RulesEngine.TerrainTypesEntry.value:type_name -> lilbattle.v1.TerrainType
	26, // 95: lilbattle.v1.GameState.PlayerStatesEntry.value:type_name -> lilbattle.v1.PlayerState
	51, // 96: lilbattle.v1.AllPaths.EdgesEntry.value:type_name -> lilbattle.v1.PathEdge
	97, // [97:97] is the sub-list for method output_type
	97, // [97:97] is the sub-list for method input_type
	97, // [97:97] is the sub-list for extension type_name
	97, // [97:97] is the sub-list for extension extendee
	0,  // [0:97] is the sub-list for field type_name
}

func init() { file_lilbattle_v1_models_models_proto_init() }
func file_lilbattle_v1_models_models_proto_init() {
	if File_lilbattle_v1_models_models_proto != nil {
		return
	}
	file_lilbattle_v1_models_models_proto_msgTypes[12].OneofWrappers = []any{}
	file_lilbattle_v1_models_models_proto_msgTypes[26].OneofWrappers = []any{
		(*GameMove_MoveUnit)(nil),
		(*GameMove_AttackUnit)(nil),
		(*GameMove_EndTurn)(nil),
		(*GameMove_BuildUnit)(nil),
		(*GameMove_CaptureBuilding)(nil),
		(*GameMove_HealUnit)(nil),
		(*GameMove_FixUnit)(nil),
	}
	file_lilbattle_v1_models_models_proto_msgTypes[35].OneofWrappers = []any{
		(*WorldChange_UnitMoved)(nil),
		(*WorldChange_UnitDamaged)(nil),
		(*WorldChange_UnitKilled)(nil),
		(*WorldChange_PlayerChanged)(nil),
		(*WorldChange_UnitBuilt)(nil),
		(*WorldChange_CoinsChanged)(nil),
		(*WorldChange_TileCaptured)(nil),
		(*WorldChange_CaptureStarted)(nil),
		(*WorldChange_UnitHealed)(nil),
		(*WorldChange_UnitFixed)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_lilbattle_v1_models_models_proto_rawDesc), len(file_lilbattle_v1_models_models_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   63,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_lilbattle_v1_models_models_proto_goTypes,
		DependencyIndexes: file_lilbattle_v1_models_models_proto_depIdxs,
		EnumInfos:         file_lilbattle_v1_models_models_proto_enumTypes,
		MessageInfos:      file_lilbattle_v1_models_models_proto_msgTypes,
	}.Build()
	File_lilbattle_v1_models_models_proto = out.File
	file_lilbattle_v1_models_models_proto_goTypes = nil
	file_lilbattle_v1_models_models_proto_depIdxs = nil
}
