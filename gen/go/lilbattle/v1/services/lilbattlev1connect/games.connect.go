// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: lilbattle/v1/services/games.proto

package lilbattlev1connect

import (
	context "context"
	errors "errors"
	http "net/http"
	strings "strings"

	connect "connectrpc.com/connect"
	models "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/models"
	services "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/services"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// GamesServiceName is the fully-qualified name of the GamesService service.
	GamesServiceName = "lilbattle.v1.GamesService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// GamesServiceCreateGameProcedure is the fully-qualified name of the GamesService's CreateGame RPC.
	GamesServiceCreateGameProcedure = "/lilbattle.v1.GamesService/CreateGame"
	// GamesServiceGetGamesProcedure is the fully-qualified name of the GamesService's GetGames RPC.
	GamesServiceGetGamesProcedure = "/lilbattle.v1.GamesService/GetGames"
	// GamesServiceListGamesProcedure is the fully-qualified name of the GamesService's ListGames RPC.
	GamesServiceListGamesProcedure = "/lilbattle.v1.GamesService/ListGames"
	// GamesServiceGetGameProcedure is the fully-qualified name of the GamesService's GetGame RPC.
	GamesServiceGetGameProcedure = "/lilbattle.v1.GamesService/GetGame"
	// GamesServiceDeleteGameProcedure is the fully-qualified name of the GamesService's DeleteGame RPC.
	GamesServiceDeleteGameProcedure = "/lilbattle.v1.GamesService/DeleteGame"
	// GamesServiceUpdateGameProcedure is the fully-qualified name of the GamesService's UpdateGame RPC.
	GamesServiceUpdateGameProcedure = "/lilbattle.v1.GamesService/UpdateGame"
	// GamesServiceGetGameStateProcedure is the fully-qualified name of the GamesService's GetGameState
	// RPC.
	GamesServiceGetGameStateProcedure = "/lilbattle.v1.GamesService/GetGameState"
	// GamesServiceListMovesProcedure is the fully-qualified name of the GamesService's ListMoves RPC.
	GamesServiceListMovesProcedure = "/lilbattle.v1.GamesService/ListMoves"
	// GamesServiceProcessMovesProcedure is the fully-qualified name of the GamesService's ProcessMoves
	// RPC.
	GamesServiceProcessMovesProcedure = "/lilbattle.v1.GamesService/ProcessMoves"
	// GamesServiceGetOptionsAtProcedure is the fully-qualified name of the GamesService's GetOptionsAt
	// RPC.
	GamesServiceGetOptionsAtProcedure = "/lilbattle.v1.GamesService/GetOptionsAt"
	// GamesServiceSimulateAttackProcedure is the fully-qualified name of the GamesService's
	// SimulateAttack RPC.
	GamesServiceSimulateAttackProcedure = "/lilbattle.v1.GamesService/SimulateAttack"
	// GamesServiceSimulateFixProcedure is the fully-qualified name of the GamesService's SimulateFix
	// RPC.
	GamesServiceSimulateFixProcedure = "/lilbattle.v1.GamesService/SimulateFix"
)

// GamesServiceClient is a client for the lilbattle.v1.GamesService service.
type GamesServiceClient interface {
	// *
	// Create a new game
	CreateGame(context.Context, *connect.Request[models.CreateGameRequest]) (*connect.Response[models.CreateGameResponse], error)
	// *
	// Batch get multiple games by ID
	GetGames(context.Context, *connect.Request[models.GetGamesRequest]) (*connect.Response[models.GetGamesResponse], error)
	// ListGames returns all available games
	ListGames(context.Context, *connect.Request[models.ListGamesRequest]) (*connect.Response[models.ListGamesResponse], error)
	// GetGame returns a specific game with metadata
	GetGame(context.Context, *connect.Request[models.GetGameRequest]) (*connect.Response[models.GetGameResponse], error)
	// *
	// Delete a particular game
	DeleteGame(context.Context, *connect.Request[models.DeleteGameRequest]) (*connect.Response[models.DeleteGameResponse], error)
	// GetGame returns a specific game with metadata
	UpdateGame(context.Context, *connect.Request[models.UpdateGameRequest]) (*connect.Response[models.UpdateGameResponse], error)
	// Gets the latest game state
	GetGameState(context.Context, *connect.Request[models.GetGameStateRequest]) (*connect.Response[models.GetGameStateResponse], error)
	// List the moves for a game
	ListMoves(context.Context, *connect.Request[models.ListMovesRequest]) (*connect.Response[models.ListMovesResponse], error)
	ProcessMoves(context.Context, *connect.Request[models.ProcessMovesRequest]) (*connect.Response[models.ProcessMovesResponse], error)
	GetOptionsAt(context.Context, *connect.Request[models.GetOptionsAtRequest]) (*connect.Response[models.GetOptionsAtResponse], error)
	// *
	// Simulates combat between two units to generate damage distributions
	// This is a stateless utility method that doesn't require game state
	SimulateAttack(context.Context, *connect.Request[models.SimulateAttackRequest]) (*connect.Response[models.SimulateAttackResponse], error)
	// *
	// Simulates fix (repair) action to generate health restoration distributions
	// This is a stateless utility method that doesn't require game state
	SimulateFix(context.Context, *connect.Request[models.SimulateFixRequest]) (*connect.Response[models.SimulateFixResponse], error)
}

// NewGamesServiceClient constructs a client for the lilbattle.v1.GamesService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewGamesServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) GamesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	gamesServiceMethods := services.File_lilbattle_v1_services_games_proto.Services().ByName("GamesService").Methods()
	return &gamesServiceClient{
		createGame: connect.NewClient[models.CreateGameRequest, models.CreateGameResponse](
			httpClient,
			baseURL+GamesServiceCreateGameProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("CreateGame")),
			connect.WithClientOptions(opts...),
		),
		getGames: connect.NewClient[models.GetGamesRequest, models.GetGamesResponse](
			httpClient,
			baseURL+GamesServiceGetGamesProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("GetGames")),
			connect.WithClientOptions(opts...),
		),
		listGames: connect.NewClient[models.ListGamesRequest, models.ListGamesResponse](
			httpClient,
			baseURL+GamesServiceListGamesProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("ListGames")),
			connect.WithClientOptions(opts...),
		),
		getGame: connect.NewClient[models.GetGameRequest, models.GetGameResponse](
			httpClient,
			baseURL+GamesServiceGetGameProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("GetGame")),
			connect.WithClientOptions(opts...),
		),
		deleteGame: connect.NewClient[models.DeleteGameRequest, models.DeleteGameResponse](
			httpClient,
			baseURL+GamesServiceDeleteGameProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("DeleteGame")),
			connect.WithClientOptions(opts...),
		),
		updateGame: connect.NewClient[models.UpdateGameRequest, models.UpdateGameResponse](
			httpClient,
			baseURL+GamesServiceUpdateGameProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("UpdateGame")),
			connect.WithClientOptions(opts...),
		),
		getGameState: connect.NewClient[models.GetGameStateRequest, models.GetGameStateResponse](
			httpClient,
			baseURL+GamesServiceGetGameStateProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("GetGameState")),
			connect.WithClientOptions(opts...),
		),
		listMoves: connect.NewClient[models.ListMovesRequest, models.ListMovesResponse](
			httpClient,
			baseURL+GamesServiceListMovesProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("ListMoves")),
			connect.WithClientOptions(opts...),
		),
		processMoves: connect.NewClient[models.ProcessMovesRequest, models.ProcessMovesResponse](
			httpClient,
			baseURL+GamesServiceProcessMovesProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("ProcessMoves")),
			connect.WithClientOptions(opts...),
		),
		getOptionsAt: connect.NewClient[models.GetOptionsAtRequest, models.GetOptionsAtResponse](
			httpClient,
			baseURL+GamesServiceGetOptionsAtProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("GetOptionsAt")),
			connect.WithClientOptions(opts...),
		),
		simulateAttack: connect.NewClient[models.SimulateAttackRequest, models.SimulateAttackResponse](
			httpClient,
			baseURL+GamesServiceSimulateAttackProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("SimulateAttack")),
			connect.WithClientOptions(opts...),
		),
		simulateFix: connect.NewClient[models.SimulateFixRequest, models.SimulateFixResponse](
			httpClient,
			baseURL+GamesServiceSimulateFixProcedure,
			connect.WithSchema(gamesServiceMethods.ByName("SimulateFix")),
			connect.WithClientOptions(opts...),
		),
	}
}

// gamesServiceClient implements GamesServiceClient.
type gamesServiceClient struct {
	createGame     *connect.Client[models.CreateGameRequest, models.CreateGameResponse]
	getGames       *connect.Client[models.GetGamesRequest, models.GetGamesResponse]
	listGames      *connect.Client[models.ListGamesRequest, models.ListGamesResponse]
	getGame        *connect.Client[models.GetGameRequest, models.GetGameResponse]
	deleteGame     *connect.Client[models.DeleteGameRequest, models.DeleteGameResponse]
	updateGame     *connect.Client[models.UpdateGameRequest, models.UpdateGameResponse]
	getGameState   *connect.Client[models.GetGameStateRequest, models.GetGameStateResponse]
	listMoves      *connect.Client[models.ListMovesRequest, models.ListMovesResponse]
	processMoves   *connect.Client[models.ProcessMovesRequest, models.ProcessMovesResponse]
	getOptionsAt   *connect.Client[models.GetOptionsAtRequest, models.GetOptionsAtResponse]
	simulateAttack *connect.Client[models.SimulateAttackRequest, models.SimulateAttackResponse]
	simulateFix    *connect.Client[models.SimulateFixRequest, models.SimulateFixResponse]
}

// CreateGame calls lilbattle.v1.GamesService.CreateGame.
func (c *gamesServiceClient) CreateGame(ctx context.Context, req *connect.Request[models.CreateGameRequest]) (*connect.Response[models.CreateGameResponse], error) {
	return c.createGame.CallUnary(ctx, req)
}

// GetGames calls lilbattle.v1.GamesService.GetGames.
func (c *gamesServiceClient) GetGames(ctx context.Context, req *connect.Request[models.GetGamesRequest]) (*connect.Response[models.GetGamesResponse], error) {
	return c.getGames.CallUnary(ctx, req)
}

// ListGames calls lilbattle.v1.GamesService.ListGames.
func (c *gamesServiceClient) ListGames(ctx context.Context, req *connect.Request[models.ListGamesRequest]) (*connect.Response[models.ListGamesResponse], error) {
	return c.listGames.CallUnary(ctx, req)
}

// GetGame calls lilbattle.v1.GamesService.GetGame.
func (c *gamesServiceClient) GetGame(ctx context.Context, req *connect.Request[models.GetGameRequest]) (*connect.Response[models.GetGameResponse], error) {
	return c.getGame.CallUnary(ctx, req)
}

// DeleteGame calls lilbattle.v1.GamesService.DeleteGame.
func (c *gamesServiceClient) DeleteGame(ctx context.Context, req *connect.Request[models.DeleteGameRequest]) (*connect.Response[models.DeleteGameResponse], error) {
	return c.deleteGame.CallUnary(ctx, req)
}

// UpdateGame calls lilbattle.v1.GamesService.UpdateGame.
func (c *gamesServiceClient) UpdateGame(ctx context.Context, req *connect.Request[models.UpdateGameRequest]) (*connect.Response[models.UpdateGameResponse], error) {
	return c.updateGame.CallUnary(ctx, req)
}

// GetGameState calls lilbattle.v1.GamesService.GetGameState.
func (c *gamesServiceClient) GetGameState(ctx context.Context, req *connect.Request[models.GetGameStateRequest]) (*connect.Response[models.GetGameStateResponse], error) {
	return c.getGameState.CallUnary(ctx, req)
}

// ListMoves calls lilbattle.v1.GamesService.ListMoves.
func (c *gamesServiceClient) ListMoves(ctx context.Context, req *connect.Request[models.ListMovesRequest]) (*connect.Response[models.ListMovesResponse], error) {
	return c.listMoves.CallUnary(ctx, req)
}

// ProcessMoves calls lilbattle.v1.GamesService.ProcessMoves.
func (c *gamesServiceClient) ProcessMoves(ctx context.Context, req *connect.Request[models.ProcessMovesRequest]) (*connect.Response[models.ProcessMovesResponse], error) {
	return c.processMoves.CallUnary(ctx, req)
}

// GetOptionsAt calls lilbattle.v1.GamesService.GetOptionsAt.
func (c *gamesServiceClient) GetOptionsAt(ctx context.Context, req *connect.Request[models.GetOptionsAtRequest]) (*connect.Response[models.GetOptionsAtResponse], error) {
	return c.getOptionsAt.CallUnary(ctx, req)
}

// SimulateAttack calls lilbattle.v1.GamesService.SimulateAttack.
func (c *gamesServiceClient) SimulateAttack(ctx context.Context, req *connect.Request[models.SimulateAttackRequest]) (*connect.Response[models.SimulateAttackResponse], error) {
	return c.simulateAttack.CallUnary(ctx, req)
}

// SimulateFix calls lilbattle.v1.GamesService.SimulateFix.
func (c *gamesServiceClient) SimulateFix(ctx context.Context, req *connect.Request[models.SimulateFixRequest]) (*connect.Response[models.SimulateFixResponse], error) {
	return c.simulateFix.CallUnary(ctx, req)
}

// GamesServiceHandler is an implementation of the lilbattle.v1.GamesService service.
type GamesServiceHandler interface {
	// *
	// Create a new game
	CreateGame(context.Context, *connect.Request[models.CreateGameRequest]) (*connect.Response[models.CreateGameResponse], error)
	// *
	// Batch get multiple games by ID
	GetGames(context.Context, *connect.Request[models.GetGamesRequest]) (*connect.Response[models.GetGamesResponse], error)
	// ListGames returns all available games
	ListGames(context.Context, *connect.Request[models.ListGamesRequest]) (*connect.Response[models.ListGamesResponse], error)
	// GetGame returns a specific game with metadata
	GetGame(context.Context, *connect.Request[models.GetGameRequest]) (*connect.Response[models.GetGameResponse], error)
	// *
	// Delete a particular game
	DeleteGame(context.Context, *connect.Request[models.DeleteGameRequest]) (*connect.Response[models.DeleteGameResponse], error)
	// GetGame returns a specific game with metadata
	UpdateGame(context.Context, *connect.Request[models.UpdateGameRequest]) (*connect.Response[models.UpdateGameResponse], error)
	// Gets the latest game state
	GetGameState(context.Context, *connect.Request[models.GetGameStateRequest]) (*connect.Response[models.GetGameStateResponse], error)
	// List the moves for a game
	ListMoves(context.Context, *connect.Request[models.ListMovesRequest]) (*connect.Response[models.ListMovesResponse], error)
	ProcessMoves(context.Context, *connect.Request[models.ProcessMovesRequest]) (*connect.Response[models.ProcessMovesResponse], error)
	GetOptionsAt(context.Context, *connect.Request[models.GetOptionsAtRequest]) (*connect.Response[models.GetOptionsAtResponse], error)
	// *
	// Simulates combat between two units to generate damage distributions
	// This is a stateless utility method that doesn't require game state
	SimulateAttack(context.Context, *connect.Request[models.SimulateAttackRequest]) (*connect.Response[models.SimulateAttackResponse], error)
	// *
	// Simulates fix (repair) action to generate health restoration distributions
	// This is a stateless utility method that doesn't require game state
	SimulateFix(context.Context, *connect.Request[models.SimulateFixRequest]) (*connect.Response[models.SimulateFixResponse], error)
}

// NewGamesServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewGamesServiceHandler(svc GamesServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	gamesServiceMethods := services.File_lilbattle_v1_services_games_proto.Services().ByName("GamesService").Methods()
	gamesServiceCreateGameHandler := connect.NewUnaryHandler(
		GamesServiceCreateGameProcedure,
		svc.CreateGame,
		connect.WithSchema(gamesServiceMethods.ByName("CreateGame")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceGetGamesHandler := connect.NewUnaryHandler(
		GamesServiceGetGamesProcedure,
		svc.GetGames,
		connect.WithSchema(gamesServiceMethods.ByName("GetGames")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceListGamesHandler := connect.NewUnaryHandler(
		GamesServiceListGamesProcedure,
		svc.ListGames,
		connect.WithSchema(gamesServiceMethods.ByName("ListGames")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceGetGameHandler := connect.NewUnaryHandler(
		GamesServiceGetGameProcedure,
		svc.GetGame,
		connect.WithSchema(gamesServiceMethods.ByName("GetGame")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceDeleteGameHandler := connect.NewUnaryHandler(
		GamesServiceDeleteGameProcedure,
		svc.DeleteGame,
		connect.WithSchema(gamesServiceMethods.ByName("DeleteGame")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceUpdateGameHandler := connect.NewUnaryHandler(
		GamesServiceUpdateGameProcedure,
		svc.UpdateGame,
		connect.WithSchema(gamesServiceMethods.ByName("UpdateGame")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceGetGameStateHandler := connect.NewUnaryHandler(
		GamesServiceGetGameStateProcedure,
		svc.GetGameState,
		connect.WithSchema(gamesServiceMethods.ByName("GetGameState")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceListMovesHandler := connect.NewUnaryHandler(
		GamesServiceListMovesProcedure,
		svc.ListMoves,
		connect.WithSchema(gamesServiceMethods.ByName("ListMoves")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceProcessMovesHandler := connect.NewUnaryHandler(
		GamesServiceProcessMovesProcedure,
		svc.ProcessMoves,
		connect.WithSchema(gamesServiceMethods.ByName("ProcessMoves")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceGetOptionsAtHandler := connect.NewUnaryHandler(
		GamesServiceGetOptionsAtProcedure,
		svc.GetOptionsAt,
		connect.WithSchema(gamesServiceMethods.ByName("GetOptionsAt")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceSimulateAttackHandler := connect.NewUnaryHandler(
		GamesServiceSimulateAttackProcedure,
		svc.SimulateAttack,
		connect.WithSchema(gamesServiceMethods.ByName("SimulateAttack")),
		connect.WithHandlerOptions(opts...),
	)
	gamesServiceSimulateFixHandler := connect.NewUnaryHandler(
		GamesServiceSimulateFixProcedure,
		svc.SimulateFix,
		connect.WithSchema(gamesServiceMethods.ByName("SimulateFix")),
		connect.WithHandlerOptions(opts...),
	)
	return "/lilbattle.v1.GamesService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case GamesServiceCreateGameProcedure:
			gamesServiceCreateGameHandler.ServeHTTP(w, r)
		case GamesServiceGetGamesProcedure:
			gamesServiceGetGamesHandler.ServeHTTP(w, r)
		case GamesServiceListGamesProcedure:
			gamesServiceListGamesHandler.ServeHTTP(w, r)
		case GamesServiceGetGameProcedure:
			gamesServiceGetGameHandler.ServeHTTP(w, r)
		case GamesServiceDeleteGameProcedure:
			gamesServiceDeleteGameHandler.ServeHTTP(w, r)
		case GamesServiceUpdateGameProcedure:
			gamesServiceUpdateGameHandler.ServeHTTP(w, r)
		case GamesServiceGetGameStateProcedure:
			gamesServiceGetGameStateHandler.ServeHTTP(w, r)
		case GamesServiceListMovesProcedure:
			gamesServiceListMovesHandler.ServeHTTP(w, r)
		case GamesServiceProcessMovesProcedure:
			gamesServiceProcessMovesHandler.ServeHTTP(w, r)
		case GamesServiceGetOptionsAtProcedure:
			gamesServiceGetOptionsAtHandler.ServeHTTP(w, r)
		case GamesServiceSimulateAttackProcedure:
			gamesServiceSimulateAttackHandler.ServeHTTP(w, r)
		case GamesServiceSimulateFixProcedure:
			gamesServiceSimulateFixHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedGamesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedGamesServiceHandler struct{}

func (UnimplementedGamesServiceHandler) CreateGame(context.Context, *connect.Request[models.CreateGameRequest]) (*connect.Response[models.CreateGameResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.CreateGame is not implemented"))
}

func (UnimplementedGamesServiceHandler) GetGames(context.Context, *connect.Request[models.GetGamesRequest]) (*connect.Response[models.GetGamesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.GetGames is not implemented"))
}

func (UnimplementedGamesServiceHandler) ListGames(context.Context, *connect.Request[models.ListGamesRequest]) (*connect.Response[models.ListGamesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.ListGames is not implemented"))
}

func (UnimplementedGamesServiceHandler) GetGame(context.Context, *connect.Request[models.GetGameRequest]) (*connect.Response[models.GetGameResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.GetGame is not implemented"))
}

func (UnimplementedGamesServiceHandler) DeleteGame(context.Context, *connect.Request[models.DeleteGameRequest]) (*connect.Response[models.DeleteGameResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.DeleteGame is not implemented"))
}

func (UnimplementedGamesServiceHandler) UpdateGame(context.Context, *connect.Request[models.UpdateGameRequest]) (*connect.Response[models.UpdateGameResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.UpdateGame is not implemented"))
}

func (UnimplementedGamesServiceHandler) GetGameState(context.Context, *connect.Request[models.GetGameStateRequest]) (*connect.Response[models.GetGameStateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.GetGameState is not implemented"))
}

func (UnimplementedGamesServiceHandler) ListMoves(context.Context, *connect.Request[models.ListMovesRequest]) (*connect.Response[models.ListMovesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.ListMoves is not implemented"))
}

func (UnimplementedGamesServiceHandler) ProcessMoves(context.Context, *connect.Request[models.ProcessMovesRequest]) (*connect.Response[models.ProcessMovesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.ProcessMoves is not implemented"))
}

func (UnimplementedGamesServiceHandler) GetOptionsAt(context.Context, *connect.Request[models.GetOptionsAtRequest]) (*connect.Response[models.GetOptionsAtResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.GetOptionsAt is not implemented"))
}

func (UnimplementedGamesServiceHandler) SimulateAttack(context.Context, *connect.Request[models.SimulateAttackRequest]) (*connect.Response[models.SimulateAttackResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.SimulateAttack is not implemented"))
}

func (UnimplementedGamesServiceHandler) SimulateFix(context.Context, *connect.Request[models.SimulateFixRequest]) (*connect.Response[models.SimulateFixResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GamesService.SimulateFix is not implemented"))
}
