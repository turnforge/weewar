// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: lilbattle/v1/services/presenter.proto

package lilbattlev1connect

import (
	context "context"
	errors "errors"
	http "net/http"
	strings "strings"

	connect "connectrpc.com/connect"
	models "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/models"
	services "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/services"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// SingletonInitializerServiceName is the fully-qualified name of the SingletonInitializerService
	// service.
	SingletonInitializerServiceName = "lilbattle.v1.SingletonInitializerService"
	// GameViewPresenterName is the fully-qualified name of the GameViewPresenter service.
	GameViewPresenterName = "lilbattle.v1.GameViewPresenter"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// SingletonInitializerServiceInitializeSingletonProcedure is the fully-qualified name of the
	// SingletonInitializerService's InitializeSingleton RPC.
	SingletonInitializerServiceInitializeSingletonProcedure = "/lilbattle.v1.SingletonInitializerService/InitializeSingleton"
	// GameViewPresenterInitializeGameProcedure is the fully-qualified name of the GameViewPresenter's
	// InitializeGame RPC.
	GameViewPresenterInitializeGameProcedure = "/lilbattle.v1.GameViewPresenter/InitializeGame"
	// GameViewPresenterClientReadyProcedure is the fully-qualified name of the GameViewPresenter's
	// ClientReady RPC.
	GameViewPresenterClientReadyProcedure = "/lilbattle.v1.GameViewPresenter/ClientReady"
	// GameViewPresenterSceneClickedProcedure is the fully-qualified name of the GameViewPresenter's
	// SceneClicked RPC.
	GameViewPresenterSceneClickedProcedure = "/lilbattle.v1.GameViewPresenter/SceneClicked"
	// GameViewPresenterTurnOptionClickedProcedure is the fully-qualified name of the
	// GameViewPresenter's TurnOptionClicked RPC.
	GameViewPresenterTurnOptionClickedProcedure = "/lilbattle.v1.GameViewPresenter/TurnOptionClicked"
	// GameViewPresenterEndTurnButtonClickedProcedure is the fully-qualified name of the
	// GameViewPresenter's EndTurnButtonClicked RPC.
	GameViewPresenterEndTurnButtonClickedProcedure = "/lilbattle.v1.GameViewPresenter/EndTurnButtonClicked"
	// GameViewPresenterBuildOptionClickedProcedure is the fully-qualified name of the
	// GameViewPresenter's BuildOptionClicked RPC.
	GameViewPresenterBuildOptionClickedProcedure = "/lilbattle.v1.GameViewPresenter/BuildOptionClicked"
	// GameViewPresenterApplyRemoteChangesProcedure is the fully-qualified name of the
	// GameViewPresenter's ApplyRemoteChanges RPC.
	GameViewPresenterApplyRemoteChangesProcedure = "/lilbattle.v1.GameViewPresenter/ApplyRemoteChanges"
)

// SingletonInitializerServiceClient is a client for the lilbattle.v1.SingletonInitializerService
// service.
type SingletonInitializerServiceClient interface {
	InitializeSingleton(context.Context, *connect.Request[models.InitializeSingletonRequest]) (*connect.Response[models.InitializeSingletonResponse], error)
}

// NewSingletonInitializerServiceClient constructs a client for the
// lilbattle.v1.SingletonInitializerService service. By default, it uses the Connect protocol with
// the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To use
// the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewSingletonInitializerServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) SingletonInitializerServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	singletonInitializerServiceMethods := services.File_lilbattle_v1_services_presenter_proto.Services().ByName("SingletonInitializerService").Methods()
	return &singletonInitializerServiceClient{
		initializeSingleton: connect.NewClient[models.InitializeSingletonRequest, models.InitializeSingletonResponse](
			httpClient,
			baseURL+SingletonInitializerServiceInitializeSingletonProcedure,
			connect.WithSchema(singletonInitializerServiceMethods.ByName("InitializeSingleton")),
			connect.WithClientOptions(opts...),
		),
	}
}

// singletonInitializerServiceClient implements SingletonInitializerServiceClient.
type singletonInitializerServiceClient struct {
	initializeSingleton *connect.Client[models.InitializeSingletonRequest, models.InitializeSingletonResponse]
}

// InitializeSingleton calls lilbattle.v1.SingletonInitializerService.InitializeSingleton.
func (c *singletonInitializerServiceClient) InitializeSingleton(ctx context.Context, req *connect.Request[models.InitializeSingletonRequest]) (*connect.Response[models.InitializeSingletonResponse], error) {
	return c.initializeSingleton.CallUnary(ctx, req)
}

// SingletonInitializerServiceHandler is an implementation of the
// lilbattle.v1.SingletonInitializerService service.
type SingletonInitializerServiceHandler interface {
	InitializeSingleton(context.Context, *connect.Request[models.InitializeSingletonRequest]) (*connect.Response[models.InitializeSingletonResponse], error)
}

// NewSingletonInitializerServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewSingletonInitializerServiceHandler(svc SingletonInitializerServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	singletonInitializerServiceMethods := services.File_lilbattle_v1_services_presenter_proto.Services().ByName("SingletonInitializerService").Methods()
	singletonInitializerServiceInitializeSingletonHandler := connect.NewUnaryHandler(
		SingletonInitializerServiceInitializeSingletonProcedure,
		svc.InitializeSingleton,
		connect.WithSchema(singletonInitializerServiceMethods.ByName("InitializeSingleton")),
		connect.WithHandlerOptions(opts...),
	)
	return "/lilbattle.v1.SingletonInitializerService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case SingletonInitializerServiceInitializeSingletonProcedure:
			singletonInitializerServiceInitializeSingletonHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedSingletonInitializerServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedSingletonInitializerServiceHandler struct{}

func (UnimplementedSingletonInitializerServiceHandler) InitializeSingleton(context.Context, *connect.Request[models.InitializeSingletonRequest]) (*connect.Response[models.InitializeSingletonResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.SingletonInitializerService.InitializeSingleton is not implemented"))
}

// GameViewPresenterClient is a client for the lilbattle.v1.GameViewPresenter service.
type GameViewPresenterClient interface {
	// *
	// Called on first init based on the game and world data
	InitializeGame(context.Context, *connect.Request[models.InitializeGameRequest]) (*connect.Response[models.InitializeGameResponse], error)
	// *
	// Called by the browser after the UI/scene is fully initialized and ready
	// to receive visual updates (highlights, paths, etc.)
	ClientReady(context.Context, *connect.Request[models.ClientReadyRequest]) (*connect.Response[models.ClientReadyResponse], error)
	// *
	// This is called when the user clicks a tile on the Game Scene
	// The tile can have a unit or just be a plain tile.  It is upto the presenter to
	// change the various view states
	SceneClicked(context.Context, *connect.Request[models.SceneClickedRequest]) (*connect.Response[models.SceneClickedResponse], error)
	// *
	// Called when a particular turn option is clicked in the TurnOptionsPanel
	// Note how we have a strong coupling between what the page elements do and which
	// presenter elements they call
	TurnOptionClicked(context.Context, *connect.Request[models.TurnOptionClickedRequest]) (*connect.Response[models.TurnOptionClickedResponse], error)
	// *
	// Called when user clicked the EndTurn button
	EndTurnButtonClicked(context.Context, *connect.Request[models.EndTurnButtonClickedRequest]) (*connect.Response[models.EndTurnButtonClickedResponse], error)
	// *
	// Called when a build option is clicked in the BuildOptionsModal
	BuildOptionClicked(context.Context, *connect.Request[models.BuildOptionClickedRequest]) (*connect.Response[models.BuildOptionClickedResponse], error)
	// *
	// Apply changes from remote players (received via SyncService subscription).
	// This updates local game state and triggers UI updates for the received WorldChanges.
	// Used by viewers to apply moves made by other players.
	ApplyRemoteChanges(context.Context, *connect.Request[models.ApplyRemoteChangesRequest]) (*connect.Response[models.ApplyRemoteChangesResponse], error)
}

// NewGameViewPresenterClient constructs a client for the lilbattle.v1.GameViewPresenter service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewGameViewPresenterClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) GameViewPresenterClient {
	baseURL = strings.TrimRight(baseURL, "/")
	gameViewPresenterMethods := services.File_lilbattle_v1_services_presenter_proto.Services().ByName("GameViewPresenter").Methods()
	return &gameViewPresenterClient{
		initializeGame: connect.NewClient[models.InitializeGameRequest, models.InitializeGameResponse](
			httpClient,
			baseURL+GameViewPresenterInitializeGameProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("InitializeGame")),
			connect.WithClientOptions(opts...),
		),
		clientReady: connect.NewClient[models.ClientReadyRequest, models.ClientReadyResponse](
			httpClient,
			baseURL+GameViewPresenterClientReadyProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("ClientReady")),
			connect.WithClientOptions(opts...),
		),
		sceneClicked: connect.NewClient[models.SceneClickedRequest, models.SceneClickedResponse](
			httpClient,
			baseURL+GameViewPresenterSceneClickedProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("SceneClicked")),
			connect.WithClientOptions(opts...),
		),
		turnOptionClicked: connect.NewClient[models.TurnOptionClickedRequest, models.TurnOptionClickedResponse](
			httpClient,
			baseURL+GameViewPresenterTurnOptionClickedProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("TurnOptionClicked")),
			connect.WithClientOptions(opts...),
		),
		endTurnButtonClicked: connect.NewClient[models.EndTurnButtonClickedRequest, models.EndTurnButtonClickedResponse](
			httpClient,
			baseURL+GameViewPresenterEndTurnButtonClickedProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("EndTurnButtonClicked")),
			connect.WithClientOptions(opts...),
		),
		buildOptionClicked: connect.NewClient[models.BuildOptionClickedRequest, models.BuildOptionClickedResponse](
			httpClient,
			baseURL+GameViewPresenterBuildOptionClickedProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("BuildOptionClicked")),
			connect.WithClientOptions(opts...),
		),
		applyRemoteChanges: connect.NewClient[models.ApplyRemoteChangesRequest, models.ApplyRemoteChangesResponse](
			httpClient,
			baseURL+GameViewPresenterApplyRemoteChangesProcedure,
			connect.WithSchema(gameViewPresenterMethods.ByName("ApplyRemoteChanges")),
			connect.WithClientOptions(opts...),
		),
	}
}

// gameViewPresenterClient implements GameViewPresenterClient.
type gameViewPresenterClient struct {
	initializeGame       *connect.Client[models.InitializeGameRequest, models.InitializeGameResponse]
	clientReady          *connect.Client[models.ClientReadyRequest, models.ClientReadyResponse]
	sceneClicked         *connect.Client[models.SceneClickedRequest, models.SceneClickedResponse]
	turnOptionClicked    *connect.Client[models.TurnOptionClickedRequest, models.TurnOptionClickedResponse]
	endTurnButtonClicked *connect.Client[models.EndTurnButtonClickedRequest, models.EndTurnButtonClickedResponse]
	buildOptionClicked   *connect.Client[models.BuildOptionClickedRequest, models.BuildOptionClickedResponse]
	applyRemoteChanges   *connect.Client[models.ApplyRemoteChangesRequest, models.ApplyRemoteChangesResponse]
}

// InitializeGame calls lilbattle.v1.GameViewPresenter.InitializeGame.
func (c *gameViewPresenterClient) InitializeGame(ctx context.Context, req *connect.Request[models.InitializeGameRequest]) (*connect.Response[models.InitializeGameResponse], error) {
	return c.initializeGame.CallUnary(ctx, req)
}

// ClientReady calls lilbattle.v1.GameViewPresenter.ClientReady.
func (c *gameViewPresenterClient) ClientReady(ctx context.Context, req *connect.Request[models.ClientReadyRequest]) (*connect.Response[models.ClientReadyResponse], error) {
	return c.clientReady.CallUnary(ctx, req)
}

// SceneClicked calls lilbattle.v1.GameViewPresenter.SceneClicked.
func (c *gameViewPresenterClient) SceneClicked(ctx context.Context, req *connect.Request[models.SceneClickedRequest]) (*connect.Response[models.SceneClickedResponse], error) {
	return c.sceneClicked.CallUnary(ctx, req)
}

// TurnOptionClicked calls lilbattle.v1.GameViewPresenter.TurnOptionClicked.
func (c *gameViewPresenterClient) TurnOptionClicked(ctx context.Context, req *connect.Request[models.TurnOptionClickedRequest]) (*connect.Response[models.TurnOptionClickedResponse], error) {
	return c.turnOptionClicked.CallUnary(ctx, req)
}

// EndTurnButtonClicked calls lilbattle.v1.GameViewPresenter.EndTurnButtonClicked.
func (c *gameViewPresenterClient) EndTurnButtonClicked(ctx context.Context, req *connect.Request[models.EndTurnButtonClickedRequest]) (*connect.Response[models.EndTurnButtonClickedResponse], error) {
	return c.endTurnButtonClicked.CallUnary(ctx, req)
}

// BuildOptionClicked calls lilbattle.v1.GameViewPresenter.BuildOptionClicked.
func (c *gameViewPresenterClient) BuildOptionClicked(ctx context.Context, req *connect.Request[models.BuildOptionClickedRequest]) (*connect.Response[models.BuildOptionClickedResponse], error) {
	return c.buildOptionClicked.CallUnary(ctx, req)
}

// ApplyRemoteChanges calls lilbattle.v1.GameViewPresenter.ApplyRemoteChanges.
func (c *gameViewPresenterClient) ApplyRemoteChanges(ctx context.Context, req *connect.Request[models.ApplyRemoteChangesRequest]) (*connect.Response[models.ApplyRemoteChangesResponse], error) {
	return c.applyRemoteChanges.CallUnary(ctx, req)
}

// GameViewPresenterHandler is an implementation of the lilbattle.v1.GameViewPresenter service.
type GameViewPresenterHandler interface {
	// *
	// Called on first init based on the game and world data
	InitializeGame(context.Context, *connect.Request[models.InitializeGameRequest]) (*connect.Response[models.InitializeGameResponse], error)
	// *
	// Called by the browser after the UI/scene is fully initialized and ready
	// to receive visual updates (highlights, paths, etc.)
	ClientReady(context.Context, *connect.Request[models.ClientReadyRequest]) (*connect.Response[models.ClientReadyResponse], error)
	// *
	// This is called when the user clicks a tile on the Game Scene
	// The tile can have a unit or just be a plain tile.  It is upto the presenter to
	// change the various view states
	SceneClicked(context.Context, *connect.Request[models.SceneClickedRequest]) (*connect.Response[models.SceneClickedResponse], error)
	// *
	// Called when a particular turn option is clicked in the TurnOptionsPanel
	// Note how we have a strong coupling between what the page elements do and which
	// presenter elements they call
	TurnOptionClicked(context.Context, *connect.Request[models.TurnOptionClickedRequest]) (*connect.Response[models.TurnOptionClickedResponse], error)
	// *
	// Called when user clicked the EndTurn button
	EndTurnButtonClicked(context.Context, *connect.Request[models.EndTurnButtonClickedRequest]) (*connect.Response[models.EndTurnButtonClickedResponse], error)
	// *
	// Called when a build option is clicked in the BuildOptionsModal
	BuildOptionClicked(context.Context, *connect.Request[models.BuildOptionClickedRequest]) (*connect.Response[models.BuildOptionClickedResponse], error)
	// *
	// Apply changes from remote players (received via SyncService subscription).
	// This updates local game state and triggers UI updates for the received WorldChanges.
	// Used by viewers to apply moves made by other players.
	ApplyRemoteChanges(context.Context, *connect.Request[models.ApplyRemoteChangesRequest]) (*connect.Response[models.ApplyRemoteChangesResponse], error)
}

// NewGameViewPresenterHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewGameViewPresenterHandler(svc GameViewPresenterHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	gameViewPresenterMethods := services.File_lilbattle_v1_services_presenter_proto.Services().ByName("GameViewPresenter").Methods()
	gameViewPresenterInitializeGameHandler := connect.NewUnaryHandler(
		GameViewPresenterInitializeGameProcedure,
		svc.InitializeGame,
		connect.WithSchema(gameViewPresenterMethods.ByName("InitializeGame")),
		connect.WithHandlerOptions(opts...),
	)
	gameViewPresenterClientReadyHandler := connect.NewUnaryHandler(
		GameViewPresenterClientReadyProcedure,
		svc.ClientReady,
		connect.WithSchema(gameViewPresenterMethods.ByName("ClientReady")),
		connect.WithHandlerOptions(opts...),
	)
	gameViewPresenterSceneClickedHandler := connect.NewUnaryHandler(
		GameViewPresenterSceneClickedProcedure,
		svc.SceneClicked,
		connect.WithSchema(gameViewPresenterMethods.ByName("SceneClicked")),
		connect.WithHandlerOptions(opts...),
	)
	gameViewPresenterTurnOptionClickedHandler := connect.NewUnaryHandler(
		GameViewPresenterTurnOptionClickedProcedure,
		svc.TurnOptionClicked,
		connect.WithSchema(gameViewPresenterMethods.ByName("TurnOptionClicked")),
		connect.WithHandlerOptions(opts...),
	)
	gameViewPresenterEndTurnButtonClickedHandler := connect.NewUnaryHandler(
		GameViewPresenterEndTurnButtonClickedProcedure,
		svc.EndTurnButtonClicked,
		connect.WithSchema(gameViewPresenterMethods.ByName("EndTurnButtonClicked")),
		connect.WithHandlerOptions(opts...),
	)
	gameViewPresenterBuildOptionClickedHandler := connect.NewUnaryHandler(
		GameViewPresenterBuildOptionClickedProcedure,
		svc.BuildOptionClicked,
		connect.WithSchema(gameViewPresenterMethods.ByName("BuildOptionClicked")),
		connect.WithHandlerOptions(opts...),
	)
	gameViewPresenterApplyRemoteChangesHandler := connect.NewUnaryHandler(
		GameViewPresenterApplyRemoteChangesProcedure,
		svc.ApplyRemoteChanges,
		connect.WithSchema(gameViewPresenterMethods.ByName("ApplyRemoteChanges")),
		connect.WithHandlerOptions(opts...),
	)
	return "/lilbattle.v1.GameViewPresenter/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case GameViewPresenterInitializeGameProcedure:
			gameViewPresenterInitializeGameHandler.ServeHTTP(w, r)
		case GameViewPresenterClientReadyProcedure:
			gameViewPresenterClientReadyHandler.ServeHTTP(w, r)
		case GameViewPresenterSceneClickedProcedure:
			gameViewPresenterSceneClickedHandler.ServeHTTP(w, r)
		case GameViewPresenterTurnOptionClickedProcedure:
			gameViewPresenterTurnOptionClickedHandler.ServeHTTP(w, r)
		case GameViewPresenterEndTurnButtonClickedProcedure:
			gameViewPresenterEndTurnButtonClickedHandler.ServeHTTP(w, r)
		case GameViewPresenterBuildOptionClickedProcedure:
			gameViewPresenterBuildOptionClickedHandler.ServeHTTP(w, r)
		case GameViewPresenterApplyRemoteChangesProcedure:
			gameViewPresenterApplyRemoteChangesHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedGameViewPresenterHandler returns CodeUnimplemented from all methods.
type UnimplementedGameViewPresenterHandler struct{}

func (UnimplementedGameViewPresenterHandler) InitializeGame(context.Context, *connect.Request[models.InitializeGameRequest]) (*connect.Response[models.InitializeGameResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.InitializeGame is not implemented"))
}

func (UnimplementedGameViewPresenterHandler) ClientReady(context.Context, *connect.Request[models.ClientReadyRequest]) (*connect.Response[models.ClientReadyResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.ClientReady is not implemented"))
}

func (UnimplementedGameViewPresenterHandler) SceneClicked(context.Context, *connect.Request[models.SceneClickedRequest]) (*connect.Response[models.SceneClickedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.SceneClicked is not implemented"))
}

func (UnimplementedGameViewPresenterHandler) TurnOptionClicked(context.Context, *connect.Request[models.TurnOptionClickedRequest]) (*connect.Response[models.TurnOptionClickedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.TurnOptionClicked is not implemented"))
}

func (UnimplementedGameViewPresenterHandler) EndTurnButtonClicked(context.Context, *connect.Request[models.EndTurnButtonClickedRequest]) (*connect.Response[models.EndTurnButtonClickedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.EndTurnButtonClicked is not implemented"))
}

func (UnimplementedGameViewPresenterHandler) BuildOptionClicked(context.Context, *connect.Request[models.BuildOptionClickedRequest]) (*connect.Response[models.BuildOptionClickedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.BuildOptionClicked is not implemented"))
}

func (UnimplementedGameViewPresenterHandler) ApplyRemoteChanges(context.Context, *connect.Request[models.ApplyRemoteChangesRequest]) (*connect.Response[models.ApplyRemoteChangesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("lilbattle.v1.GameViewPresenter.ApplyRemoteChanges is not implemented"))
}
