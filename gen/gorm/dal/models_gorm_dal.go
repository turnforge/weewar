// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package dal

import (
	"context"
	"errors"

	gorm "github.com/turnforge/lilbattle/gen/gorm"
	gormlib "gorm.io/gorm"
)

// WorldGORMDAL provides database access helper methods for gorm.WorldGORM.
type WorldGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.WorldGORM) error
}

// NewWorldGORMDAL creates a new WorldGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewWorldGORMDAL(tableName string) *WorldGORMDAL {
	return &WorldGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *WorldGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.WorldGORM record.
// Returns an error if the record already exists.
func (d *WorldGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.WorldGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.WorldGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *WorldGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.WorldGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.WorldGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *WorldGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.WorldGORM) error {
	// Validate primary key(s)
	if obj.Id == "" {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.WorldGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.WorldGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *WorldGORMDAL) Get(ctx context.Context, db *gormlib.DB, id string) (*gorm.WorldGORM, error) {
	var out gorm.WorldGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.WorldGORM record by primary key.
func (d *WorldGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id string) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.WorldGORM{}).Error
}

// List retrieves multiple gorm.WorldGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *WorldGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.WorldGORM, error) {
	var out []*gorm.WorldGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.WorldGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *WorldGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []string) ([]*gorm.WorldGORM, error) {
	if len(ids) == 0 {
		return []*gorm.WorldGORM{}, nil
	}

	var out []*gorm.WorldGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// WorldDataGORMDAL provides database access helper methods for gorm.WorldDataGORM.
type WorldDataGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.WorldDataGORM) error
}

// NewWorldDataGORMDAL creates a new WorldDataGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewWorldDataGORMDAL(tableName string) *WorldDataGORMDAL {
	return &WorldDataGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *WorldDataGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.WorldDataGORM record.
// Returns an error if the record already exists.
func (d *WorldDataGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.WorldDataGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.WorldDataGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *WorldDataGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.WorldDataGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.WorldDataGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *WorldDataGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.WorldDataGORM) error {
	// Validate primary key(s)
	if obj.WorldId == "" {
		return errors.New("primary key 'WorldId' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.WorldDataGORM
	err := d.db(db).First(&existing, "world_id = ?", obj.WorldId).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.WorldDataGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *WorldDataGORMDAL) Get(ctx context.Context, db *gormlib.DB, worldId string) (*gorm.WorldDataGORM, error) {
	var out gorm.WorldDataGORM
	err := d.db(db).First(&out, "world_id = ?", worldId).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.WorldDataGORM record by primary key.
func (d *WorldDataGORMDAL) Delete(ctx context.Context, db *gormlib.DB, worldId string) error {
	return d.db(db).Where("world_id = ?", worldId).Delete(&gorm.WorldDataGORM{}).Error
}

// List retrieves multiple gorm.WorldDataGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *WorldDataGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.WorldDataGORM, error) {
	var out []*gorm.WorldDataGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.WorldDataGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *WorldDataGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, worldIds []string) ([]*gorm.WorldDataGORM, error) {
	if len(worldIds) == 0 {
		return []*gorm.WorldDataGORM{}, nil
	}

	var out []*gorm.WorldDataGORM
	err := d.db(db).Where("world_id IN ?", worldIds).Find(&out).Error
	return out, err
}

// GameGORMDAL provides database access helper methods for gorm.GameGORM.
type GameGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.GameGORM) error
}

// NewGameGORMDAL creates a new GameGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewGameGORMDAL(tableName string) *GameGORMDAL {
	return &GameGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *GameGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.GameGORM record.
// Returns an error if the record already exists.
func (d *GameGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.GameGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.GameGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *GameGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.GameGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.GameGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *GameGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.GameGORM) error {
	// Validate primary key(s)
	if obj.Id == "" {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.GameGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.GameGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *GameGORMDAL) Get(ctx context.Context, db *gormlib.DB, id string) (*gorm.GameGORM, error) {
	var out gorm.GameGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.GameGORM record by primary key.
func (d *GameGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id string) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.GameGORM{}).Error
}

// List retrieves multiple gorm.GameGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *GameGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.GameGORM, error) {
	var out []*gorm.GameGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.GameGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *GameGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []string) ([]*gorm.GameGORM, error) {
	if len(ids) == 0 {
		return []*gorm.GameGORM{}, nil
	}

	var out []*gorm.GameGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// GameStateGORMDAL provides database access helper methods for gorm.GameStateGORM.
type GameStateGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.GameStateGORM) error
}

// NewGameStateGORMDAL creates a new GameStateGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewGameStateGORMDAL(tableName string) *GameStateGORMDAL {
	return &GameStateGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *GameStateGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.GameStateGORM record.
// Returns an error if the record already exists.
func (d *GameStateGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.GameStateGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.GameStateGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *GameStateGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.GameStateGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.GameStateGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *GameStateGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.GameStateGORM) error {
	// Validate primary key(s)
	if obj.GameId == "" {
		return errors.New("primary key 'GameId' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.GameStateGORM
	err := d.db(db).First(&existing, "game_id = ?", obj.GameId).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.GameStateGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *GameStateGORMDAL) Get(ctx context.Context, db *gormlib.DB, gameId string) (*gorm.GameStateGORM, error) {
	var out gorm.GameStateGORM
	err := d.db(db).First(&out, "game_id = ?", gameId).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.GameStateGORM record by primary key.
func (d *GameStateGORMDAL) Delete(ctx context.Context, db *gormlib.DB, gameId string) error {
	return d.db(db).Where("game_id = ?", gameId).Delete(&gorm.GameStateGORM{}).Error
}

// List retrieves multiple gorm.GameStateGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *GameStateGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.GameStateGORM, error) {
	var out []*gorm.GameStateGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.GameStateGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *GameStateGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, gameIds []string) ([]*gorm.GameStateGORM, error) {
	if len(gameIds) == 0 {
		return []*gorm.GameStateGORM{}, nil
	}

	var out []*gorm.GameStateGORM
	err := d.db(db).Where("game_id IN ?", gameIds).Find(&out).Error
	return out, err
}

// GameMoveKey represents the composite primary key for gorm.GameMoveGORM
type GameMoveKey struct {
	GameId      string
	GroupNumber int64
	MoveNumber  int64
}

// GameMoveGORMDAL provides database access helper methods for gorm.GameMoveGORM.
type GameMoveGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.GameMoveGORM) error
}

// NewGameMoveGORMDAL creates a new GameMoveGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewGameMoveGORMDAL(tableName string) *GameMoveGORMDAL {
	return &GameMoveGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *GameMoveGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.GameMoveGORM record.
// Returns an error if the record already exists.
func (d *GameMoveGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.GameMoveGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.GameMoveGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *GameMoveGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.GameMoveGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.GameMoveGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *GameMoveGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.GameMoveGORM) error {
	// Validate primary key(s)
	if obj.GameId == "" {
		return errors.New("primary key 'GameId' cannot be empty")
	}
	if obj.GroupNumber == 0 {
		return errors.New("primary key 'GroupNumber' cannot be empty")
	}
	if obj.MoveNumber == 0 {
		return errors.New("primary key 'MoveNumber' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.GameMoveGORM
	err := d.db(db).First(&existing, "game_id = ?", "group_number = ?", "move_number = ?", obj.GameId, obj.GroupNumber, obj.MoveNumber).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.GameMoveGORM record by primary keys.
// Returns (nil, nil) if the record is not found (not an error).
func (d *GameMoveGORMDAL) Get(ctx context.Context, db *gormlib.DB, gameId string, groupNumber int64, moveNumber int64) (*gorm.GameMoveGORM, error) {
	var out gorm.GameMoveGORM
	err := d.db(db).First(&out, "game_id = ? AND group_number = ? AND move_number = ?", gameId, groupNumber, moveNumber).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.GameMoveGORM record by primary keys.
func (d *GameMoveGORMDAL) Delete(ctx context.Context, db *gormlib.DB, gameId string, groupNumber int64, moveNumber int64) error {
	return d.db(db).Where("game_id = ? AND group_number = ? AND move_number = ?", gameId, groupNumber, moveNumber).Delete(&gorm.GameMoveGORM{}).Error
}

// List retrieves multiple gorm.GameMoveGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *GameMoveGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.GameMoveGORM, error) {
	var out []*gorm.GameMoveGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.GameMoveGORM records by primary keys.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *GameMoveGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, keys []GameMoveKey) ([]*gorm.GameMoveGORM, error) {
	if len(keys) == 0 {
		return []*gorm.GameMoveGORM{}, nil
	}

	// Build OR query for each key combination
	query := d.db(db).Where("1 = 0") // Start with false condition
	for _, key := range keys {
		query = query.Or("game_id = ? AND group_number = ? AND move_number = ?", key.GameId, key.GroupNumber, key.MoveNumber)
	}

	var out []*gorm.GameMoveGORM
	err := query.Find(&out).Error
	return out, err
}
