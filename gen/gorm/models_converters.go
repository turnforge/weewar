// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package gorm

import (
	"fmt"

	"github.com/panyam/protoc-gen-dal/pkg/converters"
	models "github.com/turnforge/weewar/gen/go/weewar/v1/models"
)

// IndexInfoToIndexInfoGORM converts a models.IndexInfo to IndexInfoGORM.
// The optional decorator function allows custom field transformations.
func IndexInfoToIndexInfoGORM(
	src *models.IndexInfo,
	dest *IndexInfoGORM,
	decorator func(*models.IndexInfo, *IndexInfoGORM) error,
) (out *IndexInfoGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IndexInfoGORM{}
	}

	// Initialize struct with inline values
	*dest = IndexInfoGORM{
		NeedsIndexing: src.NeedsIndexing,
	}
	out = dest

	if src.LastUpdatedAt != nil {
		out.LastUpdatedAt = converters.TimestampToTime(src.LastUpdatedAt)
	}

	if src.LastIndexedAt != nil {
		out.LastIndexedAt = converters.TimestampToTime(src.LastIndexedAt)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IndexInfoFromIndexInfoGORM converts a IndexInfoGORM back to models.IndexInfo.
// The optional decorator function allows custom field transformations.
func IndexInfoFromIndexInfoGORM(
	dest *models.IndexInfo,
	src *IndexInfoGORM,
	decorator func(dest *models.IndexInfo, src *IndexInfoGORM) error,
) (out *models.IndexInfo, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IndexInfo{}
	}

	// Initialize struct with inline values
	*dest = models.IndexInfo{
		LastUpdatedAt: converters.TimeToTimestamp(src.LastUpdatedAt),
		LastIndexedAt: converters.TimeToTimestamp(src.LastIndexedAt),
		NeedsIndexing: src.NeedsIndexing,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// TileToTileGORM converts a models.Tile to TileGORM.
// The optional decorator function allows custom field transformations.
func TileToTileGORM(
	src *models.Tile,
	dest *TileGORM,
	decorator func(*models.Tile, *TileGORM) error,
) (out *TileGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &TileGORM{}
	}

	// Initialize struct with inline values
	*dest = TileGORM{
		Q:                src.Q,
		R:                src.R,
		TileType:         src.TileType,
		Player:           src.Player,
		Shortcut:         src.Shortcut,
		LastActedTurn:    src.LastActedTurn,
		LastToppedupTurn: src.LastToppedupTurn,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// TileFromTileGORM converts a TileGORM back to models.Tile.
// The optional decorator function allows custom field transformations.
func TileFromTileGORM(
	dest *models.Tile,
	src *TileGORM,
	decorator func(dest *models.Tile, src *TileGORM) error,
) (out *models.Tile, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Tile{}
	}

	// Initialize struct with inline values
	*dest = models.Tile{
		Q:                src.Q,
		R:                src.R,
		TileType:         src.TileType,
		Player:           src.Player,
		Shortcut:         src.Shortcut,
		LastActedTurn:    src.LastActedTurn,
		LastToppedupTurn: src.LastToppedupTurn,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// CrossingToCrossingGORM converts a models.Crossing to CrossingGORM.
// The optional decorator function allows custom field transformations.
func CrossingToCrossingGORM(
	src *models.Crossing,
	dest *CrossingGORM,
	decorator func(*models.Crossing, *CrossingGORM) error,
) (out *CrossingGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &CrossingGORM{}
	}

	// Initialize struct with inline values
	*dest = CrossingGORM{
		Type:       src.Type,
		ConnectsTo: src.ConnectsTo,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// CrossingFromCrossingGORM converts a CrossingGORM back to models.Crossing.
// The optional decorator function allows custom field transformations.
func CrossingFromCrossingGORM(
	dest *models.Crossing,
	src *CrossingGORM,
	decorator func(dest *models.Crossing, src *CrossingGORM) error,
) (out *models.Crossing, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Crossing{}
	}

	// Initialize struct with inline values
	*dest = models.Crossing{
		Type:       src.Type,
		ConnectsTo: src.ConnectsTo,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// UnitToUnitGORM converts a models.Unit to UnitGORM.
// The optional decorator function allows custom field transformations.
func UnitToUnitGORM(
	src *models.Unit,
	dest *UnitGORM,
	decorator func(*models.Unit, *UnitGORM) error,
) (out *UnitGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &UnitGORM{}
	}

	// Initialize struct with inline values
	*dest = UnitGORM{
		Q:                       src.Q,
		R:                       src.R,
		Player:                  src.Player,
		UnitType:                src.UnitType,
		Shortcut:                src.Shortcut,
		AvailableHealth:         src.AvailableHealth,
		DistanceLeft:            src.DistanceLeft,
		LastActedTurn:           src.LastActedTurn,
		LastToppedupTurn:        src.LastToppedupTurn,
		AttacksReceivedThisTurn: src.AttacksReceivedThisTurn,
		ProgressionStep:         src.ProgressionStep,
		ChosenAlternative:       src.ChosenAlternative,
		CaptureStartedTurn:      src.CaptureStartedTurn,
	}
	out = dest

	if src.AttackHistory != nil {
		out.AttackHistory = make([]AttackRecordGORM, len(src.AttackHistory))
		for i, item := range src.AttackHistory {
			_, err = AttackRecordToAttackRecordGORM(item, &out.AttackHistory[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting AttackHistory[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// UnitFromUnitGORM converts a UnitGORM back to models.Unit.
// The optional decorator function allows custom field transformations.
func UnitFromUnitGORM(
	dest *models.Unit,
	src *UnitGORM,
	decorator func(dest *models.Unit, src *UnitGORM) error,
) (out *models.Unit, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Unit{}
	}

	// Initialize struct with inline values
	*dest = models.Unit{
		Q:                       src.Q,
		R:                       src.R,
		Player:                  src.Player,
		UnitType:                src.UnitType,
		Shortcut:                src.Shortcut,
		AvailableHealth:         src.AvailableHealth,
		DistanceLeft:            src.DistanceLeft,
		LastActedTurn:           src.LastActedTurn,
		LastToppedupTurn:        src.LastToppedupTurn,
		AttacksReceivedThisTurn: src.AttacksReceivedThisTurn,
		ProgressionStep:         src.ProgressionStep,
		ChosenAlternative:       src.ChosenAlternative,
		CaptureStartedTurn:      src.CaptureStartedTurn,
	}
	out = dest

	if src.AttackHistory != nil {
		out.AttackHistory = make([]*models.AttackRecord, len(src.AttackHistory))
		for i, item := range src.AttackHistory {
			out.AttackHistory[i], err = AttackRecordFromAttackRecordGORM(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting AttackHistory[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// AttackRecordToAttackRecordGORM converts a models.AttackRecord to AttackRecordGORM.
// The optional decorator function allows custom field transformations.
func AttackRecordToAttackRecordGORM(
	src *models.AttackRecord,
	dest *AttackRecordGORM,
	decorator func(*models.AttackRecord, *AttackRecordGORM) error,
) (out *AttackRecordGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &AttackRecordGORM{}
	}

	// Initialize struct with inline values
	*dest = AttackRecordGORM{
		Q:          src.Q,
		R:          src.R,
		IsRanged:   src.IsRanged,
		TurnNumber: src.TurnNumber,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// AttackRecordFromAttackRecordGORM converts a AttackRecordGORM back to models.AttackRecord.
// The optional decorator function allows custom field transformations.
func AttackRecordFromAttackRecordGORM(
	dest *models.AttackRecord,
	src *AttackRecordGORM,
	decorator func(dest *models.AttackRecord, src *AttackRecordGORM) error,
) (out *models.AttackRecord, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.AttackRecord{}
	}

	// Initialize struct with inline values
	*dest = models.AttackRecord{
		Q:          src.Q,
		R:          src.R,
		IsRanged:   src.IsRanged,
		TurnNumber: src.TurnNumber,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// WorldToWorldGORM converts a models.World to WorldGORM.
// The optional decorator function allows custom field transformations.
func WorldToWorldGORM(
	src *models.World,
	dest *WorldGORM,
	decorator func(*models.World, *WorldGORM) error,
) (out *WorldGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &WorldGORM{}
	}

	// Initialize struct with inline values
	*dest = WorldGORM{
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	if src.CreatedAt != nil {
		out.CreatedAt = converters.TimestampToTime(src.CreatedAt)
	}

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.DefaultGameConfig != nil {
		_, err = GameConfigurationToGameConfigurationGORM(src.DefaultGameConfig, &out.DefaultGameConfig, nil)
		if err != nil {
			return nil, fmt.Errorf("converting DefaultGameConfig: %w", err)
		}
	}
	if src.SearchIndexInfo != nil {
		_, err = IndexInfoToIndexInfoGORM(src.SearchIndexInfo, &out.SearchIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldFromWorldGORM converts a WorldGORM back to models.World.
// The optional decorator function allows custom field transformations.
func WorldFromWorldGORM(
	dest *models.World,
	src *WorldGORM,
	decorator func(dest *models.World, src *WorldGORM) error,
) (out *models.World, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.World{}
	}

	// Initialize struct with inline values
	*dest = models.World{
		CreatedAt:   converters.TimeToTimestamp(src.CreatedAt),
		UpdatedAt:   converters.TimeToTimestamp(src.UpdatedAt),
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	out.DefaultGameConfig, err = GameConfigurationFromGameConfigurationGORM(nil, &src.DefaultGameConfig, nil)
	if err != nil {
		return nil, fmt.Errorf("converting DefaultGameConfig: %w", err)
	}
	out.SearchIndexInfo, err = IndexInfoFromIndexInfoGORM(nil, &src.SearchIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// WorldDataToWorldDataGORM converts a models.WorldData to WorldDataGORM.
// The optional decorator function allows custom field transformations.
func WorldDataToWorldDataGORM(
	src *models.WorldData,
	dest *WorldDataGORM,
	decorator func(*models.WorldData, *WorldDataGORM) error,
) (out *WorldDataGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &WorldDataGORM{}
	}

	// Initialize struct with inline values
	*dest = WorldDataGORM{
		ContentHash: src.ContentHash,
		Version:     src.Version,
	}
	out = dest

	if src.ScreenshotIndexInfo != nil {
		_, err = IndexInfoToIndexInfoGORM(src.ScreenshotIndexInfo, &out.ScreenshotIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting ScreenshotIndexInfo: %w", err)
		}
	}

	if src.TilesMap != nil {
		out.TilesMap = make(map[string]TileGORM, len(src.TilesMap))
		for key, value := range src.TilesMap {
			var converted TileGORM
			_, err = TileToTileGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting TilesMap[%v]: %w", key, err)
			}
			out.TilesMap[key] = converted
		}
	}
	if src.UnitsMap != nil {
		out.UnitsMap = make(map[string]UnitGORM, len(src.UnitsMap))
		for key, value := range src.UnitsMap {
			var converted UnitGORM
			_, err = UnitToUnitGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting UnitsMap[%v]: %w", key, err)
			}
			out.UnitsMap[key] = converted
		}
	}
	if src.Crossings != nil {
		out.Crossings = make(map[string]CrossingGORM, len(src.Crossings))
		for key, value := range src.Crossings {
			var converted CrossingGORM
			_, err = CrossingToCrossingGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Crossings[%v]: %w", key, err)
			}
			out.Crossings[key] = converted
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldDataFromWorldDataGORM converts a WorldDataGORM back to models.WorldData.
// The optional decorator function allows custom field transformations.
func WorldDataFromWorldDataGORM(
	dest *models.WorldData,
	src *WorldDataGORM,
	decorator func(dest *models.WorldData, src *WorldDataGORM) error,
) (out *models.WorldData, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.WorldData{}
	}

	// Initialize struct with inline values
	*dest = models.WorldData{
		ContentHash: src.ContentHash,
		Version:     src.Version,
	}
	out = dest

	out.ScreenshotIndexInfo, err = IndexInfoFromIndexInfoGORM(nil, &src.ScreenshotIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting ScreenshotIndexInfo: %w", err)
	}

	if src.TilesMap != nil {
		out.TilesMap = make(map[string]*models.Tile, len(src.TilesMap))
		for key, value := range src.TilesMap {
			out.TilesMap[key], err = TileFromTileGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting TilesMap[%v]: %w", key, err)
			}
		}
	}
	if src.UnitsMap != nil {
		out.UnitsMap = make(map[string]*models.Unit, len(src.UnitsMap))
		for key, value := range src.UnitsMap {
			out.UnitsMap[key], err = UnitFromUnitGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting UnitsMap[%v]: %w", key, err)
			}
		}
	}
	if src.Crossings != nil {
		out.Crossings = make(map[string]*models.Crossing, len(src.Crossings))
		for key, value := range src.Crossings {
			out.Crossings[key], err = CrossingFromCrossingGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Crossings[%v]: %w", key, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameToGameGORM converts a models.Game to GameGORM.
// The optional decorator function allows custom field transformations.
func GameToGameGORM(
	src *models.Game,
	dest *GameGORM,
	decorator func(*models.Game, *GameGORM) error,
) (out *GameGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameGORM{}
	}

	// Initialize struct with inline values
	*dest = GameGORM{
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		WorldId:     src.WorldId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	if src.CreatedAt != nil {
		out.CreatedAt = converters.TimestampToTime(src.CreatedAt)
	}

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.Config != nil {
		_, err = GameConfigurationToGameConfigurationGORM(src.Config, &out.Config, nil)
		if err != nil {
			return nil, fmt.Errorf("converting Config: %w", err)
		}
	}
	if src.SearchIndexInfo != nil {
		_, err = IndexInfoToIndexInfoGORM(src.SearchIndexInfo, &out.SearchIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameFromGameGORM converts a GameGORM back to models.Game.
// The optional decorator function allows custom field transformations.
func GameFromGameGORM(
	dest *models.Game,
	src *GameGORM,
	decorator func(dest *models.Game, src *GameGORM) error,
) (out *models.Game, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.Game{}
	}

	// Initialize struct with inline values
	*dest = models.Game{
		CreatedAt:   converters.TimeToTimestamp(src.CreatedAt),
		UpdatedAt:   converters.TimeToTimestamp(src.UpdatedAt),
		Version:     src.Version,
		Id:          src.Id,
		CreatorId:   src.CreatorId,
		WorldId:     src.WorldId,
		Name:        src.Name,
		Description: src.Description,
		Tags:        src.Tags,
		ImageUrl:    src.ImageUrl,
		Difficulty:  src.Difficulty,
		PreviewUrls: src.PreviewUrls,
	}
	out = dest

	out.Config, err = GameConfigurationFromGameConfigurationGORM(nil, &src.Config, nil)
	if err != nil {
		return nil, fmt.Errorf("converting Config: %w", err)
	}
	out.SearchIndexInfo, err = IndexInfoFromIndexInfoGORM(nil, &src.SearchIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting SearchIndexInfo: %w", err)
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameConfigurationToGameConfigurationGORM converts a models.GameConfiguration to GameConfigurationGORM.
// The optional decorator function allows custom field transformations.
func GameConfigurationToGameConfigurationGORM(
	src *models.GameConfiguration,
	dest *GameConfigurationGORM,
	decorator func(*models.GameConfiguration, *GameConfigurationGORM) error,
) (out *GameConfigurationGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameConfigurationGORM{}
	}

	// Initialize struct with inline values
	*dest = GameConfigurationGORM{}
	out = dest

	if src.IncomeConfigs != nil {
		_, err = IncomeConfigToIncomeConfigGORM(src.IncomeConfigs, &out.IncomeConfigs, nil)
		if err != nil {
			return nil, fmt.Errorf("converting IncomeConfigs: %w", err)
		}
	}
	if src.Settings != nil {
		_, err = GameSettingsToGameSettingsGORM(src.Settings, &out.Settings, nil)
		if err != nil {
			return nil, fmt.Errorf("converting Settings: %w", err)
		}
	}

	if src.Players != nil {
		out.Players = make([]GamePlayerGORM, len(src.Players))
		for i, item := range src.Players {
			_, err = GamePlayerToGamePlayerGORM(item, &out.Players[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Players[%d]: %w", i, err)
			}
		}
	}
	if src.Teams != nil {
		out.Teams = make([]GameTeamGORM, len(src.Teams))
		for i, item := range src.Teams {
			_, err = GameTeamToGameTeamGORM(item, &out.Teams[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Teams[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameConfigurationFromGameConfigurationGORM converts a GameConfigurationGORM back to models.GameConfiguration.
// The optional decorator function allows custom field transformations.
func GameConfigurationFromGameConfigurationGORM(
	dest *models.GameConfiguration,
	src *GameConfigurationGORM,
	decorator func(dest *models.GameConfiguration, src *GameConfigurationGORM) error,
) (out *models.GameConfiguration, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameConfiguration{}
	}

	// Initialize struct with inline values
	*dest = models.GameConfiguration{}
	out = dest

	out.IncomeConfigs, err = IncomeConfigFromIncomeConfigGORM(nil, &src.IncomeConfigs, nil)
	if err != nil {
		return nil, fmt.Errorf("converting IncomeConfigs: %w", err)
	}
	out.Settings, err = GameSettingsFromGameSettingsGORM(nil, &src.Settings, nil)
	if err != nil {
		return nil, fmt.Errorf("converting Settings: %w", err)
	}

	if src.Players != nil {
		out.Players = make([]*models.GamePlayer, len(src.Players))
		for i, item := range src.Players {
			out.Players[i], err = GamePlayerFromGamePlayerGORM(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Players[%d]: %w", i, err)
			}
		}
	}
	if src.Teams != nil {
		out.Teams = make([]*models.GameTeam, len(src.Teams))
		for i, item := range src.Teams {
			out.Teams[i], err = GameTeamFromGameTeamGORM(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Teams[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// IncomeConfigToIncomeConfigGORM converts a models.IncomeConfig to IncomeConfigGORM.
// The optional decorator function allows custom field transformations.
func IncomeConfigToIncomeConfigGORM(
	src *models.IncomeConfig,
	dest *IncomeConfigGORM,
	decorator func(*models.IncomeConfig, *IncomeConfigGORM) error,
) (out *IncomeConfigGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &IncomeConfigGORM{}
	}

	// Initialize struct with inline values
	*dest = IncomeConfigGORM{
		StartingCoins:     src.StartingCoins,
		GameIncome:        src.GameIncome,
		LandbaseIncome:    src.LandbaseIncome,
		NavalbaseIncome:   src.NavalbaseIncome,
		AirportbaseIncome: src.AirportbaseIncome,
		MissilesiloIncome: src.MissilesiloIncome,
		MinesIncome:       src.MinesIncome,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// IncomeConfigFromIncomeConfigGORM converts a IncomeConfigGORM back to models.IncomeConfig.
// The optional decorator function allows custom field transformations.
func IncomeConfigFromIncomeConfigGORM(
	dest *models.IncomeConfig,
	src *IncomeConfigGORM,
	decorator func(dest *models.IncomeConfig, src *IncomeConfigGORM) error,
) (out *models.IncomeConfig, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.IncomeConfig{}
	}

	// Initialize struct with inline values
	*dest = models.IncomeConfig{
		StartingCoins:     src.StartingCoins,
		GameIncome:        src.GameIncome,
		LandbaseIncome:    src.LandbaseIncome,
		NavalbaseIncome:   src.NavalbaseIncome,
		AirportbaseIncome: src.AirportbaseIncome,
		MissilesiloIncome: src.MissilesiloIncome,
		MinesIncome:       src.MinesIncome,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GamePlayerToGamePlayerGORM converts a models.GamePlayer to GamePlayerGORM.
// The optional decorator function allows custom field transformations.
func GamePlayerToGamePlayerGORM(
	src *models.GamePlayer,
	dest *GamePlayerGORM,
	decorator func(*models.GamePlayer, *GamePlayerGORM) error,
) (out *GamePlayerGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GamePlayerGORM{}
	}

	// Initialize struct with inline values
	*dest = GamePlayerGORM{
		PlayerId:      src.PlayerId,
		PlayerType:    src.PlayerType,
		Color:         src.Color,
		TeamId:        src.TeamId,
		Name:          src.Name,
		IsActive:      src.IsActive,
		StartingCoins: src.StartingCoins,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GamePlayerFromGamePlayerGORM converts a GamePlayerGORM back to models.GamePlayer.
// The optional decorator function allows custom field transformations.
func GamePlayerFromGamePlayerGORM(
	dest *models.GamePlayer,
	src *GamePlayerGORM,
	decorator func(dest *models.GamePlayer, src *GamePlayerGORM) error,
) (out *models.GamePlayer, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GamePlayer{}
	}

	// Initialize struct with inline values
	*dest = models.GamePlayer{
		PlayerId:      src.PlayerId,
		PlayerType:    src.PlayerType,
		Color:         src.Color,
		TeamId:        src.TeamId,
		Name:          src.Name,
		IsActive:      src.IsActive,
		StartingCoins: src.StartingCoins,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameTeamToGameTeamGORM converts a models.GameTeam to GameTeamGORM.
// The optional decorator function allows custom field transformations.
func GameTeamToGameTeamGORM(
	src *models.GameTeam,
	dest *GameTeamGORM,
	decorator func(*models.GameTeam, *GameTeamGORM) error,
) (out *GameTeamGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameTeamGORM{}
	}

	// Initialize struct with inline values
	*dest = GameTeamGORM{
		TeamId:   src.TeamId,
		Name:     src.Name,
		Color:    src.Color,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameTeamFromGameTeamGORM converts a GameTeamGORM back to models.GameTeam.
// The optional decorator function allows custom field transformations.
func GameTeamFromGameTeamGORM(
	dest *models.GameTeam,
	src *GameTeamGORM,
	decorator func(dest *models.GameTeam, src *GameTeamGORM) error,
) (out *models.GameTeam, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameTeam{}
	}

	// Initialize struct with inline values
	*dest = models.GameTeam{
		TeamId:   src.TeamId,
		Name:     src.Name,
		Color:    src.Color,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameSettingsToGameSettingsGORM converts a models.GameSettings to GameSettingsGORM.
// The optional decorator function allows custom field transformations.
func GameSettingsToGameSettingsGORM(
	src *models.GameSettings,
	dest *GameSettingsGORM,
	decorator func(*models.GameSettings, *GameSettingsGORM) error,
) (out *GameSettingsGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameSettingsGORM{}
	}

	// Initialize struct with inline values
	*dest = GameSettingsGORM{
		AllowedUnits:  src.AllowedUnits,
		TurnTimeLimit: src.TurnTimeLimit,
		TeamMode:      src.TeamMode,
		MaxTurns:      src.MaxTurns,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameSettingsFromGameSettingsGORM converts a GameSettingsGORM back to models.GameSettings.
// The optional decorator function allows custom field transformations.
func GameSettingsFromGameSettingsGORM(
	dest *models.GameSettings,
	src *GameSettingsGORM,
	decorator func(dest *models.GameSettings, src *GameSettingsGORM) error,
) (out *models.GameSettings, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameSettings{}
	}

	// Initialize struct with inline values
	*dest = models.GameSettings{
		AllowedUnits:  src.AllowedUnits,
		TurnTimeLimit: src.TurnTimeLimit,
		TeamMode:      src.TeamMode,
		MaxTurns:      src.MaxTurns,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// PlayerStateToPlayerStateGORM converts a models.PlayerState to PlayerStateGORM.
// The optional decorator function allows custom field transformations.
func PlayerStateToPlayerStateGORM(
	src *models.PlayerState,
	dest *PlayerStateGORM,
	decorator func(*models.PlayerState, *PlayerStateGORM) error,
) (out *PlayerStateGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &PlayerStateGORM{}
	}

	// Initialize struct with inline values
	*dest = PlayerStateGORM{
		Coins:    src.Coins,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// PlayerStateFromPlayerStateGORM converts a PlayerStateGORM back to models.PlayerState.
// The optional decorator function allows custom field transformations.
func PlayerStateFromPlayerStateGORM(
	dest *models.PlayerState,
	src *PlayerStateGORM,
	decorator func(dest *models.PlayerState, src *PlayerStateGORM) error,
) (out *models.PlayerState, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.PlayerState{}
	}

	// Initialize struct with inline values
	*dest = models.PlayerState{
		Coins:    src.Coins,
		IsActive: src.IsActive,
	}
	out = dest

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// WorldDataToGameWorldDataGORM converts a models.WorldData to GameWorldDataGORM.
// The optional decorator function allows custom field transformations.
func WorldDataToGameWorldDataGORM(
	src *models.WorldData,
	dest *GameWorldDataGORM,
	decorator func(*models.WorldData, *GameWorldDataGORM) error,
) (out *GameWorldDataGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameWorldDataGORM{}
	}

	// Initialize struct with inline values
	*dest = GameWorldDataGORM{
		ContentHash: src.ContentHash,
		Version:     src.Version,
	}
	out = dest

	if src.ScreenshotIndexInfo != nil {
		_, err = IndexInfoToIndexInfoGORM(src.ScreenshotIndexInfo, &out.ScreenshotIndexInfo, nil)
		if err != nil {
			return nil, fmt.Errorf("converting ScreenshotIndexInfo: %w", err)
		}
	}

	if src.TilesMap != nil {
		out.TilesMap = make(map[string]TileGORM, len(src.TilesMap))
		for key, value := range src.TilesMap {
			var converted TileGORM
			_, err = TileToTileGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting TilesMap[%v]: %w", key, err)
			}
			out.TilesMap[key] = converted
		}
	}
	if src.UnitsMap != nil {
		out.UnitsMap = make(map[string]UnitGORM, len(src.UnitsMap))
		for key, value := range src.UnitsMap {
			var converted UnitGORM
			_, err = UnitToUnitGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting UnitsMap[%v]: %w", key, err)
			}
			out.UnitsMap[key] = converted
		}
	}
	if src.Crossings != nil {
		out.Crossings = make(map[string]CrossingGORM, len(src.Crossings))
		for key, value := range src.Crossings {
			var converted CrossingGORM
			_, err = CrossingToCrossingGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Crossings[%v]: %w", key, err)
			}
			out.Crossings[key] = converted
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// WorldDataFromGameWorldDataGORM converts a GameWorldDataGORM back to models.WorldData.
// The optional decorator function allows custom field transformations.
func WorldDataFromGameWorldDataGORM(
	dest *models.WorldData,
	src *GameWorldDataGORM,
	decorator func(dest *models.WorldData, src *GameWorldDataGORM) error,
) (out *models.WorldData, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.WorldData{}
	}

	// Initialize struct with inline values
	*dest = models.WorldData{
		ContentHash: src.ContentHash,
		Version:     src.Version,
	}
	out = dest

	out.ScreenshotIndexInfo, err = IndexInfoFromIndexInfoGORM(nil, &src.ScreenshotIndexInfo, nil)
	if err != nil {
		return nil, fmt.Errorf("converting ScreenshotIndexInfo: %w", err)
	}

	if src.TilesMap != nil {
		out.TilesMap = make(map[string]*models.Tile, len(src.TilesMap))
		for key, value := range src.TilesMap {
			out.TilesMap[key], err = TileFromTileGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting TilesMap[%v]: %w", key, err)
			}
		}
	}
	if src.UnitsMap != nil {
		out.UnitsMap = make(map[string]*models.Unit, len(src.UnitsMap))
		for key, value := range src.UnitsMap {
			out.UnitsMap[key], err = UnitFromUnitGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting UnitsMap[%v]: %w", key, err)
			}
		}
	}
	if src.Crossings != nil {
		out.Crossings = make(map[string]*models.Crossing, len(src.Crossings))
		for key, value := range src.Crossings {
			out.Crossings[key], err = CrossingFromCrossingGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Crossings[%v]: %w", key, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameStateToGameStateGORM converts a models.GameState to GameStateGORM.
// The optional decorator function allows custom field transformations.
func GameStateToGameStateGORM(
	src *models.GameState,
	dest *GameStateGORM,
	decorator func(*models.GameState, *GameStateGORM) error,
) (out *GameStateGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameStateGORM{}
	}

	// Initialize struct with inline values
	*dest = GameStateGORM{
		GameId:             src.GameId,
		TurnCounter:        src.TurnCounter,
		CurrentPlayer:      src.CurrentPlayer,
		StateHash:          src.StateHash,
		Version:            src.Version,
		Status:             src.Status,
		Finished:           src.Finished,
		WinningPlayer:      src.WinningPlayer,
		WinningTeam:        src.WinningTeam,
		CurrentGroupNumber: src.CurrentGroupNumber,
	}
	out = dest

	if src.UpdatedAt != nil {
		out.UpdatedAt = converters.TimestampToTime(src.UpdatedAt)
	}

	if src.WorldData != nil {
		_, err = WorldDataToGameWorldDataGORM(src.WorldData, &out.WorldData, nil)
		if err != nil {
			return nil, fmt.Errorf("converting WorldData: %w", err)
		}
	}

	if src.PlayerStates != nil {
		out.PlayerStates = make(map[int32]PlayerStateGORM, len(src.PlayerStates))
		for key, value := range src.PlayerStates {
			var converted PlayerStateGORM
			_, err = PlayerStateToPlayerStateGORM(value, &converted, nil)
			if err != nil {
				return nil, fmt.Errorf("converting PlayerStates[%v]: %w", key, err)
			}
			out.PlayerStates[key] = converted
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameStateFromGameStateGORM converts a GameStateGORM back to models.GameState.
// The optional decorator function allows custom field transformations.
func GameStateFromGameStateGORM(
	dest *models.GameState,
	src *GameStateGORM,
	decorator func(dest *models.GameState, src *GameStateGORM) error,
) (out *models.GameState, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameState{}
	}

	// Initialize struct with inline values
	*dest = models.GameState{
		UpdatedAt:          converters.TimeToTimestamp(src.UpdatedAt),
		GameId:             src.GameId,
		TurnCounter:        src.TurnCounter,
		CurrentPlayer:      src.CurrentPlayer,
		StateHash:          src.StateHash,
		Version:            src.Version,
		Status:             src.Status,
		Finished:           src.Finished,
		WinningPlayer:      src.WinningPlayer,
		WinningTeam:        src.WinningTeam,
		CurrentGroupNumber: src.CurrentGroupNumber,
	}
	out = dest

	out.WorldData, err = WorldDataFromGameWorldDataGORM(nil, &src.WorldData, nil)
	if err != nil {
		return nil, fmt.Errorf("converting WorldData: %w", err)
	}

	if src.PlayerStates != nil {
		out.PlayerStates = make(map[int32]*models.PlayerState, len(src.PlayerStates))
		for key, value := range src.PlayerStates {
			out.PlayerStates[key], err = PlayerStateFromPlayerStateGORM(nil, &value, nil)
			if err != nil {
				return nil, fmt.Errorf("converting PlayerStates[%v]: %w", key, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameMoveHistoryToGameMoveHistoryGORM converts a models.GameMoveHistory to GameMoveHistoryGORM.
// The optional decorator function allows custom field transformations.
func GameMoveHistoryToGameMoveHistoryGORM(
	src *models.GameMoveHistory,
	dest *GameMoveHistoryGORM,
	decorator func(*models.GameMoveHistory, *GameMoveHistoryGORM) error,
) (out *GameMoveHistoryGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameMoveHistoryGORM{}
	}

	// Initialize struct with inline values
	*dest = GameMoveHistoryGORM{
		GameId: src.GameId,
	}
	out = dest

	if src.Groups != nil {
		out.Groups = make([]GameMoveGroupGORM, len(src.Groups))
		for i, item := range src.Groups {
			_, err = GameMoveGroupToGameMoveGroupGORM(item, &out.Groups[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Groups[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameMoveHistoryFromGameMoveHistoryGORM converts a GameMoveHistoryGORM back to models.GameMoveHistory.
// The optional decorator function allows custom field transformations.
func GameMoveHistoryFromGameMoveHistoryGORM(
	dest *models.GameMoveHistory,
	src *GameMoveHistoryGORM,
	decorator func(dest *models.GameMoveHistory, src *GameMoveHistoryGORM) error,
) (out *models.GameMoveHistory, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameMoveHistory{}
	}

	// Initialize struct with inline values
	*dest = models.GameMoveHistory{
		GameId: src.GameId,
	}
	out = dest

	if src.Groups != nil {
		out.Groups = make([]*models.GameMoveGroup, len(src.Groups))
		for i, item := range src.Groups {
			out.Groups[i], err = GameMoveGroupFromGameMoveGroupGORM(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Groups[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameMoveGroupToGameMoveGroupGORM converts a models.GameMoveGroup to GameMoveGroupGORM.
// The optional decorator function allows custom field transformations.
func GameMoveGroupToGameMoveGroupGORM(
	src *models.GameMoveGroup,
	dest *GameMoveGroupGORM,
	decorator func(*models.GameMoveGroup, *GameMoveGroupGORM) error,
) (out *GameMoveGroupGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameMoveGroupGORM{}
	}

	// Initialize struct with inline values
	*dest = GameMoveGroupGORM{
		GroupNumber: src.GroupNumber,
	}
	out = dest

	if src.StartedAt != nil {
		out.StartedAt = converters.TimestampToTime(src.StartedAt)
	}

	if src.EndedAt != nil {
		out.EndedAt = converters.TimestampToTime(src.EndedAt)
	}

	if src.Moves != nil {
		out.Moves = make([]GameMoveGORM, len(src.Moves))
		for i, item := range src.Moves {
			_, err = GameMoveToGameMoveGORM(item, &out.Moves[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Moves[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameMoveGroupFromGameMoveGroupGORM converts a GameMoveGroupGORM back to models.GameMoveGroup.
// The optional decorator function allows custom field transformations.
func GameMoveGroupFromGameMoveGroupGORM(
	dest *models.GameMoveGroup,
	src *GameMoveGroupGORM,
	decorator func(dest *models.GameMoveGroup, src *GameMoveGroupGORM) error,
) (out *models.GameMoveGroup, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameMoveGroup{}
	}

	// Initialize struct with inline values
	*dest = models.GameMoveGroup{
		StartedAt:   converters.TimeToTimestamp(src.StartedAt),
		EndedAt:     converters.TimeToTimestamp(src.EndedAt),
		GroupNumber: src.GroupNumber,
	}
	out = dest

	if src.Moves != nil {
		out.Moves = make([]*models.GameMove, len(src.Moves))
		for i, item := range src.Moves {
			out.Moves[i], err = GameMoveFromGameMoveGORM(nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Moves[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}

// GameMoveToGameMoveGORM converts a models.GameMove to GameMoveGORM.
// The optional decorator function allows custom field transformations.
func GameMoveToGameMoveGORM(
	src *models.GameMove,
	dest *GameMoveGORM,
	decorator func(*models.GameMove, *GameMoveGORM) error,
) (out *GameMoveGORM, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &GameMoveGORM{}
	}

	// Initialize struct with inline values
	*dest = GameMoveGORM{
		Player:      src.Player,
		GroupNumber: src.GroupNumber,
		MoveNumber:  src.MoveNumber,
		SequenceNum: src.SequenceNum,
		IsPermanent: src.IsPermanent,
		Description: src.Description,
	}
	out = dest

	if src.Timestamp != nil {
		out.Timestamp = converters.TimestampToTime(src.Timestamp)
	}

	if src.Changes != nil {
		out.Changes = make([][]byte, len(src.Changes))
		for i, item := range src.Changes {
			_, err = converters.MessageToAnyBytesConverter(item, &out.Changes[i], nil)
			if err != nil {
				return nil, fmt.Errorf("converting Changes[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(src, dest); err != nil {
			return nil, err
		}
	}

	return dest, nil
}

// GameMoveFromGameMoveGORM converts a GameMoveGORM back to models.GameMove.
// The optional decorator function allows custom field transformations.
func GameMoveFromGameMoveGORM(
	dest *models.GameMove,
	src *GameMoveGORM,
	decorator func(dest *models.GameMove, src *GameMoveGORM) error,
) (out *models.GameMove, err error) {
	if src == nil {
		return nil, nil
	}
	if dest == nil {
		dest = &models.GameMove{}
	}

	// Initialize struct with inline values
	*dest = models.GameMove{
		Player:      src.Player,
		GroupNumber: src.GroupNumber,
		MoveNumber:  src.MoveNumber,
		Timestamp:   converters.TimeToTimestamp(src.Timestamp),
		SequenceNum: src.SequenceNum,
		IsPermanent: src.IsPermanent,
		Description: src.Description,
	}
	out = dest

	if src.Changes != nil {
		out.Changes = make([]*models.WorldChange, len(src.Changes))
		for i, item := range src.Changes {
			out.Changes[i], err = converters.AnyBytesToMessageConverter[*models.WorldChange](nil, &item, nil)
			if err != nil {
				return nil, fmt.Errorf("converting Changes[%d]: %w", i, err)
			}
		}
	}

	// Apply decorator if provided
	if decorator != nil {
		if err := decorator(dest, src); err != nil {
			return nil, err
		}
	}

	return out, nil
}
