{
  "swagger": "2.0",
  "info": {
    "title": "lilbattle/v1/models/indexer.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "FileStoreService"
    },
    {
      "name": "GamesService"
    },
    {
      "name": "GameViewerPage"
    },
    {
      "name": "IndexerService"
    },
    {
      "name": "SingletonInitializerService"
    },
    {
      "name": "GameViewPresenter"
    },
    {
      "name": "GameSyncService"
    },
    {
      "name": "WorldsService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/files": {
      "get": {
        "summary": "*\nLists files in a directory",
        "operationId": "FileStoreService_ListFiles",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListFilesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "path",
            "description": "Directory path to list files from (relative to base path)",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.pageKey",
            "description": "*\nInstead of an offset an abstract  \"page\" key is provided that offers\nan opaque \"pointer\" into some offset in a result set.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.pageOffset",
            "description": "*\nIf a pagekey is not supported we can also support a direct integer offset\nfor cases where it makes sense.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.pageSize",
            "description": "*\nNumber of results to return.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "includeSignedUrls",
            "description": "If true, populate signed_urls in each File response",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "FileStoreService"
        ]
      }
    },
    "/v1/files/{file.path}": {
      "post": {
        "summary": "*\nCreate a LRO for indexing records",
        "operationId": "FileStoreService_PutFile",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PutFileResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "file.path",
            "description": "Unique path of the file",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "object",
                  "properties": {
                    "contentType": {
                      "type": "string",
                      "title": "Type of file"
                    },
                    "fileSize": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "isPublic": {
                      "type": "boolean",
                      "title": "Public visibility or not"
                    },
                    "createdAt": {
                      "type": "string",
                      "format": "date-time",
                      "title": "When the last indexing was queued"
                    },
                    "updatedAt": {
                      "type": "string",
                      "format": "date-time",
                      "title": "when the last time the file was updated"
                    },
                    "downloadUrl": {
                      "type": "string",
                      "title": "The download/get URL for this file (public URL or default signed URL)"
                    },
                    "signedUrls": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      },
                      "title": "Signed URLs with different expiries (e.g., \"15m\", \"1h\", \"24h\")\nOnly populated when requested"
                    }
                  }
                },
                "content": {
                  "type": "string",
                  "format": "byte"
                }
              }
            }
          }
        ],
        "tags": [
          "FileStoreService"
        ]
      }
    },
    "/v1/files/{path}": {
      "get": {
        "summary": "*\nGets the metadata about a file",
        "operationId": "FileStoreService_GetFile",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetFileResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "path",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          },
          {
            "name": "includeSignedUrls",
            "description": "If true, populate signed_urls in the File response",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "FileStoreService"
        ]
      },
      "delete": {
        "summary": "*\nDeletes a file",
        "operationId": "FileStoreService_DeleteFile",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteFileResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "path",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          }
        ],
        "tags": [
          "FileStoreService"
        ]
      }
    },
    "/v1/games": {
      "get": {
        "summary": "ListGames returns all available games",
        "operationId": "GamesService_ListGames",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListGamesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.pageKey",
            "description": "*\nInstead of an offset an abstract  \"page\" key is provided that offers\nan opaque \"pointer\" into some offset in a result set.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.pageOffset",
            "description": "*\nIf a pagekey is not supported we can also support a direct integer offset\nfor cases where it makes sense.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.pageSize",
            "description": "*\nNumber of results to return.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerId",
            "description": "May be filter by owner id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "GamesService"
        ]
      },
      "post": {
        "summary": "*\nCreate a new game",
        "operationId": "GamesService_CreateGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateGameRequest"
            }
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/simulate_attack": {
      "post": {
        "summary": "*\nSimulates combat between two units to generate damage distributions\nThis is a stateless utility method that doesn't require game state",
        "operationId": "GamesService_SimulateAttack",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SimulateAttackResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1SimulateAttackRequest"
            }
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/simulate_fix": {
      "post": {
        "summary": "*\nSimulates fix (repair) action to generate health restoration distributions\nThis is a stateless utility method that doesn't require game state",
        "operationId": "GamesService_SimulateFix",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SimulateFixResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1SimulateFixRequest"
            }
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/{gameId}": {
      "patch": {
        "summary": "GetGame returns a specific game with metadata",
        "operationId": "GamesService_UpdateGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "description": "Game id to modify",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "newGame": {
                  "$ref": "#/definitions/v1Game",
                  "title": "*\nGame being updated"
                },
                "newState": {
                  "$ref": "#/definitions/v1GameState",
                  "title": "New world state to save"
                },
                "newHistory": {
                  "$ref": "#/definitions/v1GameMoveHistory",
                  "title": "History to save"
                },
                "updateMask": {
                  "type": "string",
                  "description": "*\nMask of fields being updated in this Game to make partial changes."
                }
              },
              "title": "UpdateGameRequest"
            }
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/{gameId}/moves": {
      "get": {
        "summary": "List the moves for a game",
        "operationId": "GamesService_ListMoves",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListMovesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "description": "*\nGame ID to add moves to",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fromGroup",
            "description": "Gets moves \u003e= from_group",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "toGroup",
            "description": "Gets moves \u003c= to_group",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "GamesService"
        ]
      },
      "post": {
        "operationId": "GamesService_ProcessMoves",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ProcessMovesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "description": "*\nGame ID to add moves to",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "moves": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "$ref": "#/definitions/v1GameMove"
                  },
                  "title": "*\nList of moves to add"
                },
                "expectedResponse": {
                  "$ref": "#/definitions/v1ProcessMovesResponse",
                  "description": "*\nThe player can submit a list of \"Expected\" changes when in local-first mode\nIf this is list provided the server will validate it - either via the coordinator\nor by itself.  If it is not provided then the server will validate it and return\nthe changes."
                },
                "dryRun": {
                  "type": "boolean",
                  "title": "Whether to only perform a dryrun and return results instead of comitting it"
                }
              },
              "description": "*\nRequest to add moves to a game\nThe model is that a game in each \"tick\" can handle multiple moves (by possibly various players).\nIt is upto the move manager/processor in the game to ensure the \"transaction\" of moves is handled\natomically.\n\nFor example we may have 3 moves where first two units are moved to a common location\nand then they attack another unit.  Here If we treat it as a single unit attacking it\nwill have different outcomes than a \"combined\" attack."
            }
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/{gameId}/options/{pos.label}": {
      "get": {
        "operationId": "GamesService_GetOptionsAt2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetOptionsAtResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pos.label",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pos.q",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pos.r",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/{gameId}/options/{pos.q}/{pos.r}": {
      "get": {
        "operationId": "GamesService_GetOptionsAt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetOptionsAtResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pos.q",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pos.r",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pos.label",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/{gameId}/state": {
      "get": {
        "summary": "Gets the latest game state",
        "operationId": "GamesService_GetGameState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetGameStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "description": "*\nGame ID to add moves to",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games/{id}": {
      "get": {
        "summary": "GetGame returns a specific game with metadata",
        "operationId": "GamesService_GetGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Optional, defaults to default_version",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "GamesService"
        ]
      },
      "delete": {
        "summary": "*\nDelete a particular game",
        "operationId": "GamesService_DeleteGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "*\nID of the game to be deleted.",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/games:batchGet": {
      "get": {
        "summary": "*\nBatch get multiple games by ID",
        "operationId": "GamesService_GetGames",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetGamesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "ids",
            "description": "*\nIDs of the game to be fetched",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "GamesService"
        ]
      }
    },
    "/v1/indexes/{entityType}": {
      "get": {
        "summary": "*\nList index entity states by filtering",
        "operationId": "IndexerService_ListIndexStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListIndexStatesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "entityType",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "updatedBefore",
            "description": "Get records indexed \"before\" this time",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "updatedAfter",
            "description": "Get records updated \"after\" this time",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "indexTypes",
            "description": "Filter by index types or get all",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "orderBy",
            "description": "\"id\" or \"indexed_at\"",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "count",
            "description": "limit to max items",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "IndexerService"
        ]
      }
    },
    "/v1/indexes/{entityType}/{entityId}": {
      "get": {
        "summary": "*\nGet the index states for a particular entity",
        "operationId": "IndexerService_GetIndexStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetIndexStatesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "entityType",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "entityId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "indexTypes",
            "description": "Optional - can be used to get \"all\" indexer states or just once specified here",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "IndexerService"
        ]
      },
      "delete": {
        "operationId": "IndexerService_DeleteIndexStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteIndexStatesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "entityType",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "entityId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "indexTypes",
            "description": "Optional - can be used to get \"all\" indexer states or just once specified here",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "IndexerService"
        ]
      }
    },
    "/v1/indexes/{indexState.entityType}/{indexState.entityId}/{indexState.indexType}": {
      "post": {
        "summary": "*\nCreate a LRO for indexing records",
        "operationId": "IndexerService_EnsureIndexState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1EnsureIndexStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexState.entityType",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "indexState.entityId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "indexState.indexType",
            "description": "eg \"screenshots\", \"keywords\" etc\nEntityType + EntityId + IndexType should be  unique",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "indexState": {
                  "type": "object",
                  "properties": {
                    "createdAt": {
                      "type": "string",
                      "format": "date-time",
                      "title": "When the last indexing was queued"
                    },
                    "updatedAt": {
                      "type": "string",
                      "format": "date-time",
                      "title": "when the last time the entity was recorded for an update (means it is eligible for a re-indexing)"
                    },
                    "indexedAt": {
                      "type": "string",
                      "format": "date-time",
                      "title": "When did the last indexing finish"
                    },
                    "needsIndexing": {
                      "type": "boolean",
                      "title": "Whether indexing is needed or not"
                    },
                    "status": {
                      "$ref": "#/definitions/v1IndexStatus",
                      "title": "\"queued/pending\", \"indexing\", \"completed\", \"failed\""
                    },
                    "lastError": {
                      "type": "string",
                      "title": "If there was an error in the last indexing"
                    },
                    "idempotencyKey": {
                      "type": "string",
                      "title": "A way to ignore multiple requests if they are updates but\nnothing has changed"
                    },
                    "retryCount": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "updateMask": {
                  "type": "string",
                  "description": "*\nMask of fields being updated in this Game to make partial changes."
                }
              }
            }
          }
        ],
        "tags": [
          "IndexerService"
        ]
      }
    },
    "/v1/presenters/gameview/action:applyRemoteChanges/{game_id}": {
      "post": {
        "summary": "*\nApply changes from remote players (received via SyncService subscription).\nThis updates local game state and triggers UI updates for the received WorldChanges.\nUsed by viewers to apply moves made by other players.",
        "operationId": "GameViewPresenter_ApplyRemoteChanges",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ApplyRemoteChangesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "moves": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "$ref": "#/definitions/v1GameMove"
                  },
                  "title": "The moves containing WorldChanges to apply"
                }
              },
              "title": "Request to apply changes from remote players\nCalled when SyncService streams moves made by other players"
            }
          }
        ],
        "tags": [
          "GameViewPresenter"
        ]
      }
    },
    "/v1/presenters/gameview/action:clicked:buildOption/{game_id}": {
      "post": {
        "summary": "*\nCalled when a build option is clicked in the BuildOptionsModal",
        "operationId": "GameViewPresenter_BuildOptionClicked",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1BuildOptionClickedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "pos": {
                  "$ref": "#/definitions/v1Position"
                },
                "unitType": {
                  "type": "integer",
                  "format": "int32",
                  "title": "Type of unit being built (e.g., \"soldier_basic\")"
                }
              },
              "title": "Called when a build option is clicked in BuildOptionsModal"
            }
          }
        ],
        "tags": [
          "GameViewPresenter"
        ]
      }
    },
    "/v1/presenters/gameview/action:clicked:endTurnButton/{game_id}": {
      "post": {
        "summary": "*\nCalled when user clicked the EndTurn button",
        "operationId": "GameViewPresenter_EndTurnButtonClicked",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1EndTurnButtonClickedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "title": "Called when the end turn button was clicked"
            }
          }
        ],
        "tags": [
          "GameViewPresenter"
        ]
      }
    },
    "/v1/presenters/gameview/action:clicked:scene/{game_id}": {
      "post": {
        "summary": "*\nThis is called when the user clicks a tile on the Game Scene\nThe tile can have a unit or just be a plain tile.  It is upto the presenter to\nchange the various view states",
        "operationId": "GameViewPresenter_SceneClicked",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SceneClickedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "pos": {
                  "$ref": "#/definitions/v1Position"
                },
                "layer": {
                  "type": "string"
                }
              },
              "title": "Called when the scene was clicked"
            }
          }
        ],
        "tags": [
          "GameViewPresenter"
        ]
      }
    },
    "/v1/presenters/gameview/action:clicked:turnOption/{game_id}": {
      "post": {
        "summary": "*\nCalled when a particular turn option is clicked in the TurnOptionsPanel\nNote how we have a strong coupling between what the page elements do and which\npresenter elements they call",
        "operationId": "GameViewPresenter_TurnOptionClicked",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TurnOptionClickedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "optionIndex": {
                  "type": "integer",
                  "format": "int32",
                  "title": "Index of the option in the options array"
                },
                "optionType": {
                  "type": "string",
                  "description": "Type of option: \"move\", \"attack\", \"endTurn\", etc."
                },
                "pos": {
                  "$ref": "#/definitions/v1Position"
                }
              },
              "title": "Called when a turn option is clicked in TurnOptionsPanel"
            }
          }
        ],
        "tags": [
          "GameViewPresenter"
        ]
      }
    },
    "/v1/sync/games/{gameId}/broadcast": {
      "post": {
        "summary": "Broadcast sends a GameUpdate to all subscribers of a game.\nCalled internally by GamesService after ProcessMoves succeeds.\nNot intended for direct client use.",
        "operationId": "GameSyncService_Broadcast",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1BroadcastResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "description": "Game ID to broadcast to",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "update": {
                  "$ref": "#/definitions/v1GameUpdate",
                  "title": "The update to broadcast"
                }
              },
              "title": "BroadcastRequest to send a GameUpdate to all subscribers\nCalled internally by GamesService after ProcessMoves succeeds"
            }
          }
        ],
        "tags": [
          "GameSyncService"
        ]
      }
    },
    "/v1/worlds": {
      "get": {
        "summary": "ListWorlds returns all available worlds",
        "operationId": "WorldsService_ListWorlds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorldsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.pageKey",
            "description": "*\nInstead of an offset an abstract  \"page\" key is provided that offers\nan opaque \"pointer\" into some offset in a result set.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.pageOffset",
            "description": "*\nIf a pagekey is not supported we can also support a direct integer offset\nfor cases where it makes sense.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pagination.pageSize",
            "description": "*\nNumber of results to return.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "ownerId",
            "description": "May be filter by owner id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorldsService"
        ]
      },
      "post": {
        "summary": "*\nCreate a new world",
        "operationId": "WorldsService_CreateWorld",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateWorldResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateWorldRequest"
            }
          }
        ],
        "tags": [
          "WorldsService"
        ]
      }
    },
    "/v1/worlds/{id}": {
      "get": {
        "summary": "GetWorld returns a specific world with metadata",
        "operationId": "WorldsService_GetWorld",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorldResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Optional, defaults to default_version",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorldsService"
        ]
      },
      "delete": {
        "summary": "*\nDelete a particular world",
        "operationId": "WorldsService_DeleteWorld",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorldResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "*\nID of the world to be deleted.",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          }
        ],
        "tags": [
          "WorldsService"
        ]
      }
    },
    "/v1/worlds/{world.id}": {
      "patch": {
        "summary": "GetWorld returns a specific world with metadata",
        "operationId": "WorldsService_UpdateWorld",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorldResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "world.id",
            "description": "Unique ID for the world",
            "in": "path",
            "required": true,
            "type": "string",
            "pattern": "[^/]+"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "world": {
                  "type": "object",
                  "properties": {
                    "createdAt": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "updatedAt": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "version": {
                      "type": "string",
                      "format": "int64",
                      "title": "Version for Optimistic concurrent locking"
                    },
                    "creatorId": {
                      "type": "string",
                      "title": "User that created the world"
                    },
                    "name": {
                      "type": "string",
                      "title": "Name if items have names"
                    },
                    "description": {
                      "type": "string",
                      "title": "Description if world has a description"
                    },
                    "tags": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "Some tags"
                    },
                    "imageUrl": {
                      "type": "string",
                      "title": "A possible image url"
                    },
                    "difficulty": {
                      "type": "string",
                      "title": "Difficulty - example attribute"
                    },
                    "previewUrls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "URL to screenshot/preview image (defaults to /worlds/{id}/screenshots/{screenshotName})\nCan be overridden to point to CDN or external hosting"
                    },
                    "defaultGameConfig": {
                      "$ref": "#/definitions/v1GameConfiguration",
                      "title": "Default game configs"
                    },
                    "searchIndexInfo": {
                      "$ref": "#/definitions/v1IndexInfo"
                    }
                  },
                  "title": "*\nWorld being updated"
                },
                "worldData": {
                  "$ref": "#/definitions/v1WorldData"
                },
                "clearWorld": {
                  "type": "boolean"
                },
                "updateMask": {
                  "type": "string",
                  "description": "*\nMask of fields being updated in this World to make partial changes."
                }
              },
              "title": "UpdateWorldRequest"
            }
          }
        ],
        "tags": [
          "WorldsService"
        ]
      }
    },
    "/v1/worlds:batchGet": {
      "get": {
        "summary": "*\nBatch get multiple worlds by ID",
        "operationId": "WorldsService_GetWorlds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorldsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "ids",
            "description": "*\nIDs of the world to be fetched",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "WorldsService"
        ]
      }
    }
  },
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1AllPaths": {
      "type": "object",
      "properties": {
        "sourceQ": {
          "type": "integer",
          "format": "int32",
          "title": "Starting coordinate for all paths"
        },
        "sourceR": {
          "type": "integer",
          "format": "int32"
        },
        "edges": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1PathEdge"
          },
          "title": "Map of edges: key is \"toQ,toR\" for quick parent lookup\nEach edge represents the optimal way to reach 'to' from its parent"
        }
      },
      "title": "Compact representation of all reachable paths from a source"
    },
    "v1ApplyRemoteChangesResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "title": "Whether the changes were successfully applied"
        },
        "error": {
          "type": "string",
          "title": "Error message if application failed (e.g., state desync)"
        },
        "requiresReload": {
          "type": "boolean",
          "title": "If state desync detected, client should reload game"
        }
      },
      "title": "Response after applying remote changes"
    },
    "v1AttackRecord": {
      "type": "object",
      "properties": {
        "q": {
          "type": "integer",
          "format": "int32",
          "title": "Attacker's Q coordinate"
        },
        "r": {
          "type": "integer",
          "format": "int32",
          "title": "Attacker's R coordinate"
        },
        "isRanged": {
          "type": "boolean",
          "title": "Whether attacker is ranged 2+ tiles away"
        },
        "turnNumber": {
          "type": "integer",
          "format": "int32",
          "title": "Which turn this attack occured"
        }
      }
    },
    "v1AttackUnitAction": {
      "type": "object",
      "properties": {
        "attacker": {
          "$ref": "#/definitions/v1Position"
        },
        "defender": {
          "$ref": "#/definitions/v1Position"
        },
        "targetUnitType": {
          "type": "integer",
          "format": "int32",
          "title": "Optional fields for presenting during \"options\" and debugging"
        },
        "targetUnitHealth": {
          "type": "integer",
          "format": "int32"
        },
        "canAttack": {
          "type": "boolean"
        },
        "damageEstimate": {
          "type": "integer",
          "format": "int32",
          "title": "Estimated damage this attack would deal"
        }
      },
      "title": "*\nAttack with one unit against another"
    },
    "v1BroadcastResponse": {
      "type": "object",
      "properties": {
        "subscriberCount": {
          "type": "integer",
          "format": "int32",
          "title": "Number of subscribers that received the update"
        },
        "sequence": {
          "type": "string",
          "format": "int64",
          "title": "The sequence number assigned to this update"
        }
      },
      "title": "BroadcastResponse after broadcasting"
    },
    "v1BuildOptionClickedResponse": {
      "type": "object",
      "title": "Response of a build option click"
    },
    "v1BuildUnitAction": {
      "type": "object",
      "properties": {
        "pos": {
          "$ref": "#/definitions/v1Position"
        },
        "unitType": {
          "type": "integer",
          "format": "int32"
        },
        "cost": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "*\nAn action to build a unit (at a city tile)"
    },
    "v1CaptureBuildingAction": {
      "type": "object",
      "properties": {
        "pos": {
          "$ref": "#/definitions/v1Position"
        },
        "tileType": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "*\nA move where a unit can capture a building"
    },
    "v1CaptureStartedChange": {
      "type": "object",
      "properties": {
        "capturingUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "The unit starting the capture"
        },
        "tileQ": {
          "type": "integer",
          "format": "int32",
          "title": "Tile coordinates"
        },
        "tileR": {
          "type": "integer",
          "format": "int32"
        },
        "tileType": {
          "type": "integer",
          "format": "int32",
          "title": "Tile type"
        },
        "currentOwner": {
          "type": "integer",
          "format": "int32",
          "title": "Current owner (0 for neutral)"
        }
      },
      "title": "*\nA unit started capturing a building (capture not yet complete)"
    },
    "v1ClearHighlightsResponse": {
      "type": "object"
    },
    "v1ClearPathsResponse": {
      "type": "object"
    },
    "v1ClientReadyResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        }
      },
      "title": "Response for ClientReady"
    },
    "v1CoinsChangedChange": {
      "type": "object",
      "properties": {
        "playerId": {
          "type": "integer",
          "format": "int32",
          "title": "Which player's coins changed"
        },
        "previousCoins": {
          "type": "integer",
          "format": "int32",
          "title": "Previous coin balance"
        },
        "newCoins": {
          "type": "integer",
          "format": "int32",
          "title": "New coin balance"
        },
        "reason": {
          "type": "string",
          "description": "Reason for change: \"build\", \"income\", \"repair\", etc."
        }
      },
      "title": "*\nA player's coin balance changed"
    },
    "v1CreateGameRequest": {
      "type": "object",
      "properties": {
        "game": {
          "$ref": "#/definitions/v1Game",
          "title": "*\nGame being updated"
        }
      },
      "title": "*\nGame creation request object"
    },
    "v1CreateGameResponse": {
      "type": "object",
      "properties": {
        "game": {
          "$ref": "#/definitions/v1Game",
          "title": "*\nGame being created"
        },
        "gameState": {
          "$ref": "#/definitions/v1GameState",
          "title": "The starting game state"
        },
        "fieldErrors": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "*\nError specific to a field if there are any errors."
        }
      },
      "description": "*\nResponse of an game creation."
    },
    "v1CreateWorldRequest": {
      "type": "object",
      "properties": {
        "world": {
          "$ref": "#/definitions/v1World",
          "title": "*\nWorld being updated"
        },
        "worldData": {
          "$ref": "#/definitions/v1WorldData"
        }
      },
      "title": "*\nWorld creation request object"
    },
    "v1CreateWorldResponse": {
      "type": "object",
      "properties": {
        "world": {
          "$ref": "#/definitions/v1World",
          "title": "*\nWorld being created"
        },
        "worldData": {
          "$ref": "#/definitions/v1WorldData"
        },
        "fieldErrors": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "*\nError specific to a field if there are any errors."
        }
      },
      "description": "*\nResponse of an world creation."
    },
    "v1Crossing": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1CrossingType"
        },
        "connectsTo": {
          "type": "array",
          "items": {
            "type": "boolean"
          },
          "title": "6 booleans for hex neighbors in order matching AxialNeighborDeltas:\n0: LEFT (-1,0), 1: TOP_LEFT (0,-1), 2: TOP_RIGHT (1,-1),\n3: RIGHT (1,0), 4: BOTTOM_RIGHT (0,1), 5: BOTTOM_LEFT (-1,1)"
        }
      },
      "title": "Crossing with explicit connectivity data\nEach crossing stores which of its 6 hex neighbors it connects to"
    },
    "v1CrossingType": {
      "type": "string",
      "enum": [
        "CROSSING_TYPE_UNSPECIFIED",
        "CROSSING_TYPE_ROAD",
        "CROSSING_TYPE_BRIDGE"
      ],
      "default": "CROSSING_TYPE_UNSPECIFIED",
      "description": "- CROSSING_TYPE_ROAD: Road on land terrain\n - CROSSING_TYPE_BRIDGE: Bridge over water terrain",
      "title": "Crossing types for terrain improvements (roads on land, bridges on water)"
    },
    "v1DeleteFileResponse": {
      "type": "object",
      "properties": {
        "file": {
          "$ref": "#/definitions/v1File"
        }
      }
    },
    "v1DeleteGameResponse": {
      "type": "object",
      "title": "*\nGame deletion response"
    },
    "v1DeleteIndexStatesResponse": {
      "type": "object"
    },
    "v1DeleteWorldResponse": {
      "type": "object",
      "title": "*\nWorld deletion response"
    },
    "v1EndTurnAction": {
      "type": "object",
      "description": "No additional fields needed",
      "title": "*\nEnd current player's turn"
    },
    "v1EndTurnButtonClickedResponse": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string"
        }
      },
      "title": "Response of a turn option click"
    },
    "v1EnsureIndexStateResponse": {
      "type": "object",
      "properties": {
        "indexState": {
          "$ref": "#/definitions/v1IndexState"
        }
      }
    },
    "v1File": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "title": "Unique path of the file"
        },
        "contentType": {
          "type": "string",
          "title": "Type of file"
        },
        "fileSize": {
          "type": "string",
          "format": "uint64"
        },
        "isPublic": {
          "type": "boolean",
          "title": "Public visibility or not"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "title": "When the last indexing was queued"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "title": "when the last time the file was updated"
        },
        "downloadUrl": {
          "type": "string",
          "title": "The download/get URL for this file (public URL or default signed URL)"
        },
        "signedUrls": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Signed URLs with different expiries (e.g., \"15m\", \"1h\", \"24h\")\nOnly populated when requested"
        }
      }
    },
    "v1FixUnitAction": {
      "type": "object",
      "properties": {
        "fixer": {
          "$ref": "#/definitions/v1Position",
          "title": "Position of the unit doing the fixing"
        },
        "target": {
          "$ref": "#/definitions/v1Position",
          "title": "Position of the friendly unit being fixed"
        },
        "fixAmount": {
          "type": "integer",
          "format": "int32",
          "title": "Amount of health to restore (optional, server calculates if not provided)"
        }
      },
      "title": "*\nFix (repair) another friendly unit - used by Medic, Engineer, Stratotanker, Tugboat, Aircraft Carrier\nThe fixer must be adjacent to the target unit"
    },
    "v1Game": {
      "type": "object",
      "properties": {
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "Version number for optimistic locking"
        },
        "id": {
          "type": "string",
          "title": "Unique ID for the game"
        },
        "creatorId": {
          "type": "string",
          "title": "User who started/created the game"
        },
        "worldId": {
          "type": "string",
          "title": "The world this game was created from"
        },
        "name": {
          "type": "string",
          "title": "Name if items have names"
        },
        "description": {
          "type": "string",
          "title": "Description if game has a description"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Some tags"
        },
        "imageUrl": {
          "type": "string",
          "title": "A possible image url"
        },
        "difficulty": {
          "type": "string",
          "title": "Difficulty - example attribute"
        },
        "config": {
          "$ref": "#/definitions/v1GameConfiguration",
          "title": "Game configuration"
        },
        "previewUrls": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "URL to screenshot/preview image (defaults to /games/{id}/screenshots/{screenshotName})\nCan be overridden to point to CDN or external hosting"
        },
        "searchIndexInfo": {
          "$ref": "#/definitions/v1IndexInfo"
        }
      },
      "title": "Describes a game and its metadata"
    },
    "v1GameConfiguration": {
      "type": "object",
      "properties": {
        "players": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GamePlayer"
          },
          "title": "Player configuration"
        },
        "teams": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameTeam"
          },
          "title": "Team configuration"
        },
        "incomeConfigs": {
          "$ref": "#/definitions/v1IncomeConfig",
          "title": "Various kinds of per turn income configs"
        },
        "settings": {
          "$ref": "#/definitions/v1GameSettings",
          "title": "Game settings"
        }
      }
    },
    "v1GameEnded": {
      "type": "object",
      "properties": {
        "winner": {
          "type": "integer",
          "format": "int32",
          "title": "Winning player (0 if draw or N/A)"
        },
        "reason": {
          "type": "string",
          "title": "Reason for game ending"
        }
      },
      "title": "GameEnded indicates the game has concluded"
    },
    "v1GameMove": {
      "type": "object",
      "properties": {
        "player": {
          "type": "integer",
          "format": "int32",
          "title": "The player making the move"
        },
        "groupNumber": {
          "type": "string",
          "format": "int64",
          "title": "Generated by the server"
        },
        "moveNumber": {
          "type": "string",
          "format": "int64",
          "title": "Generated by the server - will be monotonically increasing within the group"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "moveUnit": {
          "$ref": "#/definitions/v1MoveUnitAction"
        },
        "attackUnit": {
          "$ref": "#/definitions/v1AttackUnitAction"
        },
        "endTurn": {
          "$ref": "#/definitions/v1EndTurnAction"
        },
        "buildUnit": {
          "$ref": "#/definitions/v1BuildUnitAction"
        },
        "captureBuilding": {
          "$ref": "#/definitions/v1CaptureBuildingAction"
        },
        "healUnit": {
          "$ref": "#/definitions/v1HealUnitAction"
        },
        "fixUnit": {
          "$ref": "#/definitions/v1FixUnitAction"
        },
        "sequenceNum": {
          "type": "string",
          "format": "int64",
          "title": "A monotonically increasing and unique (within the game) sequence number for the move\nThis is generated by the server"
        },
        "isPermanent": {
          "type": "boolean",
          "title": "Whether the result is permenant and can be undone.\nJust moving a unit for example is not permanent, but attacking a unit\nwould be (ie a player cannot undo it).  This is also determined by the server/validator"
        },
        "changes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorldChange"
          },
          "title": "The corresponding \"result\" for the move.  This can be \"proposed\" or can be evaluated.\nKeeping this colocated with the Move for consistency and simplicity"
        },
        "description": {
          "type": "string",
          "title": "Human redable description for say recording \"commands\" if any"
        }
      },
      "title": "*\nRepresents a single move which can be one of many actions in the game"
    },
    "v1GameMoveGroup": {
      "type": "object",
      "properties": {
        "startedAt": {
          "type": "string",
          "format": "date-time",
          "title": "When the moves happened (or were submitted)"
        },
        "endedAt": {
          "type": "string",
          "format": "date-time"
        },
        "groupNumber": {
          "type": "string",
          "format": "int64",
          "title": "Group number within the game - will be monotonically increasing"
        },
        "moves": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameMove"
          },
          "title": "*\nList of moves to add -"
        }
      },
      "title": "A move group - we can allow X moves in one \"tick\""
    },
    "v1GameMoveHistory": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string",
          "title": "Move history for the game"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameMoveGroup"
          },
          "title": "Each entry in our history is a \"group\" of moves"
        }
      },
      "title": "Holds the game's move history (can be used as a replay log)"
    },
    "v1GameOption": {
      "type": "object",
      "properties": {
        "move": {
          "$ref": "#/definitions/v1MoveUnitAction"
        },
        "attack": {
          "$ref": "#/definitions/v1AttackUnitAction"
        },
        "build": {
          "$ref": "#/definitions/v1BuildUnitAction"
        },
        "capture": {
          "$ref": "#/definitions/v1CaptureBuildingAction"
        },
        "endTurn": {
          "$ref": "#/definitions/v1EndTurnAction"
        },
        "heal": {
          "$ref": "#/definitions/v1HealUnitAction"
        }
      },
      "title": "*\nA single game option available at a position"
    },
    "v1GamePlayer": {
      "type": "object",
      "properties": {
        "playerId": {
          "type": "integer",
          "format": "int32",
          "title": "Player ID (1-based)"
        },
        "userId": {
          "type": "string",
          "title": "ID of the system user that is assigned to this game player.  This is the \"auth\" user"
        },
        "playerType": {
          "type": "string",
          "description": "\"human\", \"ai\", \"open\"",
          "title": "Player type"
        },
        "color": {
          "type": "string",
          "title": "Player color"
        },
        "teamId": {
          "type": "integer",
          "format": "int32",
          "title": "Team ID (0 = no team, 1+ = team number)"
        },
        "name": {
          "type": "string",
          "title": "Nickname for the player in this game"
        },
        "isActive": {
          "type": "boolean",
          "title": "Whether play is still in the game - can this just be inferred?"
        },
        "startingCoins": {
          "type": "integer",
          "format": "int32",
          "title": "How many coins the player started off with"
        }
      }
    },
    "v1GameSettings": {
      "type": "object",
      "properties": {
        "allowedUnits": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          },
          "title": "List of allowed unit type IDs"
        },
        "turnTimeLimit": {
          "type": "integer",
          "format": "int32",
          "title": "Turn time limit in seconds (0 = no limit)"
        },
        "teamMode": {
          "type": "string",
          "description": "\"ffa\" or \"teams\"",
          "title": "Team mode"
        },
        "maxTurns": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of turns (0 = unlimited)"
        }
      }
    },
    "v1GameState": {
      "type": "object",
      "properties": {
        "updatedAt": {
          "type": "string",
          "format": "date-time"
        },
        "gameId": {
          "type": "string",
          "title": "ID of the game whos state is being tracked"
        },
        "turnCounter": {
          "type": "integer",
          "format": "int32"
        },
        "currentPlayer": {
          "type": "integer",
          "format": "int32"
        },
        "worldData": {
          "$ref": "#/definitions/v1WorldData",
          "title": "Current world state"
        },
        "stateHash": {
          "type": "string",
          "title": "Current state hash for validation"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "Version number for optimistic locking"
        },
        "status": {
          "$ref": "#/definitions/v1GameStatus"
        },
        "finished": {
          "type": "boolean",
          "title": "Only set after a win has been possible"
        },
        "winningPlayer": {
          "type": "integer",
          "format": "int32"
        },
        "winningTeam": {
          "type": "integer",
          "format": "int32"
        },
        "currentGroupNumber": {
          "type": "string",
          "format": "int64"
        },
        "playerStates": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1PlayerState"
          },
          "title": "Per-player runtime state, keyed by player_id (1-based)\nThis holds mutable player state like coins that changes during gameplay"
        }
      },
      "title": "Holds the game's Active/Current state (eg world state)"
    },
    "v1GameStatus": {
      "type": "string",
      "enum": [
        "GAME_STATUS_UNSPECIFIED",
        "GAME_STATUS_PLAYING",
        "GAME_STATUS_PAUSED",
        "GAME_STATUS_ENDED"
      ],
      "default": "GAME_STATUS_UNSPECIFIED",
      "title": "/////// Game related models"
    },
    "v1GameTeam": {
      "type": "object",
      "properties": {
        "teamId": {
          "type": "integer",
          "format": "int32",
          "title": "ID of the team within the game (unique to the game)"
        },
        "name": {
          "type": "string",
          "title": "Name of the team - in a game"
        },
        "color": {
          "type": "string",
          "title": "Just a color for this team"
        },
        "isActive": {
          "type": "boolean",
          "title": "Whether team has active players - can also be inferred"
        }
      }
    },
    "v1GameUpdate": {
      "type": "object",
      "properties": {
        "sequence": {
          "type": "string",
          "format": "int64",
          "description": "Monotonically increasing sequence number for ordering and reconnection.\nClients should track this to resume from correct position."
        },
        "movesPublished": {
          "$ref": "#/definitions/v1MovesPublished",
          "title": "Moves were published by a player (contains WorldChanges)"
        },
        "playerJoined": {
          "$ref": "#/definitions/v1PlayerJoined",
          "title": "A player connected to the game"
        },
        "playerLeft": {
          "$ref": "#/definitions/v1PlayerLeft",
          "title": "A player disconnected from the game"
        },
        "gameEnded": {
          "$ref": "#/definitions/v1GameEnded",
          "title": "Game has ended (victory, surrender, etc.)"
        },
        "initialState": {
          "$ref": "#/definitions/v1SubscribeResponse",
          "title": "Initial state sent at subscription start"
        }
      },
      "title": "GameUpdate is streamed to subscribers when game state changes"
    },
    "v1GetFileResponse": {
      "type": "object",
      "properties": {
        "file": {
          "$ref": "#/definitions/v1File"
        }
      }
    },
    "v1GetGameResponse": {
      "type": "object",
      "properties": {
        "game": {
          "$ref": "#/definitions/v1Game"
        },
        "state": {
          "$ref": "#/definitions/v1GameState"
        },
        "history": {
          "$ref": "#/definitions/v1GameMoveHistory"
        }
      }
    },
    "v1GetGameStateResponse": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1GameState"
        }
      },
      "title": "*\nResponse holding latest game state"
    },
    "v1GetGamesResponse": {
      "type": "object",
      "properties": {
        "games": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Game"
          }
        }
      },
      "title": "*\nGame batch-get response"
    },
    "v1GetIndexStatesResponse": {
      "type": "object",
      "properties": {
        "states": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexState"
          }
        }
      }
    },
    "v1GetOptionsAtResponse": {
      "type": "object",
      "properties": {
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameOption"
          }
        },
        "currentPlayer": {
          "type": "integer",
          "format": "int32",
          "title": "debug: current player in game"
        },
        "gameInitialized": {
          "type": "boolean",
          "title": "debug: whether game is properly initialized"
        },
        "allPaths": {
          "$ref": "#/definitions/v1AllPaths",
          "title": "A Path from source to dest along with cost on each tile for tracking"
        }
      },
      "title": "*\nResponse with all available options at a position"
    },
    "v1GetWorldResponse": {
      "type": "object",
      "properties": {
        "world": {
          "$ref": "#/definitions/v1World"
        },
        "worldData": {
          "$ref": "#/definitions/v1WorldData"
        }
      }
    },
    "v1GetWorldsResponse": {
      "type": "object",
      "properties": {
        "worlds": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1World"
          }
        }
      },
      "title": "*\nWorld batch-get response"
    },
    "v1HealUnitAction": {
      "type": "object",
      "properties": {
        "pos": {
          "$ref": "#/definitions/v1Position",
          "title": "Position of unit to heal"
        },
        "healAmount": {
          "type": "integer",
          "format": "int32",
          "title": "Amount of health to restore"
        }
      },
      "title": "*\nHeal a unit - player manually chooses to heal instead of attacking/moving\nAuto-healing at turn start is handled separately in TopUpUnitIfNeeded"
    },
    "v1HexCoord": {
      "type": "object",
      "properties": {
        "q": {
          "type": "integer",
          "format": "int32"
        },
        "r": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "Hex coordinate for paths"
    },
    "v1HighlightSpec": {
      "type": "object",
      "properties": {
        "q": {
          "type": "integer",
          "format": "int32"
        },
        "r": {
          "type": "integer",
          "format": "int32"
        },
        "type": {
          "type": "string",
          "title": "\"selection\", \"movement\", \"attack\", \"build\", \"exhausted\", \"capturing\""
        },
        "move": {
          "$ref": "#/definitions/v1MoveUnitAction"
        },
        "attack": {
          "$ref": "#/definitions/v1AttackUnitAction"
        },
        "build": {
          "$ref": "#/definitions/v1BuildUnitAction"
        },
        "capture": {
          "$ref": "#/definitions/v1CaptureBuildingAction"
        },
        "player": {
          "type": "integer",
          "format": "int32",
          "title": "Player ID for player-colored highlights (e.g., capturing flag)"
        }
      },
      "title": "Specification for a single highlight"
    },
    "v1IncomeConfig": {
      "type": "object",
      "properties": {
        "startingCoins": {
          "type": "integer",
          "format": "int32",
          "title": "How much starting coins to give each player at the start of the agme"
        },
        "gameIncome": {
          "type": "integer",
          "format": "int32",
          "title": "Income each player just for being in the game each turn"
        },
        "landbaseIncome": {
          "type": "integer",
          "format": "int32",
          "title": "Income from each landbase per turn"
        },
        "navalbaseIncome": {
          "type": "integer",
          "format": "int32",
          "title": "Income from each navalbase per turn"
        },
        "airportbaseIncome": {
          "type": "integer",
          "format": "int32",
          "title": "Income from each airport base per turn"
        },
        "missilesiloIncome": {
          "type": "integer",
          "format": "int32",
          "title": "Income from each missile silo per turn"
        },
        "minesIncome": {
          "type": "integer",
          "format": "int32",
          "title": "Income from each mine per turn"
        }
      }
    },
    "v1IndexInfo": {
      "type": "object",
      "properties": {
        "lastUpdatedAt": {
          "type": "string",
          "format": "date-time",
          "title": "We maintain an IndexInfo for each type of \"indexing\" operation needed\nFor example one update may change the keywords (so we need to update indexes for search)\nAnother might update the \"units\" so we may need a new screenshot\nEach one's updates - updated and indexed timestamps separately so they can be tracked sepately"
        },
        "lastIndexedAt": {
          "type": "string",
          "format": "date-time"
        },
        "needsIndexing": {
          "type": "boolean"
        }
      }
    },
    "v1IndexState": {
      "type": "object",
      "properties": {
        "entityType": {
          "type": "string"
        },
        "entityId": {
          "type": "string"
        },
        "indexType": {
          "type": "string",
          "title": "eg \"screenshots\", \"keywords\" etc\nEntityType + EntityId + IndexType should be  unique"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "title": "When the last indexing was queued"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "title": "when the last time the entity was recorded for an update (means it is eligible for a re-indexing)"
        },
        "indexedAt": {
          "type": "string",
          "format": "date-time",
          "title": "When did the last indexing finish"
        },
        "needsIndexing": {
          "type": "boolean",
          "title": "Whether indexing is needed or not"
        },
        "status": {
          "$ref": "#/definitions/v1IndexStatus",
          "title": "\"queued/pending\", \"indexing\", \"completed\", \"failed\""
        },
        "lastError": {
          "type": "string",
          "title": "If there was an error in the last indexing"
        },
        "idempotencyKey": {
          "type": "string",
          "title": "A way to ignore multiple requests if they are updates but\nnothing has changed"
        },
        "retryCount": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1IndexStatus": {
      "type": "string",
      "enum": [
        "INDEX_STATUS_UNSPECIFIED",
        "INDEX_STATUS_PENDING",
        "INDEX_STATUS_INDEXING",
        "INDEX_STATUS_COMPLETED",
        "INDEX_STATUS_FAILED"
      ],
      "default": "INDEX_STATUS_UNSPECIFIED"
    },
    "v1InitializeGameResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        },
        "error": {
          "type": "string"
        },
        "currentPlayer": {
          "type": "integer",
          "format": "int32",
          "title": "Initial UI state information"
        },
        "turnCounter": {
          "type": "integer",
          "format": "int32"
        },
        "gameName": {
          "type": "string"
        }
      },
      "title": "Response of a turn option click"
    },
    "v1InitializeSingletonResponse": {
      "type": "object",
      "properties": {
        "response": {
          "$ref": "#/definitions/v1InitializeGameResponse"
        }
      },
      "title": "Response of a turn option click"
    },
    "v1ListFilesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1File"
          }
        },
        "pagination": {
          "$ref": "#/definitions/v1PaginationResponse"
        }
      }
    },
    "v1ListGamesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Game"
          }
        },
        "pagination": {
          "$ref": "#/definitions/v1PaginationResponse"
        }
      }
    },
    "v1ListIndexStatesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1IndexState"
          }
        },
        "nextPageKey": {
          "type": "string",
          "title": "How to identify the next \"page\" in this list"
        }
      }
    },
    "v1ListMovesResponse": {
      "type": "object",
      "properties": {
        "hasMore": {
          "type": "boolean",
          "title": "Whether there are more moves before this"
        },
        "moveGroups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameMoveGroup"
          }
        }
      },
      "description": "*\nResponse after adding moves to game."
    },
    "v1ListWorldsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1World"
          }
        },
        "pagination": {
          "$ref": "#/definitions/v1PaginationResponse"
        }
      }
    },
    "v1LogMessageResponse": {
      "type": "object",
      "title": "Response from fetch"
    },
    "v1MoveUnitAction": {
      "type": "object",
      "properties": {
        "from": {
          "$ref": "#/definitions/v1Position"
        },
        "to": {
          "$ref": "#/definitions/v1Position"
        },
        "movementCost": {
          "type": "number",
          "format": "double",
          "title": "Optional fields that can be used for showing move options as well as debugging"
        },
        "reconstructedPath": {
          "$ref": "#/definitions/v1Path",
          "title": "Debug fields"
        }
      },
      "title": "*\nMove unit from one position to another"
    },
    "v1MoveUnitResponse": {
      "type": "object"
    },
    "v1MovesPublished": {
      "type": "object",
      "properties": {
        "player": {
          "type": "integer",
          "format": "int32",
          "title": "Which player made these moves"
        },
        "moves": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameMove"
          },
          "title": "The moves with their WorldChanges populated"
        },
        "groupNumber": {
          "type": "string",
          "format": "int64",
          "title": "Group number for this batch of moves"
        }
      },
      "title": "MovesPublished indicates a player made moves"
    },
    "v1Pagination": {
      "type": "object",
      "properties": {
        "pageKey": {
          "type": "string",
          "description": "*\nInstead of an offset an abstract  \"page\" key is provided that offers\nan opaque \"pointer\" into some offset in a result set."
        },
        "pageOffset": {
          "type": "integer",
          "format": "int32",
          "description": "*\nIf a pagekey is not supported we can also support a direct integer offset\nfor cases where it makes sense."
        },
        "pageSize": {
          "type": "integer",
          "format": "int32",
          "description": "*\nNumber of results to return."
        }
      }
    },
    "v1PaginationResponse": {
      "type": "object",
      "properties": {
        "nextPageKey": {
          "type": "string",
          "description": "*\nThe key/pointer string that subsequent List requests should pass to\ncontinue the pagination."
        },
        "nextPageOffset": {
          "type": "integer",
          "format": "int32",
          "title": "*\nAlso support an integer offset if possible"
        },
        "hasMore": {
          "type": "boolean",
          "description": "*\nWhether theere are more results."
        },
        "totalResults": {
          "type": "integer",
          "format": "int32",
          "description": "*\nTotal number of results."
        }
      }
    },
    "v1Path": {
      "type": "object",
      "properties": {
        "edges": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PathEdge"
          },
          "title": "Edges in order from source to destination"
        },
        "directions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1PathDirection"
          },
          "title": "len(directions) = len(edges) - 1\nand directions[i] = direction from edge[i - 1] -\u003e edge[i]"
        },
        "totalCost": {
          "type": "number",
          "format": "double",
          "title": "Sum of all edge costs"
        }
      },
      "title": "Full path from source to destination (constructed on-demand from AllPaths)"
    },
    "v1PathDirection": {
      "type": "string",
      "enum": [
        "PATH_DIRECTION_UNSPECIFIED",
        "PATH_DIRECTION_LEFT",
        "PATH_DIRECTION_TOP_LEFT",
        "PATH_DIRECTION_TOP_RIGHT",
        "PATH_DIRECTION_RIGHT",
        "PATH_DIRECTION_BOTTOM_RIGHT",
        "PATH_DIRECTION_BOTTOM_LEFT"
      ],
      "default": "PATH_DIRECTION_UNSPECIFIED"
    },
    "v1PathEdge": {
      "type": "object",
      "properties": {
        "fromQ": {
          "type": "integer",
          "format": "int32",
          "title": "Parent coordinate Q"
        },
        "fromR": {
          "type": "integer",
          "format": "int32",
          "title": "Parent coordinate R"
        },
        "toQ": {
          "type": "integer",
          "format": "int32",
          "title": "Destination coordinate Q"
        },
        "toR": {
          "type": "integer",
          "format": "int32",
          "title": "Destination coordinate R"
        },
        "movementCost": {
          "type": "number",
          "format": "double",
          "title": "Cost to move from 'from' to 'to' (edge cost)"
        },
        "totalCost": {
          "type": "number",
          "format": "double",
          "title": "Total cumulative cost from source to 'to'"
        },
        "terrainType": {
          "type": "string",
          "title": "e.g., \"mountain\", \"plains\", \"forest\""
        },
        "explanation": {
          "type": "string",
          "title": "e.g., \"Mountain costs Soldier 4 movement points\""
        },
        "isOccupied": {
          "type": "boolean",
          "title": "True if destination tile has a friendly unit (pass-through only, cannot land)"
        }
      },
      "title": "A single edge in a path with movement details"
    },
    "v1PlayerChangedChange": {
      "type": "object",
      "properties": {
        "previousPlayer": {
          "type": "integer",
          "format": "int32"
        },
        "newPlayer": {
          "type": "integer",
          "format": "int32"
        },
        "previousTurn": {
          "type": "integer",
          "format": "int32"
        },
        "newTurn": {
          "type": "integer",
          "format": "int32"
        },
        "resetUnits": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Unit"
          },
          "title": "Units that had their movement/health reset for the new turn"
        }
      },
      "title": "*\nActive player changed"
    },
    "v1PlayerJoined": {
      "type": "object",
      "properties": {
        "playerId": {
          "type": "string"
        },
        "playerNumber": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "PlayerJoined indicates a player connected"
    },
    "v1PlayerLeft": {
      "type": "object",
      "properties": {
        "playerId": {
          "type": "string"
        },
        "playerNumber": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "PlayerLeft indicates a player disconnected"
    },
    "v1PlayerState": {
      "type": "object",
      "properties": {
        "coins": {
          "type": "integer",
          "format": "int32",
          "title": "Current coin balance (changes during gameplay via building, income, etc.)"
        },
        "isActive": {
          "type": "boolean",
          "title": "Whether player is still active in the game (not eliminated)"
        }
      },
      "title": "Runtime state for a player during the game\nThis is separate from GamePlayer (which is player configuration)\nPlayerState is indexed by player_id in the player_states map"
    },
    "v1Position": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "q": {
          "type": "integer",
          "format": "int32"
        },
        "r": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "A unified \"Position\" type that can be used to \nspecify locations via \"string shortcuts\" like A1, \"3,2\", \"r2,4\" (for row/col)\nor even \"relative\" positions like \"L,TL,TR,R\"  in the shortcut field.\nOr string q/r coordinates in the q and r fields.  This can also be used \nin the \"response\" to resolve a shortcut -\u003e q,r"
    },
    "v1ProcessMovesResponse": {
      "type": "object",
      "properties": {
        "moves": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1GameMove"
          },
          "description": "*\nReturns the moves that were passed in along wth changes and other data filled in."
        }
      },
      "description": "*\nResponse after adding moves to game."
    },
    "v1PutFileResponse": {
      "type": "object",
      "properties": {
        "file": {
          "$ref": "#/definitions/v1File"
        }
      }
    },
    "v1RemoveTileAtResponse": {
      "type": "object"
    },
    "v1RemoveUnitAtResponse": {
      "type": "object"
    },
    "v1SceneClickedResponse": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string"
        }
      },
      "title": "Response of a turn option click"
    },
    "v1SetAllowedPanelsResponse": {
      "type": "object"
    },
    "v1SetContentResponse": {
      "type": "object",
      "title": "Response from fetch"
    },
    "v1SetGameStateResponse": {
      "type": "object",
      "title": "Response from fetch"
    },
    "v1SetTileAtResponse": {
      "type": "object"
    },
    "v1SetUnitAtResponse": {
      "type": "object"
    },
    "v1ShowAttackEffectResponse": {
      "type": "object"
    },
    "v1ShowBuildOptionsResponse": {
      "type": "object"
    },
    "v1ShowCaptureEffectResponse": {
      "type": "object"
    },
    "v1ShowHealEffectResponse": {
      "type": "object"
    },
    "v1ShowHighlightsResponse": {
      "type": "object"
    },
    "v1ShowPathResponse": {
      "type": "object"
    },
    "v1SimulateAttackRequest": {
      "type": "object",
      "properties": {
        "attackerUnitType": {
          "type": "integer",
          "format": "int32"
        },
        "attackerTerrain": {
          "type": "integer",
          "format": "int32"
        },
        "attackerHealth": {
          "type": "integer",
          "format": "int32"
        },
        "defenderUnitType": {
          "type": "integer",
          "format": "int32"
        },
        "defenderTerrain": {
          "type": "integer",
          "format": "int32"
        },
        "defenderHealth": {
          "type": "integer",
          "format": "int32"
        },
        "woundBonus": {
          "type": "integer",
          "format": "int32"
        },
        "numSimulations": {
          "type": "integer",
          "format": "int32",
          "title": "Default: 1000"
        }
      },
      "title": "*\nRequest for simulating combat between two units"
    },
    "v1SimulateAttackResponse": {
      "type": "object",
      "properties": {
        "attackerDamageDistribution": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          },
          "title": "Damage distributions: damage_value -\u003e number_of_occurrences"
        },
        "defenderDamageDistribution": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          }
        },
        "attackerMeanDamage": {
          "type": "number",
          "format": "double",
          "title": "Statistical summary"
        },
        "defenderMeanDamage": {
          "type": "number",
          "format": "double"
        },
        "attackerKillProbability": {
          "type": "number",
          "format": "double"
        },
        "defenderKillProbability": {
          "type": "number",
          "format": "double"
        }
      },
      "title": "*\nResponse containing damage distribution statistics"
    },
    "v1SimulateFixRequest": {
      "type": "object",
      "properties": {
        "fixingUnitType": {
          "type": "integer",
          "format": "int32",
          "title": "Unit type performing the fix"
        },
        "fixingUnitHealth": {
          "type": "integer",
          "format": "int32",
          "title": "Health of the fixing unit (Hf)"
        },
        "injuredUnitType": {
          "type": "integer",
          "format": "int32",
          "title": "Unit type being repaired (for display)"
        },
        "numSimulations": {
          "type": "integer",
          "format": "int32",
          "title": "Default: 1000"
        }
      },
      "title": "*\nRequest for simulating fix (repair) between two units"
    },
    "v1SimulateFixResponse": {
      "type": "object",
      "properties": {
        "healingDistribution": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          },
          "title": "Health restoration distribution: health_restored -\u003e number_of_occurrences"
        },
        "meanHealing": {
          "type": "number",
          "format": "double",
          "title": "Statistical summary"
        },
        "fixValue": {
          "type": "integer",
          "format": "int32",
          "title": "The fix value (F) of the fixing unit type"
        }
      },
      "title": "*\nResponse containing health restoration distribution statistics"
    },
    "v1SplashTarget": {
      "type": "object",
      "properties": {
        "q": {
          "type": "integer",
          "format": "int32"
        },
        "r": {
          "type": "integer",
          "format": "int32"
        },
        "damage": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1SubscribeResponse": {
      "type": "object",
      "properties": {
        "currentSequence": {
          "type": "string",
          "format": "int64",
          "title": "Current sequence number at time of subscription"
        },
        "gameState": {
          "$ref": "#/definitions/v1GameState",
          "title": "Current game state (for initial load or catchup)"
        },
        "game": {
          "$ref": "#/definitions/v1Game",
          "title": "Game metadata"
        }
      },
      "title": "SubscribeResponse sent once at the start of the subscription"
    },
    "v1Tile": {
      "type": "object",
      "properties": {
        "q": {
          "type": "integer",
          "format": "int32",
          "title": "Q and R in Cubed coordinates"
        },
        "r": {
          "type": "integer",
          "format": "int32"
        },
        "tileType": {
          "type": "integer",
          "format": "int32",
          "title": "Tile type"
        },
        "player": {
          "type": "integer",
          "format": "int32",
          "title": "Whether the tile itself belongs to a player"
        },
        "shortcut": {
          "type": "string",
          "title": "A short cut like A1 or S2 etc for quick access"
        },
        "lastActedTurn": {
          "type": "integer",
          "format": "int32",
          "description": "Which turn this unit was created/last acted on (ie movemade)",
          "title": "Keep track of turns when the move was last made and when a \"top up\" was last done on/for this tile.\nThis helps us not having to \"top up\" or \"reset\" the stats at the end\nof each turn.  Instead as the game turn is incremented we can do a \nlazy reset for any unit or tile where unit_or_tile.last_toppedup_turn \u003c game.curent_turn\nSo we just have to increment the game_turn and the unit is automaticaly flagged as\nneeding a top up of its health/balance/movement etc"
        },
        "lastToppedupTurn": {
          "type": "integer",
          "format": "int32",
          "title": "When the last top up happened"
        }
      }
    },
    "v1TileCapturedChange": {
      "type": "object",
      "properties": {
        "capturingUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "The unit that captured the tile"
        },
        "tileQ": {
          "type": "integer",
          "format": "int32",
          "title": "Tile coordinates"
        },
        "tileR": {
          "type": "integer",
          "format": "int32"
        },
        "tileType": {
          "type": "integer",
          "format": "int32",
          "title": "Tile type"
        },
        "previousOwner": {
          "type": "integer",
          "format": "int32",
          "title": "Previous owner (0 for neutral)"
        },
        "newOwner": {
          "type": "integer",
          "format": "int32",
          "title": "New owner"
        }
      },
      "title": "*\nA tile was captured by a unit"
    },
    "v1TurnOptionClickedResponse": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string"
        }
      },
      "title": "Response of a turn option click"
    },
    "v1Unit": {
      "type": "object",
      "properties": {
        "q": {
          "type": "integer",
          "format": "int32",
          "title": "Q and R in Cubed coordinates"
        },
        "r": {
          "type": "integer",
          "format": "int32"
        },
        "player": {
          "type": "integer",
          "format": "int32"
        },
        "unitType": {
          "type": "integer",
          "format": "int32"
        },
        "shortcut": {
          "type": "string",
          "title": "A short cut like A1 or S2 etc for quick access"
        },
        "availableHealth": {
          "type": "integer",
          "format": "int32",
          "description": "Current health points",
          "title": "Runtime state fields"
        },
        "distanceLeft": {
          "type": "number",
          "format": "double",
          "title": "Movement points remaining this turn"
        },
        "lastActedTurn": {
          "type": "integer",
          "format": "int32",
          "description": "Which turn this unit was created/last acted on (ie movemade)",
          "title": "Keep track of turns when the move was last made and when a \"top up\" was last done on/for this tile.\nThis helps us not having to \"top up\" or \"reset\" the stats at the end\nof each turn.  Instead as the game turn is incremented we can do a \nlazy reset for any unit or tile where unit_or_tile.last_toppedup_turn \u003c game.curent_turn\nSo we just have to increment the game_turn and the unit is automaticaly flagged as\nneeding a top up of its health/balance/movement etc"
        },
        "lastToppedupTurn": {
          "type": "integer",
          "format": "int32",
          "title": "When the last top up happened"
        },
        "attacksReceivedThisTurn": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of attacks received this turn",
          "title": "Details around wound bonus tracking for this turn"
        },
        "attackHistory": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1AttackRecord"
          },
          "title": "Detailed attack history for wound bonus calculation"
        },
        "progressionStep": {
          "type": "integer",
          "format": "int32",
          "title": "Action progression tracking - index into UnitDefinition.action_order\nIndicates which step in the action sequence the unit is currently on\nReset to 0 at turn start via TopUpUnitIfNeeded()"
        },
        "chosenAlternative": {
          "type": "string",
          "title": "When current step has pipe-separated alternatives (e.g., \"attack|capture\"),\nthis tracks which alternative the user chose, preventing switching mid-step\nCleared when advancing to next step"
        },
        "captureStartedTurn": {
          "type": "integer",
          "format": "int32",
          "title": "Turn when this unit started capturing a building (0 = not capturing)\nCapture completes at the start of the capturing player's next turn\nif the unit is still alive on the tile"
        }
      }
    },
    "v1UnitBuiltChange": {
      "type": "object",
      "properties": {
        "unit": {
          "$ref": "#/definitions/v1Unit",
          "title": "The newly created unit"
        },
        "tileQ": {
          "type": "integer",
          "format": "int32",
          "title": "Tile coordinates where unit was built"
        },
        "tileR": {
          "type": "integer",
          "format": "int32"
        },
        "coinsCost": {
          "type": "integer",
          "format": "int32",
          "title": "Cost in coins"
        },
        "playerCoins": {
          "type": "integer",
          "format": "int32",
          "title": "Player's remaining coins after build"
        }
      },
      "title": "*\nA new unit was built at a tile"
    },
    "v1UnitDamagedChange": {
      "type": "object",
      "properties": {
        "previousUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Complete unit state before taking damage"
        },
        "updatedUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Complete unit state after taking damage"
        }
      },
      "title": "*\nA unit took damage"
    },
    "v1UnitFixedChange": {
      "type": "object",
      "properties": {
        "fixerUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Unit that performed the fix"
        },
        "previousTarget": {
          "$ref": "#/definitions/v1Unit",
          "title": "Target unit state before fix"
        },
        "updatedTarget": {
          "$ref": "#/definitions/v1Unit",
          "title": "Target unit state after fix"
        },
        "fixAmount": {
          "type": "integer",
          "format": "int32",
          "title": "Amount of health restored"
        }
      },
      "title": "*\nA unit was fixed (repaired) by another unit"
    },
    "v1UnitHealedChange": {
      "type": "object",
      "properties": {
        "previousUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Unit state before healing"
        },
        "updatedUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Unit state after healing"
        },
        "healAmount": {
          "type": "integer",
          "format": "int32",
          "title": "Amount healed"
        }
      },
      "title": "*\nA unit was healed"
    },
    "v1UnitKilledChange": {
      "type": "object",
      "properties": {
        "previousUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Complete unit state before being killed"
        }
      },
      "title": "*\nA unit was killed"
    },
    "v1UnitMovedChange": {
      "type": "object",
      "properties": {
        "previousUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Complete unit state before the move"
        },
        "updatedUnit": {
          "$ref": "#/definitions/v1Unit",
          "title": "Complete unit state after the move (includes updated position, distanceLeft, etc.)"
        }
      },
      "title": "*\nA unit moved from one position to another"
    },
    "v1UpdateGameResponse": {
      "type": "object",
      "properties": {
        "game": {
          "$ref": "#/definitions/v1Game",
          "title": "*\nGame being updated"
        }
      },
      "description": "*\nThe request for (partially) updating an Game.",
      "title": "UpdateGameResponse"
    },
    "v1UpdateGameStatusResponse": {
      "type": "object"
    },
    "v1UpdateWorldResponse": {
      "type": "object",
      "properties": {
        "world": {
          "$ref": "#/definitions/v1World",
          "title": "*\nWorld being updated"
        },
        "worldData": {
          "$ref": "#/definitions/v1WorldData"
        }
      },
      "description": "*\nThe request for (partially) updating an World.",
      "title": "UpdateWorldResponse"
    },
    "v1World": {
      "type": "object",
      "properties": {
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "Version for Optimistic concurrent locking"
        },
        "id": {
          "type": "string",
          "title": "Unique ID for the world"
        },
        "creatorId": {
          "type": "string",
          "title": "User that created the world"
        },
        "name": {
          "type": "string",
          "title": "Name if items have names"
        },
        "description": {
          "type": "string",
          "title": "Description if world has a description"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Some tags"
        },
        "imageUrl": {
          "type": "string",
          "title": "A possible image url"
        },
        "difficulty": {
          "type": "string",
          "title": "Difficulty - example attribute"
        },
        "previewUrls": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "URL to screenshot/preview image (defaults to /worlds/{id}/screenshots/{screenshotName})\nCan be overridden to point to CDN or external hosting"
        },
        "defaultGameConfig": {
          "$ref": "#/definitions/v1GameConfiguration",
          "title": "Default game configs"
        },
        "searchIndexInfo": {
          "$ref": "#/definitions/v1IndexInfo"
        }
      }
    },
    "v1WorldChange": {
      "type": "object",
      "properties": {
        "unitMoved": {
          "$ref": "#/definitions/v1UnitMovedChange"
        },
        "unitDamaged": {
          "$ref": "#/definitions/v1UnitDamagedChange"
        },
        "unitKilled": {
          "$ref": "#/definitions/v1UnitKilledChange"
        },
        "playerChanged": {
          "$ref": "#/definitions/v1PlayerChangedChange"
        },
        "unitBuilt": {
          "$ref": "#/definitions/v1UnitBuiltChange"
        },
        "coinsChanged": {
          "$ref": "#/definitions/v1CoinsChangedChange"
        },
        "tileCaptured": {
          "$ref": "#/definitions/v1TileCapturedChange"
        },
        "captureStarted": {
          "$ref": "#/definitions/v1CaptureStartedChange"
        },
        "unitHealed": {
          "$ref": "#/definitions/v1UnitHealedChange"
        },
        "unitFixed": {
          "$ref": "#/definitions/v1UnitFixedChange"
        }
      },
      "title": "*\nRepresents a change to the game world"
    },
    "v1WorldData": {
      "type": "object",
      "properties": {
        "tilesMap": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Tile"
          },
          "title": "New map-based storage (key = \"q,r\" coordinate string)"
        },
        "unitsMap": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Unit"
          }
        },
        "screenshotIndexInfo": {
          "$ref": "#/definitions/v1IndexInfo",
          "title": "When this world data was updated (may have happened without world updating)"
        },
        "contentHash": {
          "type": "string",
          "title": "We will only update if hash's are different"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "Version for Optimistic concurrent locking"
        },
        "crossings": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Crossing"
          },
          "description": "key = \"q,r\", value = crossing with connectivity",
          "title": "Improvement layer - crossings (roads on land, bridges on water)"
        }
      }
    }
  }
}
