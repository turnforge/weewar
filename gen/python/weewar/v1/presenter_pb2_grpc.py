# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from weewar.v1 import presenter_pb2 as weewar_dot_v1_dot_presenter__pb2


class GameViewPresenterServiceStub(object):
    """Presenter service is the P in Model View Presenter
    We noticed that the front end was getting very bloated with not just views but also the 
    cycles of interactions across various components.   So a MVP is being adopted where
    the frontend/views are being as dumb as possible.  They will just react to commands
    and state changes but not be responsible for handling user interactions.  They will just
    present them to the Presenter who will handle the UI logic between the view and the backend (model)

    This will also help us mock out the views as we see fit for testing and also have various kinds of views
    eg a Text based views, Typescript views, views over websocket to remote clients etc

    The other advantage is we can also change presenters to suit various looks/feels.
    Note that our Presenter service is GameViewPresenter service.  This way we can create one presenter
    per "page" so each page (which is heavy weight and needs wasm) can create one of these.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.TileClicked = channel.unary_unary(
                '/weewar.v1.GameViewPresenterService/TileClicked',
                request_serializer=weewar_dot_v1_dot_presenter__pb2.TileClickedRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_presenter__pb2.TileClickedResponse.FromString,
                _registered_method=True)
        self.TurnOptionClicked = channel.unary_unary(
                '/weewar.v1.GameViewPresenterService/TurnOptionClicked',
                request_serializer=weewar_dot_v1_dot_presenter__pb2.TurnOptionClickedRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_presenter__pb2.TurnOptionClickedResponse.FromString,
                _registered_method=True)


class GameViewPresenterServiceServicer(object):
    """Presenter service is the P in Model View Presenter
    We noticed that the front end was getting very bloated with not just views but also the 
    cycles of interactions across various components.   So a MVP is being adopted where
    the frontend/views are being as dumb as possible.  They will just react to commands
    and state changes but not be responsible for handling user interactions.  They will just
    present them to the Presenter who will handle the UI logic between the view and the backend (model)

    This will also help us mock out the views as we see fit for testing and also have various kinds of views
    eg a Text based views, Typescript views, views over websocket to remote clients etc

    The other advantage is we can also change presenters to suit various looks/feels.
    Note that our Presenter service is GameViewPresenter service.  This way we can create one presenter
    per "page" so each page (which is heavy weight and needs wasm) can create one of these.
    """

    def TileClicked(self, request, context):
        """*
        This is called when the user clicks a tile on the Game Scene
        The tile can have a unit or just be a plain tile.  It is upto the presenter to
        change the various view states
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def TurnOptionClicked(self, request, context):
        """*
        Called when a particular turn option is clicked in the TurnOptionsPanel
        Note how we have a strong coupling between what the page elements do and which presenter elements they call
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_GameViewPresenterServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'TileClicked': grpc.unary_unary_rpc_method_handler(
                    servicer.TileClicked,
                    request_deserializer=weewar_dot_v1_dot_presenter__pb2.TileClickedRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_presenter__pb2.TileClickedResponse.SerializeToString,
            ),
            'TurnOptionClicked': grpc.unary_unary_rpc_method_handler(
                    servicer.TurnOptionClicked,
                    request_deserializer=weewar_dot_v1_dot_presenter__pb2.TurnOptionClickedRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_presenter__pb2.TurnOptionClickedResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'weewar.v1.GameViewPresenterService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('weewar.v1.GameViewPresenterService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class GameViewPresenterService(object):
    """Presenter service is the P in Model View Presenter
    We noticed that the front end was getting very bloated with not just views but also the 
    cycles of interactions across various components.   So a MVP is being adopted where
    the frontend/views are being as dumb as possible.  They will just react to commands
    and state changes but not be responsible for handling user interactions.  They will just
    present them to the Presenter who will handle the UI logic between the view and the backend (model)

    This will also help us mock out the views as we see fit for testing and also have various kinds of views
    eg a Text based views, Typescript views, views over websocket to remote clients etc

    The other advantage is we can also change presenters to suit various looks/feels.
    Note that our Presenter service is GameViewPresenter service.  This way we can create one presenter
    per "page" so each page (which is heavy weight and needs wasm) can create one of these.
    """

    @staticmethod
    def TileClicked(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenterService/TileClicked',
            weewar_dot_v1_dot_presenter__pb2.TileClickedRequest.SerializeToString,
            weewar_dot_v1_dot_presenter__pb2.TileClickedResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def TurnOptionClicked(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenterService/TurnOptionClicked',
            weewar_dot_v1_dot_presenter__pb2.TurnOptionClickedRequest.SerializeToString,
            weewar_dot_v1_dot_presenter__pb2.TurnOptionClickedResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
