# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from weewar.v1.models import presenter_pb2 as weewar_dot_v1_dot_models_dot_presenter__pb2


class SingletonInitializerServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.InitializeSingleton = channel.unary_unary(
                '/weewar.v1.SingletonInitializerService/InitializeSingleton',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeSingletonRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeSingletonResponse.FromString,
                _registered_method=True)


class SingletonInitializerServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def InitializeSingleton(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_SingletonInitializerServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'InitializeSingleton': grpc.unary_unary_rpc_method_handler(
                    servicer.InitializeSingleton,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeSingletonRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeSingletonResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'weewar.v1.SingletonInitializerService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('weewar.v1.SingletonInitializerService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class SingletonInitializerService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def InitializeSingleton(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.SingletonInitializerService/InitializeSingleton',
            weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeSingletonRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeSingletonResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)


class GameViewPresenterStub(object):
    """Presenter service is the P in Model View Presenter
    We noticed that the front end was getting very bloated with not just views but also the 
    cycles of interactions across various components.   So a MVP is being adopted where
    the frontend/views are being as dumb as possible.  They will just react to commands
    and state changes but not be responsible for handling user interactions.  They will just
    present them to the Presenter who will handle the UI logic between the view and the backend (model)

    This will also help us mock out the views as we see fit for testing and also have various kinds of views
    eg a Text based views, Typescript views, views over websocket to remote clients etc

    The other advantage is we can also change presenters to suit various looks/feels.
    Note that our Presenter service is GameViewPresenter service.  This way we can create one presenter
    per "page" so each page (which is heavy weight and needs wasm) can create one of these.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.InitializeGame = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/InitializeGame',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeGameRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeGameResponse.FromString,
                _registered_method=True)
        self.ClientReady = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/ClientReady',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ClientReadyRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ClientReadyResponse.FromString,
                _registered_method=True)
        self.SceneClicked = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/SceneClicked',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.SceneClickedRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.SceneClickedResponse.FromString,
                _registered_method=True)
        self.TurnOptionClicked = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/TurnOptionClicked',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.TurnOptionClickedRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.TurnOptionClickedResponse.FromString,
                _registered_method=True)
        self.EndTurnButtonClicked = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/EndTurnButtonClicked',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.EndTurnButtonClickedRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.EndTurnButtonClickedResponse.FromString,
                _registered_method=True)
        self.BuildOptionClicked = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/BuildOptionClicked',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.BuildOptionClickedRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.BuildOptionClickedResponse.FromString,
                _registered_method=True)
        self.ApplyRemoteChanges = channel.unary_unary(
                '/weewar.v1.GameViewPresenter/ApplyRemoteChanges',
                request_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ApplyRemoteChangesRequest.SerializeToString,
                response_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ApplyRemoteChangesResponse.FromString,
                _registered_method=True)


class GameViewPresenterServicer(object):
    """Presenter service is the P in Model View Presenter
    We noticed that the front end was getting very bloated with not just views but also the 
    cycles of interactions across various components.   So a MVP is being adopted where
    the frontend/views are being as dumb as possible.  They will just react to commands
    and state changes but not be responsible for handling user interactions.  They will just
    present them to the Presenter who will handle the UI logic between the view and the backend (model)

    This will also help us mock out the views as we see fit for testing and also have various kinds of views
    eg a Text based views, Typescript views, views over websocket to remote clients etc

    The other advantage is we can also change presenters to suit various looks/feels.
    Note that our Presenter service is GameViewPresenter service.  This way we can create one presenter
    per "page" so each page (which is heavy weight and needs wasm) can create one of these.
    """

    def InitializeGame(self, request, context):
        """*
        Called on first init based on the game and world data
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ClientReady(self, request, context):
        """*
        Called by the browser after the UI/scene is fully initialized and ready
        to receive visual updates (highlights, paths, etc.)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SceneClicked(self, request, context):
        """*
        This is called when the user clicks a tile on the Game Scene
        The tile can have a unit or just be a plain tile.  It is upto the presenter to
        change the various view states
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def TurnOptionClicked(self, request, context):
        """*
        Called when a particular turn option is clicked in the TurnOptionsPanel
        Note how we have a strong coupling between what the page elements do and which
        presenter elements they call
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def EndTurnButtonClicked(self, request, context):
        """*
        Called when user clicked the EndTurn button
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def BuildOptionClicked(self, request, context):
        """*
        Called when a build option is clicked in the BuildOptionsModal
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ApplyRemoteChanges(self, request, context):
        """*
        Apply changes from remote players (received via SyncService subscription).
        This updates local game state and triggers UI updates for the received WorldChanges.
        Used by viewers to apply moves made by other players.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_GameViewPresenterServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'InitializeGame': grpc.unary_unary_rpc_method_handler(
                    servicer.InitializeGame,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeGameRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeGameResponse.SerializeToString,
            ),
            'ClientReady': grpc.unary_unary_rpc_method_handler(
                    servicer.ClientReady,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ClientReadyRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ClientReadyResponse.SerializeToString,
            ),
            'SceneClicked': grpc.unary_unary_rpc_method_handler(
                    servicer.SceneClicked,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.SceneClickedRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.SceneClickedResponse.SerializeToString,
            ),
            'TurnOptionClicked': grpc.unary_unary_rpc_method_handler(
                    servicer.TurnOptionClicked,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.TurnOptionClickedRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.TurnOptionClickedResponse.SerializeToString,
            ),
            'EndTurnButtonClicked': grpc.unary_unary_rpc_method_handler(
                    servicer.EndTurnButtonClicked,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.EndTurnButtonClickedRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.EndTurnButtonClickedResponse.SerializeToString,
            ),
            'BuildOptionClicked': grpc.unary_unary_rpc_method_handler(
                    servicer.BuildOptionClicked,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.BuildOptionClickedRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.BuildOptionClickedResponse.SerializeToString,
            ),
            'ApplyRemoteChanges': grpc.unary_unary_rpc_method_handler(
                    servicer.ApplyRemoteChanges,
                    request_deserializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ApplyRemoteChangesRequest.FromString,
                    response_serializer=weewar_dot_v1_dot_models_dot_presenter__pb2.ApplyRemoteChangesResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'weewar.v1.GameViewPresenter', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('weewar.v1.GameViewPresenter', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class GameViewPresenter(object):
    """Presenter service is the P in Model View Presenter
    We noticed that the front end was getting very bloated with not just views but also the 
    cycles of interactions across various components.   So a MVP is being adopted where
    the frontend/views are being as dumb as possible.  They will just react to commands
    and state changes but not be responsible for handling user interactions.  They will just
    present them to the Presenter who will handle the UI logic between the view and the backend (model)

    This will also help us mock out the views as we see fit for testing and also have various kinds of views
    eg a Text based views, Typescript views, views over websocket to remote clients etc

    The other advantage is we can also change presenters to suit various looks/feels.
    Note that our Presenter service is GameViewPresenter service.  This way we can create one presenter
    per "page" so each page (which is heavy weight and needs wasm) can create one of these.
    """

    @staticmethod
    def InitializeGame(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/InitializeGame',
            weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeGameRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.InitializeGameResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ClientReady(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/ClientReady',
            weewar_dot_v1_dot_models_dot_presenter__pb2.ClientReadyRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.ClientReadyResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SceneClicked(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/SceneClicked',
            weewar_dot_v1_dot_models_dot_presenter__pb2.SceneClickedRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.SceneClickedResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def TurnOptionClicked(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/TurnOptionClicked',
            weewar_dot_v1_dot_models_dot_presenter__pb2.TurnOptionClickedRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.TurnOptionClickedResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def EndTurnButtonClicked(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/EndTurnButtonClicked',
            weewar_dot_v1_dot_models_dot_presenter__pb2.EndTurnButtonClickedRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.EndTurnButtonClickedResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def BuildOptionClicked(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/BuildOptionClicked',
            weewar_dot_v1_dot_models_dot_presenter__pb2.BuildOptionClickedRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.BuildOptionClickedResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ApplyRemoteChanges(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/weewar.v1.GameViewPresenter/ApplyRemoteChanges',
            weewar_dot_v1_dot_models_dot_presenter__pb2.ApplyRemoteChangesRequest.SerializeToString,
            weewar_dot_v1_dot_models_dot_presenter__pb2.ApplyRemoteChangesResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
