//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: weewar/v1/services/filestore.proto

package weewar

import (
	"context"
	"encoding/json"
	"fmt"
	"syscall/js"
	"time"

	wasm "github.com/panyam/protoc-gen-go-wasmjs/pkg/wasm"
	v1models "github.com/turnforge/weewar/gen/go/weewar/v1/models"
)

// Weewar_v1ServicesExports provides WASM exports for dependency injection
type Weewar_v1ServicesExports struct {
	FileStoreService            FileStoreServiceServer
	GamesService                GamesServiceServer
	IndexerService              IndexerServiceServer
	SingletonInitializerService SingletonInitializerServiceServer
	GameViewPresenter           GameViewPresenterServer
	GameSyncService             GameSyncServiceServer
	WorldsService               WorldsServiceServer

	// Browser-provided services (clients)
	GameViewerPage *GameViewerPageClient
}

// RegisterAPI registers the services with the JavaScript global namespace
func (exports *Weewar_v1ServicesExports) RegisterAPI() {
	fmt.Println("weewar WASM module loading...")

	// Initialize browser channel for browser-provided services
	_ = wasm.GetBrowserChannel()
	// Create namespaced API structure
	weewar := map[string]interface{}{
		"fileStoreService": map[string]interface{}{
			"putFile": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.fileStoreServicePutFile(this, args)
			}),
			"getFile": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.fileStoreServiceGetFile(this, args)
			}),
			"deleteFile": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.fileStoreServiceDeleteFile(this, args)
			}),
			"listFiles": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.fileStoreServiceListFiles(this, args)
			}),
		},
		"gamesService": map[string]interface{}{
			"createGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceCreateGame(this, args)
			}),
			"getGames": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceGetGames(this, args)
			}),
			"listGames": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceListGames(this, args)
			}),
			"getGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceGetGame(this, args)
			}),
			"deleteGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceDeleteGame(this, args)
			}),
			"updateGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceUpdateGame(this, args)
			}),
			"getGameState": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceGetGameState(this, args)
			}),
			"listMoves": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceListMoves(this, args)
			}),
			"processMoves": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceProcessMoves(this, args)
			}),
			"getOptionsAt": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceGetOptionsAt(this, args)
			}),
			"simulateAttack": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceSimulateAttack(this, args)
			}),
			"simulateFix": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceSimulateFix(this, args)
			}),
		},
		"indexerService": map[string]interface{}{
			"ensureIndexState": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.indexerServiceEnsureIndexState(this, args)
			}),
			"getIndexStates": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.indexerServiceGetIndexStates(this, args)
			}),
			"listIndexStates": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.indexerServiceListIndexStates(this, args)
			}),
			"deleteIndexStates": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.indexerServiceDeleteIndexStates(this, args)
			}),
		},
		"singletonInitializerService": map[string]interface{}{
			"initializeSingleton": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.singletonInitializerServiceInitializeSingleton(this, args)
			}),
		},
		"gameViewPresenter": map[string]interface{}{
			"initializeGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterInitializeGame(this, args)
			}),
			"clientReady": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterClientReady(this, args)
			}),
			"sceneClicked": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterSceneClicked(this, args)
			}),
			"turnOptionClicked": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterTurnOptionClicked(this, args)
			}),
			"endTurnButtonClicked": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterEndTurnButtonClicked(this, args)
			}),
			"buildOptionClicked": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterBuildOptionClicked(this, args)
			}),
			"applyRemoteChanges": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameViewPresenterApplyRemoteChanges(this, args)
			}),
		},
		"gameSyncService": map[string]interface{}{
			"subscribe": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameSyncServiceSubscribe(this, args)
			}),
			"broadcast": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gameSyncServiceBroadcast(this, args)
			}),
		},
		"worldsService": map[string]interface{}{
			"createWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceCreateWorld(this, args)
			}),
			"getWorlds": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceGetWorlds(this, args)
			}),
			"listWorlds": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceListWorlds(this, args)
			}),
			"getWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceGetWorld(this, args)
			}),
			"deleteWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceDeleteWorld(this, args)
			}),
			"updateWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceUpdateWorld(this, args)
			}),
		},
	}
	js.Global().Set("weewar", js.ValueOf(weewar))

	fmt.Println("weewar WASM module loaded successfully")
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

// fileStoreServicePutFile handles the PutFile method for FileStoreService
func (exports *Weewar_v1ServicesExports) fileStoreServicePutFile(this js.Value, args []js.Value) any {
	if exports.FileStoreService == nil {
		return wasm.CreateJSResponse(false, "FileStoreService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.PutFileRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.FileStoreService.PutFile(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// fileStoreServiceGetFile handles the GetFile method for FileStoreService
func (exports *Weewar_v1ServicesExports) fileStoreServiceGetFile(this js.Value, args []js.Value) any {
	if exports.FileStoreService == nil {
		return wasm.CreateJSResponse(false, "FileStoreService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetFileRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.FileStoreService.GetFile(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// fileStoreServiceDeleteFile handles the DeleteFile method for FileStoreService
func (exports *Weewar_v1ServicesExports) fileStoreServiceDeleteFile(this js.Value, args []js.Value) any {
	if exports.FileStoreService == nil {
		return wasm.CreateJSResponse(false, "FileStoreService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteFileRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.FileStoreService.DeleteFile(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// fileStoreServiceListFiles handles the ListFiles method for FileStoreService
func (exports *Weewar_v1ServicesExports) fileStoreServiceListFiles(this js.Value, args []js.Value) any {
	if exports.FileStoreService == nil {
		return wasm.CreateJSResponse(false, "FileStoreService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListFilesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.FileStoreService.ListFiles(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceCreateGame handles the CreateGame method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceCreateGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.CreateGameRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.CreateGame(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceGetGames handles the GetGames method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceGetGames(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetGamesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.GetGames(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceListGames handles the ListGames method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceListGames(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListGamesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.ListGames(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceGetGame handles the GetGame method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceGetGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetGameRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.GetGame(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceDeleteGame handles the DeleteGame method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceDeleteGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteGameRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.DeleteGame(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceUpdateGame handles the UpdateGame method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceUpdateGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UpdateGameRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.UpdateGame(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceGetGameState handles the GetGameState method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceGetGameState(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetGameStateRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.GetGameState(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceListMoves handles the ListMoves method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceListMoves(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListMovesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.ListMoves(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceProcessMoves handles the ProcessMoves method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceProcessMoves(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ProcessMovesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.ProcessMoves(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceGetOptionsAt handles the GetOptionsAt method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceGetOptionsAt(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetOptionsAtRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.GetOptionsAt(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceSimulateAttack handles the SimulateAttack method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceSimulateAttack(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.SimulateAttackRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.SimulateAttack(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceSimulateFix handles the SimulateFix method for GamesService
func (exports *Weewar_v1ServicesExports) gamesServiceSimulateFix(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return wasm.CreateJSResponse(false, "GamesService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.SimulateFixRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.SimulateFix(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// indexerServiceEnsureIndexState handles the EnsureIndexState method for IndexerService
func (exports *Weewar_v1ServicesExports) indexerServiceEnsureIndexState(this js.Value, args []js.Value) any {
	if exports.IndexerService == nil {
		return wasm.CreateJSResponse(false, "IndexerService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.EnsureIndexStateRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.IndexerService.EnsureIndexState(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// indexerServiceGetIndexStates handles the GetIndexStates method for IndexerService
func (exports *Weewar_v1ServicesExports) indexerServiceGetIndexStates(this js.Value, args []js.Value) any {
	if exports.IndexerService == nil {
		return wasm.CreateJSResponse(false, "IndexerService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetIndexStatesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.IndexerService.GetIndexStates(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// indexerServiceListIndexStates handles the ListIndexStates method for IndexerService
func (exports *Weewar_v1ServicesExports) indexerServiceListIndexStates(this js.Value, args []js.Value) any {
	if exports.IndexerService == nil {
		return wasm.CreateJSResponse(false, "IndexerService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListIndexStatesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.IndexerService.ListIndexStates(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// indexerServiceDeleteIndexStates handles the DeleteIndexStates method for IndexerService
func (exports *Weewar_v1ServicesExports) indexerServiceDeleteIndexStates(this js.Value, args []js.Value) any {
	if exports.IndexerService == nil {
		return wasm.CreateJSResponse(false, "IndexerService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteIndexStatesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.IndexerService.DeleteIndexStates(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// singletonInitializerServiceInitializeSingleton handles the InitializeSingleton method for SingletonInitializerService
func (exports *Weewar_v1ServicesExports) singletonInitializerServiceInitializeSingleton(this js.Value, args []js.Value) any {
	if exports.SingletonInitializerService == nil {
		return wasm.CreateJSResponse(false, "SingletonInitializerService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.InitializeSingletonRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.SingletonInitializerService.InitializeSingleton(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gameViewPresenterInitializeGame handles the InitializeGame method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterInitializeGame(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.InitializeGameRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GameViewPresenter.InitializeGame(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gameViewPresenterClientReady handles the ClientReady method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterClientReady(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Promise method: returns JS Promise, executes in goroutine
	if len(args) < 1 {
		return wasm.CreateRejectedPromise("Request JSON required")
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateRejectedPromise("Request JSON is empty")
	}

	// Parse request
	req := &v1models.ClientReadyRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}); err != nil {
		return wasm.CreateRejectedPromise(fmt.Sprintf("Failed to parse request: %v", err))
	}

	// Return Promise immediately, work happens in goroutine
	return wasm.CreateJSPromise(func(resolve, reject func(any)) {
		go func() {
			ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
			defer cancel()

			// Call service method
			resp, err := exports.GameViewPresenter.ClientReady(ctx, req)
			if err != nil {
				reject(err.Error())
				return
			}

			// Marshal response
			responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
				UseProtoNames:   false,
				EmitUnpopulated: true,
				UseEnumNumbers:  false,
			})
			if err != nil {
				reject(fmt.Sprintf("Failed to marshal response: %v", err))
				return
			}

			// Convert JSON to JavaScript object and resolve
			var jsObject interface{}
			if err := json.Unmarshal(responseJSON, &jsObject); err != nil {
				reject(fmt.Sprintf("Failed to convert response to JS object: %v", err))
				return
			}
			resolve(js.ValueOf(jsObject))
		}()
	})
}

// gameViewPresenterSceneClicked handles the SceneClicked method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterSceneClicked(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.SceneClickedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GameViewPresenter.SceneClicked(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gameViewPresenterTurnOptionClicked handles the TurnOptionClicked method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterTurnOptionClicked(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.TurnOptionClickedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GameViewPresenter.TurnOptionClicked(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gameViewPresenterEndTurnButtonClicked handles the EndTurnButtonClicked method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterEndTurnButtonClicked(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.EndTurnButtonClickedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GameViewPresenter.EndTurnButtonClicked(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gameViewPresenterBuildOptionClicked handles the BuildOptionClicked method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterBuildOptionClicked(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.BuildOptionClickedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GameViewPresenter.BuildOptionClicked(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gameViewPresenterApplyRemoteChanges handles the ApplyRemoteChanges method for GameViewPresenter
func (exports *Weewar_v1ServicesExports) gameViewPresenterApplyRemoteChanges(this js.Value, args []js.Value) any {
	if exports.GameViewPresenter == nil {
		return wasm.CreateJSResponse(false, "GameViewPresenter not initialized", nil)
	}
	// Promise method: returns JS Promise, executes in goroutine
	if len(args) < 1 {
		return wasm.CreateRejectedPromise("Request JSON required")
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateRejectedPromise("Request JSON is empty")
	}

	// Parse request
	req := &v1models.ApplyRemoteChangesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}); err != nil {
		return wasm.CreateRejectedPromise(fmt.Sprintf("Failed to parse request: %v", err))
	}

	// Return Promise immediately, work happens in goroutine
	return wasm.CreateJSPromise(func(resolve, reject func(any)) {
		go func() {
			ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
			defer cancel()

			// Call service method
			resp, err := exports.GameViewPresenter.ApplyRemoteChanges(ctx, req)
			if err != nil {
				reject(err.Error())
				return
			}

			// Marshal response
			responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
				UseProtoNames:   false,
				EmitUnpopulated: true,
				UseEnumNumbers:  false,
			})
			if err != nil {
				reject(fmt.Sprintf("Failed to marshal response: %v", err))
				return
			}

			// Convert JSON to JavaScript object and resolve
			var jsObject interface{}
			if err := json.Unmarshal(responseJSON, &jsObject); err != nil {
				reject(fmt.Sprintf("Failed to convert response to JS object: %v", err))
				return
			}
			resolve(js.ValueOf(jsObject))
		}()
	})
}

// gameSyncServiceSubscribe handles the Subscribe method for GameSyncService
func (exports *Weewar_v1ServicesExports) gameSyncServiceSubscribe(this js.Value, args []js.Value) any {
	if exports.GameSyncService == nil {
		return wasm.CreateJSResponse(false, "GameSyncService not initialized", nil)
	}
	// Server streaming method: expect request JSON and callback function
	if len(args) < 2 {
		return wasm.CreateJSResponse(false, "Request JSON and callback function required for streaming method", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	callback := args[1]
	if callback.Type() != js.TypeFunction {
		return wasm.CreateJSResponse(false, "Second argument must be a callback function", nil)
	}

	// Parse request
	req := &v1models.SubscribeRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Start streaming in goroutine to avoid blocking
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		// Create a stream wrapper that implements Subscribe_ServerStream
		streamWrapper := &serverStreamWrapperSubscribe{
			ctx:      ctx,
			callback: callback,
		}

		// Call the server streaming method with the correct signature
		err := exports.GameSyncService.Subscribe(req, streamWrapper)
		if err != nil {
			// Call callback with error and done=true
			callback.Invoke(js.Null(), err.Error(), true)
			return
		}

		// Signal completion
		callback.Invoke(js.Null(), js.Null(), true)
	}()

	// Return immediately for streaming methods
	return wasm.CreateJSResponse(true, "Server streaming started", nil)
}

// gameSyncServiceBroadcast handles the Broadcast method for GameSyncService
func (exports *Weewar_v1ServicesExports) gameSyncServiceBroadcast(this js.Value, args []js.Value) any {
	if exports.GameSyncService == nil {
		return wasm.CreateJSResponse(false, "GameSyncService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.BroadcastRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GameSyncService.Broadcast(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceCreateWorld handles the CreateWorld method for WorldsService
func (exports *Weewar_v1ServicesExports) worldsServiceCreateWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return wasm.CreateJSResponse(false, "WorldsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.CreateWorldRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.CreateWorld(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceGetWorlds handles the GetWorlds method for WorldsService
func (exports *Weewar_v1ServicesExports) worldsServiceGetWorlds(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return wasm.CreateJSResponse(false, "WorldsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetWorldsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.GetWorlds(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceListWorlds handles the ListWorlds method for WorldsService
func (exports *Weewar_v1ServicesExports) worldsServiceListWorlds(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return wasm.CreateJSResponse(false, "WorldsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListWorldsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.ListWorlds(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceGetWorld handles the GetWorld method for WorldsService
func (exports *Weewar_v1ServicesExports) worldsServiceGetWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return wasm.CreateJSResponse(false, "WorldsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetWorldRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.GetWorld(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceDeleteWorld handles the DeleteWorld method for WorldsService
func (exports *Weewar_v1ServicesExports) worldsServiceDeleteWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return wasm.CreateJSResponse(false, "WorldsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteWorldRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.DeleteWorld(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceUpdateWorld handles the UpdateWorld method for WorldsService
func (exports *Weewar_v1ServicesExports) worldsServiceUpdateWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return wasm.CreateJSResponse(false, "WorldsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UpdateWorldRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.UpdateWorld(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}
