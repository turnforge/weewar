//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: turnengine/v1/coordinator.proto

package turnengine_v1_services

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"syscall/js"
	"time"

	"google.golang.org/protobuf/encoding/protojson"
	turnenginev1 "github.com/panyam/turnengine/engine/gen/go/turnengine/v1"
)

// Turnengine_v1_servicesServicesExports provides WASM exports for dependency injection
type Turnengine_v1_servicesServicesExports struct {
	CoordinatorService turnenginev1.CoordinatorServiceServer
}

// RegisterAPI registers the services with the JavaScript global namespace
func (exports *Turnengine_v1_servicesServicesExports) RegisterAPI() {
	fmt.Println("turnengine_v1_services WASM module loading...")
	// Create namespaced API structure
	weewar := map[string]interface{}{
		"coordinatorService": map[string]interface{}{
			"submitProposal": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.coordinatorServiceSubmitProposal(this, args)
			}),
			"getPendingValidations": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.coordinatorServiceGetPendingValidations(this, args)
			}),
			"submitValidation": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.coordinatorServiceSubmitValidation(this, args)
			}),
			"getProposalStatus": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.coordinatorServiceGetProposalStatus(this, args)
			}),
		},
	}
	js.Global().Set("weewar", js.ValueOf(weewar))

	fmt.Println("turnengine_v1_services WASM module loaded successfully")
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

// coordinatorServiceSubmitProposal handles the SubmitProposal method for CoordinatorService
func (exports *Turnengine_v1_servicesServicesExports) coordinatorServiceSubmitProposal(this js.Value, args []js.Value) any {
	if exports.CoordinatorService == nil {
		return createJSResponse(false, "CoordinatorService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &turnenginev1.SubmitProposalRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CoordinatorService.SubmitProposal(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: false, // Don't emit zero values
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// coordinatorServiceGetPendingValidations handles the GetPendingValidations method for CoordinatorService
func (exports *Turnengine_v1_servicesServicesExports) coordinatorServiceGetPendingValidations(this js.Value, args []js.Value) any {
	if exports.CoordinatorService == nil {
		return createJSResponse(false, "CoordinatorService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &turnenginev1.GetPendingValidationsRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CoordinatorService.GetPendingValidations(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: false, // Don't emit zero values
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// coordinatorServiceSubmitValidation handles the SubmitValidation method for CoordinatorService
func (exports *Turnengine_v1_servicesServicesExports) coordinatorServiceSubmitValidation(this js.Value, args []js.Value) any {
	if exports.CoordinatorService == nil {
		return createJSResponse(false, "CoordinatorService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &turnenginev1.SubmitValidationRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CoordinatorService.SubmitValidation(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: false, // Don't emit zero values
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// coordinatorServiceGetProposalStatus handles the GetProposalStatus method for CoordinatorService
func (exports *Turnengine_v1_servicesServicesExports) coordinatorServiceGetProposalStatus(this js.Value, args []js.Value) any {
	if exports.CoordinatorService == nil {
		return createJSResponse(false, "CoordinatorService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &turnenginev1.GetProposalStatusRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CoordinatorService.GetProposalStatus(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: false, // Don't emit zero values
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// =============================================================================
// Helper Functions
// =============================================================================

// createJSResponse creates a JavaScript-compatible response
func createJSResponse(success bool, message string, data any) any {
	response := map[string]any{
		"success": success,
		"message": message,
		"data":    data,
	}

	// Convert to JS Value
	responseBytes, err := json.Marshal(response)
	if err != nil {
		fmt.Printf("Failed to marshal JSON response: %v\n", err)
		// Return a simple error response
		errorResponse := map[string]any{
			"success": false,
			"message": fmt.Sprintf("JSON marshal error: %v", err),
			"data":    nil,
		}
		errorBytes, _ := json.Marshal(errorResponse)
		return js.Global().Get("JSON").Call("parse", string(errorBytes))
	}

	return js.Global().Get("JSON").Call("parse", string(responseBytes))
}
