syntax = "proto3";

package lilbattle.v1;
import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

option go_package = "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/models";

// User and UsersService are now provided by goapplib.v1
// Import from github.com/panyam/goapplib/gen/go/goapplib/v1

message IndexInfo {
  // We maintain an IndexInfo for each type of "indexing" operation needed
  // For example one update may change the keywords (so we need to update indexes for search)
  // Another might update the "units" so we may need a new screenshot
  // Each one's updates - updated and indexed timestamps separately so they can be tracked sepately
  google.protobuf.Timestamp last_updated_at = 1;
  google.protobuf.Timestamp last_indexed_at = 2;
  bool needs_indexing = 3;
}

message Pagination {
  /**
   * Instead of an offset an abstract  "page" key is provided that offers
   * an opaque "pointer" into some offset in a result set.
   */
  string page_key = 1;

  /**
   * If a pagekey is not supported we can also support a direct integer offset
   * for cases where it makes sense.
   */
  int32 page_offset = 2;

  /**
   * Number of results to return.
   */
  int32 page_size = 3;
}

message PaginationResponse {
  /**
   * The key/pointer string that subsequent List requests should pass to
   * continue the pagination.
   */
  string next_page_key = 2;

  /**
   * Also support an integer offset if possible
   */
  int32 next_page_offset = 3;

  /**
   * Whether theere are more results.
   */
  bool has_more = 4;

  /**
   * Total number of results.
   */
  int32 total_results = 5;
}

///////// World related models

message World {
  google.protobuf.Timestamp created_at = 1;
  google.protobuf.Timestamp updated_at = 2;

  // Version for Optimistic concurrent locking
  int64 version = 3;

  // Unique ID for the world
  string id = 4;

  // User that created the world
  string creator_id = 5;

  // Name if items have names
  string name = 6;

  // Description if world has a description
  string description = 7;

  // Some tags
  repeated string tags = 8;

  // A possible image url
  string image_url = 9;

  // Difficulty - example attribute
  string difficulty = 10;

  // The actual world contents/data
  // WorldData world_data = 10;

  // URL to screenshot/preview image (defaults to /worlds/{id}/screenshots/{screenshotName})
  // Can be overridden to point to CDN or external hosting
  repeated string preview_urls = 11;

  // Default game configs
  GameConfiguration default_game_config = 12;

  IndexInfo search_index_info = 13;
}

message WorldData {
  // New map-based storage (key = "q,r" coordinate string)
  map<string, Tile> tiles_map = 1;
  map<string, Unit> units_map = 2;

  // When this world data was updated (may have happened without world updating)
  IndexInfo screenshot_index_info = 3;

  // We will only update if hash's are different
  string content_hash = 4;

  // Version for Optimistic concurrent locking
  int64 version = 5;

  // Improvement layer - crossings (roads on land, bridges on water)
  map<string, Crossing> crossings = 8;  // key = "q,r", value = crossing with connectivity
}

// Crossing types for terrain improvements (roads on land, bridges on water)
enum CrossingType {
  CROSSING_TYPE_UNSPECIFIED = 0;
  CROSSING_TYPE_ROAD = 1;     // Road on land terrain
  CROSSING_TYPE_BRIDGE = 2;   // Bridge over water terrain
}

// Crossing with explicit connectivity data
// Each crossing stores which of its 6 hex neighbors it connects to
message Crossing {
  CrossingType type = 1;
  // 6 booleans for hex neighbors in order matching AxialNeighborDeltas:
  // 0: LEFT (-1,0), 1: TOP_LEFT (0,-1), 2: TOP_RIGHT (1,-1),
  // 3: RIGHT (1,0), 4: BOTTOM_RIGHT (0,1), 5: BOTTOM_LEFT (-1,1)
  repeated bool connects_to = 2;
}

message Tile {
  // Q and R in Cubed coordinates
  int32 q = 1;
  int32 r = 2;
  int32 tile_type = 3; // Tile type

  // Whether the tile itself belongs to a player
  int32 player = 4;
  string shortcut = 5;  // A short cut like A1 or S2 etc for quick access

  // Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
  // This helps us not having to "top up" or "reset" the stats at the end
  // of each turn.  Instead as the game turn is incremented we can do a 
  // lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
  // So we just have to increment the game_turn and the unit is automaticaly flagged as
  // needing a top up of its health/balance/movement etc
  int32 last_acted_turn = 6;      // Which turn this unit was created/last acted on (ie movemade)
  int32 last_toppedup_turn = 7;   // When the last top up happened
}

message Unit {
  // Q and R in Cubed coordinates
  int32 q = 1;
  int32 r = 2;
  int32 player = 3;
  int32 unit_type = 4;
  string shortcut = 5;  // A short cut like A1 or S2 etc for quick access
  
  // Runtime state fields
  int32 available_health = 6; // Current health points
  double distance_left = 7;    // Movement points remaining this turn

  // Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
  // This helps us not having to "top up" or "reset" the stats at the end
  // of each turn.  Instead as the game turn is incremented we can do a 
  // lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
  // So we just have to increment the game_turn and the unit is automaticaly flagged as
  // needing a top up of its health/balance/movement etc
  int32 last_acted_turn = 8;      // Which turn this unit was created/last acted on (ie movemade)
  int32 last_toppedup_turn = 9;   // When the last top up happened

  // Details around wound bonus tracking for this turn
  int32 attacks_received_this_turn = 10;    // Total number of attacks received this turn
  repeated AttackRecord attack_history = 11; // Detailed attack history for wound bonus calculation

  // Action progression tracking - index into UnitDefinition.action_order
  // Indicates which step in the action sequence the unit is currently on
  // Reset to 0 at turn start via TopUpUnitIfNeeded()
  int32 progression_step = 12;

  // When current step has pipe-separated alternatives (e.g., "attack|capture"),
  // this tracks which alternative the user chose, preventing switching mid-step
  // Cleared when advancing to next step
  string chosen_alternative = 13;

  // Turn when this unit started capturing a building (0 = not capturing)
  // Capture completes at the start of the capturing player's next turn
  // if the unit is still alive on the tile
  int32 capture_started_turn = 14;
}

message AttackRecord {
  int32 q = 1;    // Attacker's Q coordinate
  int32 r = 2;    // Attacker's R coordinate
  bool is_ranged = 3; // Whether attacker is ranged 2+ tiles away
  int32 turn_number = 4; // Which turn this attack occured
}

///////// Rules Engine Definitions

// Terrain type classification - used for gameplay logic
enum TerrainType {
  TERRAIN_TYPE_UNSPECIFIED = 0;
  TERRAIN_TYPE_CITY = 1;      // Player-owned structures (bases, hospitals, etc.)
  TERRAIN_TYPE_NATURE = 2;    // Neutral natural terrain (grass, mountains, etc.)
  TERRAIN_TYPE_BRIDGE = 3;    // Bridge crossings
  TERRAIN_TYPE_WATER = 4;     // Water tiles
  TERRAIN_TYPE_ROAD = 5;      // Road tiles
}

// Rules engine terrain definition
message TerrainDefinition {
  int32 id = 1;                  // Terrain type ID
  string name = 2;               // Display name (e.g., "Grass", "Mountain")  
  // double base_move_cost = 3;     // Base movement cost
  // double defense_bonus = 4;      // Defense bonus multiplier (0.0 to 1.0)
  int32 type = 5;               // Terrain category type
  string description = 6;        // Human-readable description

  // How this terrain impacts 
  map<int32, TerrainUnitProperties> unit_properties = 7;

  // List of units that can be built on this terrain
  repeated int32 buildable_unit_ids = 8;

  int32 income_per_turn = 9;
}

// Rules engine unit definition  
message UnitDefinition {
  int32 id = 1;                  // Unit type ID
  string name = 2;               // Display name (e.g., "Infantry", "Tank")
  string description = 3;        //
  int32 health = 4;              // Maximum health points
  int32 coins = 5;               // how much it costs to build
  double movement_points = 6;    // Maximum movement per turn
  double retreat_points = 7;    // Movement points available after attacking
  int32 defense = 8;             // Base defense value
  int32 attack_range = 9;        // Max Attack range in tiles
  int32 min_attack_range = 10;    // Minimum attack range in tile radius if specified (otherwise - will be 1
  int32 splash_damage = 11;      // Splash damage amount
  map<int32, TerrainUnitProperties> terrain_properties = 12;
  repeated string properties = 13; // Special properties/abilities

  // Unit classification for attack calculations
  string unit_class = 14;        // "Light", "Heavy", or "Stealth"
  string unit_terrain = 15;      // "Air", "Land", or "Water"

  // Attack table: base attack values against different unit classes
  // Key format: "Light:Air", "Heavy:Land", "Stealth:Water", etc.
  // Value 0 or missing key means "n/a" (cannot attack)
  map<string, int32> attack_vs_class = 16;

  // Ordered list of allowed actions this turn
  // Examples:
  //   ["move", "attack"] - can move then attack
  //   ["move", "attack|capture"] - can move then either attack or capture
  //   ["attack"] - can only attack (no movement)
  // Default if empty: ["move", "attack|capture"]
  repeated string action_order = 17;

  // How many times each action type can be performed per turn
  // Key: action name, Value: max count
  // Example: {"attack": 2} means can attack twice
  // Default if not specified: 1 per action type
  map<string, int32> action_limits = 18;

  // Fix value for units that can repair other units (Medic, Engineer, etc.)
  // Used in fix calculation: p = 0.05 * fix_value
  // Default 0 means unit cannot fix
  int32 fix_value = 19;
}

// Properties that are specific to unit on a particular terrain
message TerrainUnitProperties {
  int32 terrain_id = 1;  // Renamed from tile_id for clarity
  int32 unit_id = 2;
  double movement_cost = 3;          // Movement cost for this unit on this terrain
  int32 healing_bonus = 4;           // How much healing per turn this tile would offer this unit
  bool can_build = 5;                // Whether this particular terrain can build this given unit
  bool can_capture = 6;              // Whether this particular unit can capture this terrain/building type
  int32 attack_bonus = 7;            // How much more attack this terrain gives to this unit
  int32 defense_bonus = 8;           // How much more defense this terrain gives to this unit
  int32 attack_range = 9;             // Max Attack range in tiles
  int32 min_attack_range = 10;        // Minimum attack range in tile radius if specified (otherwise - will be 1
}

// Properties for unit-vs-unit combat interactions
message UnitUnitProperties {
  int32 attacker_id = 1;
  int32 defender_id = 2;
  optional int32 attack_override = 3;    // Optional attack override for this Attacker/Defender combo
  optional int32 defense_override = 4;   // Optional defense override for this Attacker/Defender combo

  DamageDistribution damage = 5;
}

// Damage distribution for combat calculations
message DamageDistribution {
  double min_damage = 1;
  double max_damage = 2;
  double expected_damage = 3;
  repeated DamageRange ranges = 4;
}

message DamageRange {
  double min_value = 1;
  double max_value = 2;
  double probability = 3;
}

// Main rules engine definition - centralized source of truth
message RulesEngine {
  // Core entity definitions
  map<int32, UnitDefinition> units = 1;
  map<int32, TerrainDefinition> terrains = 2;

  // Centralized property definitions (source of truth)
  // Key format: "terrain_id:unit_id" (e.g., "1:3" for terrain 1, unit 3)
  map<string, TerrainUnitProperties> terrain_unit_properties = 3;

  // Key format: "attacker_id:defender_id" (e.g., "1:2" for unit 1 attacking unit 2)
  map<string, UnitUnitProperties> unit_unit_properties = 4;

  // Terrain type classifications (terrain_id -> TerrainType)
  // Used to determine if a terrain is city, nature, bridge, water, or road
  map<int32, TerrainType> terrain_types = 5;
}

///////// Game related models
//
enum GameStatus {
	GAME_STATUS_UNSPECIFIED = 0;
	GAME_STATUS_PLAYING = 1;
	GAME_STATUS_PAUSED = 2;
	GAME_STATUS_ENDED = 3;
}

// Describes a game and its metadata
message Game {
  google.protobuf.Timestamp created_at = 1;
  google.protobuf.Timestamp updated_at = 2;

  // Version number for optimistic locking
  int64 version = 3;

  // Unique ID for the game
  string id = 4;

  // User who started/created the game
  string creator_id = 5;

  // The world this game was created from
  string world_id = 6;

  // Name if items have names
  string name = 7;

  // Description if game has a description
  string description = 8;

  // Some tags
  repeated string tags = 9;

  // A possible image url
  string image_url = 10;

  // Difficulty - example attribute
  string difficulty = 11;

  // Game configuration
  GameConfiguration config = 12;

  // URL to screenshot/preview image (defaults to /games/{id}/screenshots/{screenshotName})
  // Can be overridden to point to CDN or external hosting
  repeated string preview_urls = 13;

  IndexInfo search_index_info = 15;
}

message GameConfiguration {
  // Player configuration
  repeated GamePlayer players = 1;

  // Team configuration
  repeated GameTeam teams = 2;

  // Various kinds of per turn income configs
  IncomeConfig income_configs = 3;

  // Game settings
  GameSettings settings = 4;
}

message IncomeConfig {
  // How much starting coins to give each player at the start of the agme
  int32 starting_coins = 1;

  // Income each player just for being in the game each turn
  int32 game_income = 2;

  // Income from each landbase per turn
  int32 landbase_income = 3;

  // Income from each navalbase per turn
  int32 navalbase_income = 4;

  // Income from each airport base per turn
  int32 airportbase_income = 5;

  // Income from each missile silo per turn
  int32 missilesilo_income = 6;

  // Income from each mine per turn
  int32 mines_income = 7;
}

message GamePlayer {
  // Player ID (1-based)
  int32 player_id = 1;

  // ID of the system user that is assigned to this game player.  This is the "auth" user
  string user_id = 2;

  // Player type
  string player_type = 3; // "human", "ai", "open"

  // Player color
  string color = 4;

  // Team ID (0 = no team, 1+ = team number)
  int32 team_id = 5;

  // Nickname for the player in this game
  string name = 6;

  // Whether play is still in the game - can this just be inferred?
  bool is_active = 7;

  // How many coins the player started off with
  int32 starting_coins = 8;

  // Player's current money/coins balance for building units
  // int32 coins = 9;
}

message GameTeam {
  // ID of the team within the game (unique to the game)
  int32 team_id = 1;

  // Name of the team - in a game
  string name = 2;

  // Just a color for this team
  string color = 3;

  // Whether team has active players - can also be inferred
  bool is_active = 4;
}

message GameSettings {
  // List of allowed unit type IDs
  repeated int32 allowed_units = 1;

  // Turn time limit in seconds (0 = no limit)
  int32 turn_time_limit = 2;

  // Team mode
  string team_mode = 3; // "ffa" or "teams"

  // Maximum number of turns (0 = unlimited)
  int32 max_turns = 4;
}

// Runtime state for a player during the game
// This is separate from GamePlayer (which is player configuration)
// PlayerState is indexed by player_id in the player_states map
message PlayerState {
  // Current coin balance (changes during gameplay via building, income, etc.)
  int32 coins = 1;

  // Whether player is still active in the game (not eliminated)
  bool is_active = 2;
}

// Holds the game's Active/Current state (eg world state)
message GameState {
  google.protobuf.Timestamp updated_at = 2;

  // ID of the game whos state is being tracked
  string game_id = 3;

  int32 turn_counter = 4;

  int32 current_player = 5;

  // Current world state
  WorldData world_data = 6;

  // Proposal tracking for multiplayer coordination (from TurnEngine)
  // turnengine.v1.ProposalTrackingInfo proposal_info = 7;

  // Current state hash for validation
  string state_hash = 8;

  // Version number for optimistic locking
  int64 version = 9;

  GameStatus status = 10;

  // Only set after a win has been possible
  bool finished = 11;
  int32 winning_player = 12;
  int32 winning_team = 13;

  int64 current_group_number = 14;

  // Per-player runtime state, keyed by player_id (1-based)
  // This holds mutable player state like coins that changes during gameplay
  map<int32, PlayerState> player_states = 15;
}

// Holds the game's move history (can be used as a replay log)
message GameMoveHistory {
  // Move history for the game
  string game_id = 1;

  // Each entry in our history is a "group" of moves
  repeated GameMoveGroup groups = 2;
}

// A move group - we can allow X moves in one "tick"
message GameMoveGroup {
  // When the moves happened (or were submitted)
  google.protobuf.Timestamp started_at = 2;
  google.protobuf.Timestamp ended_at = 3;

  // Group number within the game - will be monotonically increasing
  int64 group_number = 4;

  /**
   * List of moves to add - 
   */
  repeated GameMove moves = 5;
}

/**
 * Represents a single move which can be one of many actions in the game
 */
message GameMove {
	int32 player = 1; // The player making the move

  // Generated by the server
  int64 group_number = 2;

  // Generated by the server - will be monotonically increasing within the group
  int64 move_number = 3;

  google.protobuf.Timestamp timestamp = 4;

  oneof move_type {
    MoveUnitAction move_unit = 5;
    AttackUnitAction attack_unit = 6;
    EndTurnAction end_turn = 7;
    BuildUnitAction build_unit = 8;
    CaptureBuildingAction capture_building = 13;
    HealUnitAction heal_unit = 14;
    FixUnitAction fix_unit = 15;
  }

  // A monotonically increasing and unique (within the game) sequence number for the move
  // This is generated by the server
  int64 sequence_num = 9;

  // Whether the result is permenant and can be undone.
  // Just moving a unit for example is not permanent, but attacking a unit
  // would be (ie a player cannot undo it).  This is also determined by the server/validator
  bool is_permanent = 10;

  /*
   * The corresponding "result" for the move.  This can be "proposed" or can be evaluated.
   * Keeping this colocated with the Move for consistency and simplicity
   */
  repeated WorldChange changes = 11;

  // Human redable description for say recording "commands" if any
  string description = 12;
}

// A unified "Position" type that can be used to 
// specify locations via "string shortcuts" like A1, "3,2", "r2,4" (for row/col)
// or even "relative" positions like "L,TL,TR,R"  in the shortcut field.
// Or string q/r coordinates in the q and r fields.  This can also be used 
// in the "response" to resolve a shortcut -> q,r
message Position {
  string label = 1;
  int32 q = 2;
  int32 r = 3;
}

/**
 * Move unit from one position to another
 */
message MoveUnitAction {
  Position from = 1;
  Position to = 2;

  // Optional fields that can be used for showing move options as well as debugging
  double movement_cost = 3;

  // Debug fields
  Path reconstructed_path = 4;
}

/**
 * Attack with one unit against another
 */
message AttackUnitAction {
  Position attacker = 1;
  Position defender = 2;


  // Optional fields for presenting during "options" and debugging
  int32 target_unit_type = 7;
  int32 target_unit_health = 8;
  bool can_attack = 9;
  int32 damage_estimate = 10; // Estimated damage this attack would deal
}

/**
 * An action to build a unit (at a city tile)
 */
message BuildUnitAction {
  Position pos = 1;
  int32 unit_type = 2;
  int32 cost = 3;
}

/**
 * A move where a unit can capture a building
 */
message CaptureBuildingAction {
  Position pos = 1;
  int32 tile_type = 3;
}

/**
 * End current player's turn
 */
message EndTurnAction {
  // No additional fields needed
}

/**
 * Heal a unit - player manually chooses to heal instead of attacking/moving
 * Auto-healing at turn start is handled separately in TopUpUnitIfNeeded
 */
message HealUnitAction {
  Position pos = 1;           // Position of unit to heal
  int32 heal_amount = 2;      // Amount of health to restore
}

/**
 * Fix (repair) another friendly unit - used by Medic, Engineer, Stratotanker, Tugboat, Aircraft Carrier
 * The fixer must be adjacent to the target unit
 */
message FixUnitAction {
  Position fixer = 1;         // Position of the unit doing the fixing
  Position target = 2;        // Position of the friendly unit being fixed
  int32 fix_amount = 3;       // Amount of health to restore (optional, server calculates if not provided)
}

/**
 * Represents a change to the game world
 */
message WorldChange {
  // When did this change happen
  oneof change_type {
    UnitMovedChange unit_moved = 1;
    UnitDamagedChange unit_damaged = 2;
    UnitKilledChange unit_killed = 3;
    PlayerChangedChange player_changed = 4;
    UnitBuiltChange unit_built = 5;
    CoinsChangedChange coins_changed = 6;
    TileCapturedChange tile_captured = 7;
    CaptureStartedChange capture_started = 8;
    UnitHealedChange unit_healed = 9;
    UnitFixedChange unit_fixed = 10;
  }
}

/**
 * A unit was healed
 */
message UnitHealedChange {
  Unit previous_unit = 1;   // Unit state before healing
  Unit updated_unit = 2;    // Unit state after healing
  int32 heal_amount = 3;    // Amount healed
}

/**
 * A unit was fixed (repaired) by another unit
 */
message UnitFixedChange {
  Unit fixer_unit = 1;      // Unit that performed the fix
  Unit previous_target = 2; // Target unit state before fix
  Unit updated_target = 3;  // Target unit state after fix
  int32 fix_amount = 4;     // Amount of health restored
}

/**
 * A unit moved from one position to another
 */
message UnitMovedChange {
  // Complete unit state before the move
  Unit previous_unit = 6;
  // Complete unit state after the move (includes updated position, distanceLeft, etc.)
  Unit updated_unit = 7;
}

/**
 * A unit took damage
 */
message UnitDamagedChange {
  // Complete unit state before taking damage
  Unit previous_unit = 6;
  // Complete unit state after taking damage
  Unit updated_unit = 7;
}

/**
 * A unit was killed
 */
message UnitKilledChange {
  // Complete unit state before being killed
  Unit previous_unit = 6;
}

/**
 * Active player changed
 */
message PlayerChangedChange {
  int32 previous_player = 1;
  int32 new_player = 2;
  int32 previous_turn = 3;
  int32 new_turn = 4;
  // Units that had their movement/health reset for the new turn
  repeated Unit reset_units = 5;
}

/**
 * A new unit was built at a tile
 */
message UnitBuiltChange {
  // The newly created unit
  Unit unit = 1;
  // Tile coordinates where unit was built
  int32 tile_q = 2;
  int32 tile_r = 3;
  // Cost in coins
  int32 coins_cost = 4;
  // Player's remaining coins after build
  int32 player_coins = 5;
}

/**
 * A player's coin balance changed
 */
message CoinsChangedChange {
  // Which player's coins changed
  int32 player_id = 1;
  // Previous coin balance
  int32 previous_coins = 2;
  // New coin balance
  int32 new_coins = 3;
  // Reason for change: "build", "income", "repair", etc.
  string reason = 4;
}

/**
 * A tile was captured by a unit
 */
message TileCapturedChange {
  // The unit that captured the tile
  Unit capturing_unit = 1;
  // Tile coordinates
  int32 tile_q = 2;
  int32 tile_r = 3;
  // Tile type
  int32 tile_type = 4;
  // Previous owner (0 for neutral)
  int32 previous_owner = 5;
  // New owner
  int32 new_owner = 6;
}

/**
 * A unit started capturing a building (capture not yet complete)
 */
message CaptureStartedChange {
  // The unit starting the capture
  Unit capturing_unit = 1;
  // Tile coordinates
  int32 tile_q = 2;
  int32 tile_r = 3;
  // Tile type
  int32 tile_type = 4;
  // Current owner (0 for neutral)
  int32 current_owner = 5;
}

// Compact representation of all reachable paths from a source
message AllPaths {
  // Starting coordinate for all paths
  int32 source_q = 1;
  int32 source_r = 2;
  
  // Map of edges: key is "toQ,toR" for quick parent lookup
  // Each edge represents the optimal way to reach 'to' from its parent
  map<string, PathEdge> edges = 3;
}

// A single edge in a path with movement details
message PathEdge {
  int32 from_q = 1;            // Parent coordinate Q
  int32 from_r = 2;            // Parent coordinate R
  int32 to_q = 3;              // Destination coordinate Q
  int32 to_r = 4;              // Destination coordinate R
  double movement_cost = 5;     // Cost to move from 'from' to 'to' (edge cost)
  double total_cost = 6;        // Total cumulative cost from source to 'to'
  string terrain_type = 7;     // e.g., "mountain", "plains", "forest"
  string explanation = 8;      // e.g., "Mountain costs Soldier 4 movement points"
  bool is_occupied = 9;        // True if destination tile has a friendly unit (pass-through only, cannot land)
}

// Full path from source to destination (constructed on-demand from AllPaths)
message Path {
  // Edges in order from source to destination
  repeated PathEdge edges = 1;

  // len(directions) = len(edges) - 1
  // and directions[i] = direction from edge[i - 1] -> edge[i]
  repeated PathDirection directions = 2;

  // Sum of all edge costs
  double total_cost = 3;
}

enum PathDirection {
  PATH_DIRECTION_UNSPECIFIED = 0;
	PATH_DIRECTION_LEFT = 1;
	PATH_DIRECTION_TOP_LEFT = 2;
	PATH_DIRECTION_TOP_RIGHT = 3;
	PATH_DIRECTION_RIGHT = 4;
	PATH_DIRECTION_BOTTOM_RIGHT = 5;
	PATH_DIRECTION_BOTTOM_LEFT = 6;
}
