// @generated by protoc-gen-es v2.9.0 with parameter "target=ts"
// @generated from file weewar/v1/models/models.proto (package weewar.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file weewar/v1/models/models.proto.
 */
export const file_weewar_v1_models_models: GenFile = /*@__PURE__*/
  fileDesc("Ch13ZWV3YXIvdjEvbW9kZWxzL21vZGVscy5wcm90bxIJd2Vld2FyLnYxIo0BCglJbmRleEluZm8SMwoPbGFzdF91cGRhdGVkX2F0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIzCg9sYXN0X2luZGV4ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhYKDm5lZWRzX2luZGV4aW5nGAMgASgIIsoBCgRVc2VyEi4KCmNyZWF0ZWRfYXQYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnVwZGF0ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEgoKAmlkGAMgASgJEgwKBG5hbWUYBCABKAkSEwoLZGVzY3JpcHRpb24YBSABKAkSDAoEdGFncxgGIAMoCRIRCglpbWFnZV91cmwYByABKAkSEgoKZGlmZmljdWx0eRgIIAEoCSJGCgpQYWdpbmF0aW9uEhAKCHBhZ2Vfa2V5GAEgASgJEhMKC3BhZ2Vfb2Zmc2V0GAIgASgFEhEKCXBhZ2Vfc2l6ZRgDIAEoBSJuChJQYWdpbmF0aW9uUmVzcG9uc2USFQoNbmV4dF9wYWdlX2tleRgCIAEoCRIYChBuZXh0X3BhZ2Vfb2Zmc2V0GAMgASgFEhAKCGhhc19tb3JlGAQgASgIEhUKDXRvdGFsX3Jlc3VsdHMYBSABKAUi8gIKBVdvcmxkEi4KCmNyZWF0ZWRfYXQYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnVwZGF0ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg8KB3ZlcnNpb24YAyABKAMSCgoCaWQYBCABKAkSEgoKY3JlYXRvcl9pZBgFIAEoCRIMCgRuYW1lGAYgASgJEhMKC2Rlc2NyaXB0aW9uGAcgASgJEgwKBHRhZ3MYCCADKAkSEQoJaW1hZ2VfdXJsGAkgASgJEhIKCmRpZmZpY3VsdHkYCiABKAkSFAoMcHJldmlld191cmxzGAsgAygJEjkKE2RlZmF1bHRfZ2FtZV9jb25maWcYDCABKAsyHC53ZWV3YXIudjEuR2FtZUNvbmZpZ3VyYXRpb24SLwoRc2VhcmNoX2luZGV4X2luZm8YDSABKAsyFC53ZWV3YXIudjEuSW5kZXhJbmZvItgDCglXb3JsZERhdGESNQoJdGlsZXNfbWFwGAEgAygLMiIud2Vld2FyLnYxLldvcmxkRGF0YS5UaWxlc01hcEVudHJ5EjUKCXVuaXRzX21hcBgCIAMoCzIiLndlZXdhci52MS5Xb3JsZERhdGEuVW5pdHNNYXBFbnRyeRIzChVzY3JlZW5zaG90X2luZGV4X2luZm8YAyABKAsyFC53ZWV3YXIudjEuSW5kZXhJbmZvEhQKDGNvbnRlbnRfaGFzaBgEIAEoCRIPCgd2ZXJzaW9uGAUgASgDEjYKCWNyb3NzaW5ncxgIIAMoCzIjLndlZXdhci52MS5Xb3JsZERhdGEuQ3Jvc3NpbmdzRW50cnkaQAoNVGlsZXNNYXBFbnRyeRILCgNrZXkYASABKAkSHgoFdmFsdWUYAiABKAsyDy53ZWV3YXIudjEuVGlsZToCOAEaQAoNVW5pdHNNYXBFbnRyeRILCgNrZXkYASABKAkSHgoFdmFsdWUYAiABKAsyDy53ZWV3YXIudjEuVW5pdDoCOAEaRQoOQ3Jvc3NpbmdzRW50cnkSCwoDa2V5GAEgASgJEiIKBXZhbHVlGAIgASgLMhMud2Vld2FyLnYxLkNyb3NzaW5nOgI4ASJGCghDcm9zc2luZxIlCgR0eXBlGAEgASgOMhcud2Vld2FyLnYxLkNyb3NzaW5nVHlwZRITCgtjb25uZWN0c190bxgCIAMoCCKGAQoEVGlsZRIJCgFxGAEgASgFEgkKAXIYAiABKAUSEQoJdGlsZV90eXBlGAMgASgFEg4KBnBsYXllchgEIAEoBRIQCghzaG9ydGN1dBgFIAEoCRIXCg9sYXN0X2FjdGVkX3R1cm4YBiABKAUSGgoSbGFzdF90b3BwZWR1cF90dXJuGAcgASgFIsICCgRVbml0EgkKAXEYASABKAUSCQoBchgCIAEoBRIOCgZwbGF5ZXIYAyABKAUSEQoJdW5pdF90eXBlGAQgASgFEhAKCHNob3J0Y3V0GAUgASgJEhgKEGF2YWlsYWJsZV9oZWFsdGgYBiABKAUSFQoNZGlzdGFuY2VfbGVmdBgHIAEoARIXCg9sYXN0X2FjdGVkX3R1cm4YCCABKAUSGgoSbGFzdF90b3BwZWR1cF90dXJuGAkgASgFEiIKGmF0dGFja3NfcmVjZWl2ZWRfdGhpc190dXJuGAogASgFEi8KDmF0dGFja19oaXN0b3J5GAsgAygLMhcud2Vld2FyLnYxLkF0dGFja1JlY29yZBIYChBwcm9ncmVzc2lvbl9zdGVwGAwgASgFEhoKEmNob3Nlbl9hbHRlcm5hdGl2ZRgNIAEoCSJMCgxBdHRhY2tSZWNvcmQSCQoBcRgBIAEoBRIJCgFyGAIgASgFEhEKCWlzX3JhbmdlZBgDIAEoCBITCgt0dXJuX251bWJlchgEIAEoBSKpAgoRVGVycmFpbkRlZmluaXRpb24SCgoCaWQYASABKAUSDAoEbmFtZRgCIAEoCRIMCgR0eXBlGAUgASgFEhMKC2Rlc2NyaXB0aW9uGAYgASgJEkkKD3VuaXRfcHJvcGVydGllcxgHIAMoCzIwLndlZXdhci52MS5UZXJyYWluRGVmaW5pdGlvbi5Vbml0UHJvcGVydGllc0VudHJ5EhoKEmJ1aWxkYWJsZV91bml0X2lkcxgIIAMoBRIXCg9pbmNvbWVfcGVyX3R1cm4YCSABKAUaVwoTVW5pdFByb3BlcnRpZXNFbnRyeRILCgNrZXkYASABKAUSLwoFdmFsdWUYAiABKAsyIC53ZWV3YXIudjEuVGVycmFpblVuaXRQcm9wZXJ0aWVzOgI4ASLbBQoOVW5pdERlZmluaXRpb24SCgoCaWQYASABKAUSDAoEbmFtZRgCIAEoCRITCgtkZXNjcmlwdGlvbhgDIAEoCRIOCgZoZWFsdGgYBCABKAUSDQoFY29pbnMYBSABKAUSFwoPbW92ZW1lbnRfcG9pbnRzGAYgASgBEhYKDnJldHJlYXRfcG9pbnRzGAcgASgBEg8KB2RlZmVuc2UYCCABKAUSFAoMYXR0YWNrX3JhbmdlGAkgASgFEhgKEG1pbl9hdHRhY2tfcmFuZ2UYCiABKAUSFQoNc3BsYXNoX2RhbWFnZRgLIAEoBRJMChJ0ZXJyYWluX3Byb3BlcnRpZXMYDCADKAsyMC53ZWV3YXIudjEuVW5pdERlZmluaXRpb24uVGVycmFpblByb3BlcnRpZXNFbnRyeRISCgpwcm9wZXJ0aWVzGA0gAygJEhIKCnVuaXRfY2xhc3MYDiABKAkSFAoMdW5pdF90ZXJyYWluGA8gASgJEkUKD2F0dGFja192c19jbGFzcxgQIAMoCzIsLndlZXdhci52MS5Vbml0RGVmaW5pdGlvbi5BdHRhY2tWc0NsYXNzRW50cnkSFAoMYWN0aW9uX29yZGVyGBEgAygJEkIKDWFjdGlvbl9saW1pdHMYEiADKAsyKy53ZWV3YXIudjEuVW5pdERlZmluaXRpb24uQWN0aW9uTGltaXRzRW50cnkaWgoWVGVycmFpblByb3BlcnRpZXNFbnRyeRILCgNrZXkYASABKAUSLwoFdmFsdWUYAiABKAsyIC53ZWV3YXIudjEuVGVycmFpblVuaXRQcm9wZXJ0aWVzOgI4ARo0ChJBdHRhY2tWc0NsYXNzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgFOgI4ARozChFBY3Rpb25MaW1pdHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAU6AjgBIu8BChVUZXJyYWluVW5pdFByb3BlcnRpZXMSEgoKdGVycmFpbl9pZBgBIAEoBRIPCgd1bml0X2lkGAIgASgFEhUKDW1vdmVtZW50X2Nvc3QYAyABKAESFQoNaGVhbGluZ19ib251cxgEIAEoBRIRCgljYW5fYnVpbGQYBSABKAgSEwoLY2FuX2NhcHR1cmUYBiABKAgSFAoMYXR0YWNrX2JvbnVzGAcgASgFEhUKDWRlZmVuc2VfYm9udXMYCCABKAUSFAoMYXR0YWNrX3JhbmdlGAkgASgFEhgKEG1pbl9hdHRhY2tfcmFuZ2UYCiABKAUi0wEKElVuaXRVbml0UHJvcGVydGllcxITCgthdHRhY2tlcl9pZBgBIAEoBRITCgtkZWZlbmRlcl9pZBgCIAEoBRIcCg9hdHRhY2tfb3ZlcnJpZGUYAyABKAVIAIgBARIdChBkZWZlbnNlX292ZXJyaWRlGAQgASgFSAGIAQESLQoGZGFtYWdlGAUgASgLMh0ud2Vld2FyLnYxLkRhbWFnZURpc3RyaWJ1dGlvbkISChBfYXR0YWNrX292ZXJyaWRlQhMKEV9kZWZlbnNlX292ZXJyaWRlIn0KEkRhbWFnZURpc3RyaWJ1dGlvbhISCgptaW5fZGFtYWdlGAEgASgBEhIKCm1heF9kYW1hZ2UYAiABKAESFwoPZXhwZWN0ZWRfZGFtYWdlGAMgASgBEiYKBnJhbmdlcxgEIAMoCzIWLndlZXdhci52MS5EYW1hZ2VSYW5nZSJICgtEYW1hZ2VSYW5nZRIRCgltaW5fdmFsdWUYASABKAESEQoJbWF4X3ZhbHVlGAIgASgBEhMKC3Byb2JhYmlsaXR5GAMgASgBIvkFCgtSdWxlc0VuZ2luZRIwCgV1bml0cxgBIAMoCzIhLndlZXdhci52MS5SdWxlc0VuZ2luZS5Vbml0c0VudHJ5EjYKCHRlcnJhaW5zGAIgAygLMiQud2Vld2FyLnYxLlJ1bGVzRW5naW5lLlRlcnJhaW5zRW50cnkSUgoXdGVycmFpbl91bml0X3Byb3BlcnRpZXMYAyADKAsyMS53ZWV3YXIudjEuUnVsZXNFbmdpbmUuVGVycmFpblVuaXRQcm9wZXJ0aWVzRW50cnkSTAoUdW5pdF91bml0X3Byb3BlcnRpZXMYBCADKAsyLi53ZWV3YXIudjEuUnVsZXNFbmdpbmUuVW5pdFVuaXRQcm9wZXJ0aWVzRW50cnkSPwoNdGVycmFpbl90eXBlcxgFIAMoCzIoLndlZXdhci52MS5SdWxlc0VuZ2luZS5UZXJyYWluVHlwZXNFbnRyeRpHCgpVbml0c0VudHJ5EgsKA2tleRgBIAEoBRIoCgV2YWx1ZRgCIAEoCzIZLndlZXdhci52MS5Vbml0RGVmaW5pdGlvbjoCOAEaTQoNVGVycmFpbnNFbnRyeRILCgNrZXkYASABKAUSKwoFdmFsdWUYAiABKAsyHC53ZWV3YXIudjEuVGVycmFpbkRlZmluaXRpb246AjgBGl4KGlRlcnJhaW5Vbml0UHJvcGVydGllc0VudHJ5EgsKA2tleRgBIAEoCRIvCgV2YWx1ZRgCIAEoCzIgLndlZXdhci52MS5UZXJyYWluVW5pdFByb3BlcnRpZXM6AjgBGlgKF1VuaXRVbml0UHJvcGVydGllc0VudHJ5EgsKA2tleRgBIAEoCRIsCgV2YWx1ZRgCIAEoCzIdLndlZXdhci52MS5Vbml0VW5pdFByb3BlcnRpZXM6AjgBGksKEVRlcnJhaW5UeXBlc0VudHJ5EgsKA2tleRgBIAEoBRIlCgV2YWx1ZRgCIAEoDjIWLndlZXdhci52MS5UZXJyYWluVHlwZToCOAEi9gIKBEdhbWUSLgoKY3JlYXRlZF9hdBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDwoHdmVyc2lvbhgDIAEoAxIKCgJpZBgEIAEoCRISCgpjcmVhdG9yX2lkGAUgASgJEhAKCHdvcmxkX2lkGAYgASgJEgwKBG5hbWUYByABKAkSEwoLZGVzY3JpcHRpb24YCCABKAkSDAoEdGFncxgJIAMoCRIRCglpbWFnZV91cmwYCiABKAkSEgoKZGlmZmljdWx0eRgLIAEoCRIsCgZjb25maWcYDCABKAsyHC53ZWV3YXIudjEuR2FtZUNvbmZpZ3VyYXRpb24SFAoMcHJldmlld191cmxzGA0gAygJEi8KEXNlYXJjaF9pbmRleF9pbmZvGA8gASgLMhQud2Vld2FyLnYxLkluZGV4SW5mbyK7AQoRR2FtZUNvbmZpZ3VyYXRpb24SJgoHcGxheWVycxgBIAMoCzIVLndlZXdhci52MS5HYW1lUGxheWVyEiIKBXRlYW1zGAIgAygLMhMud2Vld2FyLnYxLkdhbWVUZWFtEi8KDmluY29tZV9jb25maWdzGAMgASgLMhcud2Vld2FyLnYxLkluY29tZUNvbmZpZxIpCghzZXR0aW5ncxgEIAEoCzIXLndlZXdhci52MS5HYW1lU2V0dGluZ3MivAEKDEluY29tZUNvbmZpZxIWCg5zdGFydGluZ19jb2lucxgBIAEoBRITCgtnYW1lX2luY29tZRgCIAEoBRIXCg9sYW5kYmFzZV9pbmNvbWUYAyABKAUSGAoQbmF2YWxiYXNlX2luY29tZRgEIAEoBRIaChJhaXJwb3J0YmFzZV9pbmNvbWUYBSABKAUSGgoSbWlzc2lsZXNpbG9faW5jb21lGAYgASgFEhQKDG1pbmVzX2luY29tZRgHIAEoBSKcAQoKR2FtZVBsYXllchIRCglwbGF5ZXJfaWQYASABKAUSEwoLcGxheWVyX3R5cGUYAiABKAkSDQoFY29sb3IYAyABKAkSDwoHdGVhbV9pZBgEIAEoBRIMCgRuYW1lGAUgASgJEhEKCWlzX2FjdGl2ZRgGIAEoCBIWCg5zdGFydGluZ19jb2lucxgHIAEoBRINCgVjb2lucxgIIAEoBSJLCghHYW1lVGVhbRIPCgd0ZWFtX2lkGAEgASgFEgwKBG5hbWUYAiABKAkSDQoFY29sb3IYAyABKAkSEQoJaXNfYWN0aXZlGAQgASgIImQKDEdhbWVTZXR0aW5ncxIVCg1hbGxvd2VkX3VuaXRzGAEgAygFEhcKD3R1cm5fdGltZV9saW1pdBgCIAEoBRIRCgl0ZWFtX21vZGUYAyABKAkSEQoJbWF4X3R1cm5zGAQgASgFIrACCglHYW1lU3RhdGUSLgoKdXBkYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDwoHZ2FtZV9pZBgDIAEoCRIUCgx0dXJuX2NvdW50ZXIYBCABKAUSFgoOY3VycmVudF9wbGF5ZXIYBSABKAUSKAoKd29ybGRfZGF0YRgGIAEoCzIULndlZXdhci52MS5Xb3JsZERhdGESEgoKc3RhdGVfaGFzaBgIIAEoCRIPCgd2ZXJzaW9uGAkgASgDEiUKBnN0YXR1cxgKIAEoDjIVLndlZXdhci52MS5HYW1lU3RhdHVzEhAKCGZpbmlzaGVkGAsgASgIEhYKDndpbm5pbmdfcGxheWVyGAwgASgFEhQKDHdpbm5pbmdfdGVhbRgNIAEoBSJMCg9HYW1lTW92ZUhpc3RvcnkSDwoHZ2FtZV9pZBgBIAEoCRIoCgZncm91cHMYAiADKAsyGC53ZWV3YXIudjEuR2FtZU1vdmVHcm91cCKRAQoNR2FtZU1vdmVHcm91cBIuCgpzdGFydGVkX2F0GAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghlbmRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASIgoFbW92ZXMYBCADKAsyEy53ZWV3YXIudjEuR2FtZU1vdmUi7wIKCEdhbWVNb3ZlEg4KBnBsYXllchgBIAEoBRItCgl0aW1lc3RhbXAYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCW1vdmVfdW5pdBgEIAEoCzIZLndlZXdhci52MS5Nb3ZlVW5pdEFjdGlvbkgAEjIKC2F0dGFja191bml0GAUgASgLMhsud2Vld2FyLnYxLkF0dGFja1VuaXRBY3Rpb25IABIsCghlbmRfdHVybhgGIAEoCzIYLndlZXdhci52MS5FbmRUdXJuQWN0aW9uSAASMAoKYnVpbGRfdW5pdBgHIAEoCzIaLndlZXdhci52MS5CdWlsZFVuaXRBY3Rpb25IABIUCgxzZXF1ZW5jZV9udW0YCCABKAMSFAoMaXNfcGVybWFuZW50GAkgASgIEicKB2NoYW5nZXMYCiADKAsyFi53ZWV3YXIudjEuV29ybGRDaGFuZ2VCCwoJbW92ZV90eXBlIpABCg5Nb3ZlVW5pdEFjdGlvbhIOCgZmcm9tX3EYASABKAUSDgoGZnJvbV9yGAIgASgFEgwKBHRvX3EYAyABKAUSDAoEdG9fchgEIAEoBRIVCg1tb3ZlbWVudF9jb3N0GAUgASgBEisKEnJlY29uc3RydWN0ZWRfcGF0aBgGIAEoCzIPLndlZXdhci52MS5QYXRoIsUBChBBdHRhY2tVbml0QWN0aW9uEhIKCmF0dGFja2VyX3EYASABKAUSEgoKYXR0YWNrZXJfchgCIAEoBRISCgpkZWZlbmRlcl9xGAMgASgFEhIKCmRlZmVuZGVyX3IYBCABKAUSGAoQdGFyZ2V0X3VuaXRfdHlwZRgFIAEoBRIaChJ0YXJnZXRfdW5pdF9oZWFsdGgYBiABKAUSEgoKY2FuX2F0dGFjaxgHIAEoCBIXCg9kYW1hZ2VfZXN0aW1hdGUYCCABKAUiSAoPQnVpbGRVbml0QWN0aW9uEgkKAXEYASABKAUSCQoBchgCIAEoBRIRCgl1bml0X3R5cGUYAyABKAUSDAoEY29zdBgEIAEoBSJAChVDYXB0dXJlQnVpbGRpbmdBY3Rpb24SCQoBcRgBIAEoBRIJCgFyGAIgASgFEhEKCXRpbGVfdHlwZRgDIAEoBSIPCg1FbmRUdXJuQWN0aW9uItwCCgtXb3JsZENoYW5nZRIwCgp1bml0X21vdmVkGAEgASgLMhoud2Vld2FyLnYxLlVuaXRNb3ZlZENoYW5nZUgAEjQKDHVuaXRfZGFtYWdlZBgCIAEoCzIcLndlZXdhci52MS5Vbml0RGFtYWdlZENoYW5nZUgAEjIKC3VuaXRfa2lsbGVkGAMgASgLMhsud2Vld2FyLnYxLlVuaXRLaWxsZWRDaGFuZ2VIABI4Cg5wbGF5ZXJfY2hhbmdlZBgEIAEoCzIeLndlZXdhci52MS5QbGF5ZXJDaGFuZ2VkQ2hhbmdlSAASMAoKdW5pdF9idWlsdBgFIAEoCzIaLndlZXdhci52MS5Vbml0QnVpbHRDaGFuZ2VIABI2Cg1jb2luc19jaGFuZ2VkGAYgASgLMh0ud2Vld2FyLnYxLkNvaW5zQ2hhbmdlZENoYW5nZUgAQg0KC2NoYW5nZV90eXBlImAKD1VuaXRNb3ZlZENoYW5nZRImCg1wcmV2aW91c191bml0GAYgASgLMg8ud2Vld2FyLnYxLlVuaXQSJQoMdXBkYXRlZF91bml0GAcgASgLMg8ud2Vld2FyLnYxLlVuaXQiYgoRVW5pdERhbWFnZWRDaGFuZ2USJgoNcHJldmlvdXNfdW5pdBgGIAEoCzIPLndlZXdhci52MS5Vbml0EiUKDHVwZGF0ZWRfdW5pdBgHIAEoCzIPLndlZXdhci52MS5Vbml0IjoKEFVuaXRLaWxsZWRDaGFuZ2USJgoNcHJldmlvdXNfdW5pdBgGIAEoCzIPLndlZXdhci52MS5Vbml0IpEBChNQbGF5ZXJDaGFuZ2VkQ2hhbmdlEhcKD3ByZXZpb3VzX3BsYXllchgBIAEoBRISCgpuZXdfcGxheWVyGAIgASgFEhUKDXByZXZpb3VzX3R1cm4YAyABKAUSEAoIbmV3X3R1cm4YBCABKAUSJAoLcmVzZXRfdW5pdHMYBSADKAsyDy53ZWV3YXIudjEuVW5pdCJ6Cg9Vbml0QnVpbHRDaGFuZ2USHQoEdW5pdBgBIAEoCzIPLndlZXdhci52MS5Vbml0Eg4KBnRpbGVfcRgCIAEoBRIOCgZ0aWxlX3IYAyABKAUSEgoKY29pbnNfY29zdBgEIAEoBRIUCgxwbGF5ZXJfY29pbnMYBSABKAUiYgoSQ29pbnNDaGFuZ2VkQ2hhbmdlEhEKCXBsYXllcl9pZBgBIAEoBRIWCg5wcmV2aW91c19jb2lucxgCIAEoBRIRCgluZXdfY29pbnMYAyABKAUSDgoGcmVhc29uGAQgASgJIqABCghBbGxQYXRocxIQCghzb3VyY2VfcRgBIAEoBRIQCghzb3VyY2VfchgCIAEoBRItCgVlZGdlcxgDIAMoCzIeLndlZXdhci52MS5BbGxQYXRocy5FZGdlc0VudHJ5GkEKCkVkZ2VzRW50cnkSCwoDa2V5GAEgASgJEiIKBXZhbHVlGAIgASgLMhMud2Vld2FyLnYxLlBhdGhFZGdlOgI4ASKcAQoIUGF0aEVkZ2USDgoGZnJvbV9xGAEgASgFEg4KBmZyb21fchgCIAEoBRIMCgR0b19xGAMgASgFEgwKBHRvX3IYBCABKAUSFQoNbW92ZW1lbnRfY29zdBgFIAEoARISCgp0b3RhbF9jb3N0GAYgASgBEhQKDHRlcnJhaW5fdHlwZRgHIAEoCRITCgtleHBsYW5hdGlvbhgIIAEoCSJsCgRQYXRoEiIKBWVkZ2VzGAEgAygLMhMud2Vld2FyLnYxLlBhdGhFZGdlEiwKCmRpcmVjdGlvbnMYAiADKA4yGC53ZWV3YXIudjEuUGF0aERpcmVjdGlvbhISCgp0b3RhbF9jb3N0GAMgASgBKl8KDENyb3NzaW5nVHlwZRIdChlDUk9TU0lOR19UWVBFX1VOU1BFQ0lGSUVEEAASFgoSQ1JPU1NJTkdfVFlQRV9ST0FEEAESGAoUQ1JPU1NJTkdfVFlQRV9CUklER0UQAiqjAQoLVGVycmFpblR5cGUSHAoYVEVSUkFJTl9UWVBFX1VOU1BFQ0lGSUVEEAASFQoRVEVSUkFJTl9UWVBFX0NJVFkQARIXChNURVJSQUlOX1RZUEVfTkFUVVJFEAISFwoTVEVSUkFJTl9UWVBFX0JSSURHRRADEhYKElRFUlJBSU5fVFlQRV9XQVRFUhAEEhUKEVRFUlJBSU5fVFlQRV9ST0FEEAUqcQoKR2FtZVN0YXR1cxIbChdHQU1FX1NUQVRVU19VTlNQRUNJRklFRBAAEhcKE0dBTUVfU1RBVFVTX1BMQVlJTkcQARIWChJHQU1FX1NUQVRVU19QQVVTRUQQAhIVChFHQU1FX1NUQVRVU19FTkRFRBADKt4BCg1QYXRoRGlyZWN0aW9uEh4KGlBBVEhfRElSRUNUSU9OX1VOU1BFQ0lGSUVEEAASFwoTUEFUSF9ESVJFQ1RJT05fTEVGVBABEhsKF1BBVEhfRElSRUNUSU9OX1RPUF9MRUZUEAISHAoYUEFUSF9ESVJFQ1RJT05fVE9QX1JJR0hUEAMSGAoUUEFUSF9ESVJFQ1RJT05fUklHSFQQBBIfChtQQVRIX0RJUkVDVElPTl9CT1RUT01fUklHSFQQBRIeChpQQVRIX0RJUkVDVElPTl9CT1RUT01fTEVGVBAGQp8BCg1jb20ud2Vld2FyLnYxQgtNb2RlbHNQcm90b1ABWjxnaXRodWIuY29tL3R1cm5mb3JnZS93ZWV3YXIvZ2VuL2dvL3dlZXdhci92MS9tb2RlbHM7d2Vld2FydjGiAgNXWFiqAglXZWV3YXIuVjHKAglXZWV3YXJcVjHiAhVXZWV3YXJcVjFcR1BCTWV0YWRhdGHqAgpXZWV3YXI6OlYxYgZwcm90bzM", [file_google_protobuf_timestamp]);

/**
 * @generated from message weewar.v1.IndexInfo
 */
export type IndexInfo = Message<"weewar.v1.IndexInfo"> & {
  /**
   * We maintain an IndexInfo for each type of "indexing" operation needed
   * For example one update may change the keywords (so we need to update indexes for search)
   * Another might update the "units" so we may need a new screenshot
   * Each one's updates - updated and indexed timestamps separately so they can be tracked sepately
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 1;
   */
  lastUpdatedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_indexed_at = 2;
   */
  lastIndexedAt?: Timestamp;

  /**
   * @generated from field: bool needs_indexing = 3;
   */
  needsIndexing: boolean;
};

/**
 * Describes the message weewar.v1.IndexInfo.
 * Use `create(IndexInfoSchema)` to create a new message.
 */
export const IndexInfoSchema: GenMessage<IndexInfo> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 0);

/**
 * @generated from message weewar.v1.User
 */
export type User = Message<"weewar.v1.User"> & {
  /**
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * Unique ID for the user
   *
   * @generated from field: string id = 3;
   */
  id: string;

  /**
   * Name if items have names
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Description if user has a description
   *
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * Some tags
   *
   * @generated from field: repeated string tags = 6;
   */
  tags: string[];

  /**
   * A possible image url
   *
   * @generated from field: string image_url = 7;
   */
  imageUrl: string;

  /**
   * Difficulty - example attribute
   *
   * @generated from field: string difficulty = 8;
   */
  difficulty: string;
};

/**
 * Describes the message weewar.v1.User.
 * Use `create(UserSchema)` to create a new message.
 */
export const UserSchema: GenMessage<User> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 1);

/**
 * @generated from message weewar.v1.Pagination
 */
export type Pagination = Message<"weewar.v1.Pagination"> & {
  /**
   * *
   * Instead of an offset an abstract  "page" key is provided that offers
   * an opaque "pointer" into some offset in a result set.
   *
   * @generated from field: string page_key = 1;
   */
  pageKey: string;

  /**
   * *
   * If a pagekey is not supported we can also support a direct integer offset
   * for cases where it makes sense.
   *
   * @generated from field: int32 page_offset = 2;
   */
  pageOffset: number;

  /**
   * *
   * Number of results to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;
};

/**
 * Describes the message weewar.v1.Pagination.
 * Use `create(PaginationSchema)` to create a new message.
 */
export const PaginationSchema: GenMessage<Pagination> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 2);

/**
 * @generated from message weewar.v1.PaginationResponse
 */
export type PaginationResponse = Message<"weewar.v1.PaginationResponse"> & {
  /**
   * *
   * The key/pointer string that subsequent List requests should pass to
   * continue the pagination.
   *
   * @generated from field: string next_page_key = 2;
   */
  nextPageKey: string;

  /**
   * *
   * Also support an integer offset if possible
   *
   * @generated from field: int32 next_page_offset = 3;
   */
  nextPageOffset: number;

  /**
   * *
   * Whether theere are more results.
   *
   * @generated from field: bool has_more = 4;
   */
  hasMore: boolean;

  /**
   * *
   * Total number of results.
   *
   * @generated from field: int32 total_results = 5;
   */
  totalResults: number;
};

/**
 * Describes the message weewar.v1.PaginationResponse.
 * Use `create(PaginationResponseSchema)` to create a new message.
 */
export const PaginationResponseSchema: GenMessage<PaginationResponse> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 3);

/**
 * @generated from message weewar.v1.World
 */
export type World = Message<"weewar.v1.World"> & {
  /**
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * Version for Optimistic concurrent locking
   *
   * @generated from field: int64 version = 3;
   */
  version: bigint;

  /**
   * Unique ID for the world
   *
   * @generated from field: string id = 4;
   */
  id: string;

  /**
   * User that created the world
   *
   * @generated from field: string creator_id = 5;
   */
  creatorId: string;

  /**
   * Name if items have names
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * Description if world has a description
   *
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   * Some tags
   *
   * @generated from field: repeated string tags = 8;
   */
  tags: string[];

  /**
   * A possible image url
   *
   * @generated from field: string image_url = 9;
   */
  imageUrl: string;

  /**
   * Difficulty - example attribute
   *
   * @generated from field: string difficulty = 10;
   */
  difficulty: string;

  /**
   * URL to screenshot/preview image (defaults to /worlds/{id}/screenshots/{screenshotName})
   * Can be overridden to point to CDN or external hosting
   *
   * @generated from field: repeated string preview_urls = 11;
   */
  previewUrls: string[];

  /**
   * Default game configs
   *
   * @generated from field: weewar.v1.GameConfiguration default_game_config = 12;
   */
  defaultGameConfig?: GameConfiguration;

  /**
   * @generated from field: weewar.v1.IndexInfo search_index_info = 13;
   */
  searchIndexInfo?: IndexInfo;
};

/**
 * Describes the message weewar.v1.World.
 * Use `create(WorldSchema)` to create a new message.
 */
export const WorldSchema: GenMessage<World> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 4);

/**
 * @generated from message weewar.v1.WorldData
 */
export type WorldData = Message<"weewar.v1.WorldData"> & {
  /**
   * New map-based storage (key = "q,r" coordinate string)
   *
   * @generated from field: map<string, weewar.v1.Tile> tiles_map = 1;
   */
  tilesMap: { [key: string]: Tile };

  /**
   * @generated from field: map<string, weewar.v1.Unit> units_map = 2;
   */
  unitsMap: { [key: string]: Unit };

  /**
   * When this world data was updated (may have happened without world updating)
   *
   * @generated from field: weewar.v1.IndexInfo screenshot_index_info = 3;
   */
  screenshotIndexInfo?: IndexInfo;

  /**
   * We will only update if hash's are different
   *
   * @generated from field: string content_hash = 4;
   */
  contentHash: string;

  /**
   * Version for Optimistic concurrent locking
   *
   * @generated from field: int64 version = 5;
   */
  version: bigint;

  /**
   * Improvement layer - crossings (roads on land, bridges on water)
   *
   * key = "q,r", value = crossing with connectivity
   *
   * @generated from field: map<string, weewar.v1.Crossing> crossings = 8;
   */
  crossings: { [key: string]: Crossing };
};

/**
 * Describes the message weewar.v1.WorldData.
 * Use `create(WorldDataSchema)` to create a new message.
 */
export const WorldDataSchema: GenMessage<WorldData> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 5);

/**
 * Crossing with explicit connectivity data
 * Each crossing stores which of its 6 hex neighbors it connects to
 *
 * @generated from message weewar.v1.Crossing
 */
export type Crossing = Message<"weewar.v1.Crossing"> & {
  /**
   * @generated from field: weewar.v1.CrossingType type = 1;
   */
  type: CrossingType;

  /**
   * 6 booleans for hex neighbors in order matching AxialNeighborDeltas:
   * 0: LEFT (-1,0), 1: TOP_LEFT (0,-1), 2: TOP_RIGHT (1,-1),
   * 3: RIGHT (1,0), 4: BOTTOM_RIGHT (0,1), 5: BOTTOM_LEFT (-1,1)
   *
   * @generated from field: repeated bool connects_to = 2;
   */
  connectsTo: boolean[];
};

/**
 * Describes the message weewar.v1.Crossing.
 * Use `create(CrossingSchema)` to create a new message.
 */
export const CrossingSchema: GenMessage<Crossing> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 6);

/**
 * @generated from message weewar.v1.Tile
 */
export type Tile = Message<"weewar.v1.Tile"> & {
  /**
   * Q and R in Cubed coordinates
   *
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * Tile type
   *
   * @generated from field: int32 tile_type = 3;
   */
  tileType: number;

  /**
   * Whether the tile itself belongs to a player
   *
   * @generated from field: int32 player = 4;
   */
  player: number;

  /**
   * A short cut like A1 or S2 etc for quick access
   *
   * @generated from field: string shortcut = 5;
   */
  shortcut: string;

  /**
   * Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
   * This helps us not having to "top up" or "reset" the stats at the end
   * of each turn.  Instead as the game turn is incremented we can do a 
   * lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
   * So we just have to increment the game_turn and the unit is automaticaly flagged as
   * needing a top up of its health/balance/movement etc
   *
   * Which turn this unit was created/last acted on (ie movemade)
   *
   * @generated from field: int32 last_acted_turn = 6;
   */
  lastActedTurn: number;

  /**
   * When the last top up happened
   *
   * @generated from field: int32 last_toppedup_turn = 7;
   */
  lastToppedupTurn: number;
};

/**
 * Describes the message weewar.v1.Tile.
 * Use `create(TileSchema)` to create a new message.
 */
export const TileSchema: GenMessage<Tile> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 7);

/**
 * @generated from message weewar.v1.Unit
 */
export type Unit = Message<"weewar.v1.Unit"> & {
  /**
   * Q and R in Cubed coordinates
   *
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * @generated from field: int32 player = 3;
   */
  player: number;

  /**
   * @generated from field: int32 unit_type = 4;
   */
  unitType: number;

  /**
   * A short cut like A1 or S2 etc for quick access
   *
   * @generated from field: string shortcut = 5;
   */
  shortcut: string;

  /**
   * Runtime state fields
   *
   * Current health points
   *
   * @generated from field: int32 available_health = 6;
   */
  availableHealth: number;

  /**
   * Movement points remaining this turn
   *
   * @generated from field: double distance_left = 7;
   */
  distanceLeft: number;

  /**
   * Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
   * This helps us not having to "top up" or "reset" the stats at the end
   * of each turn.  Instead as the game turn is incremented we can do a 
   * lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
   * So we just have to increment the game_turn and the unit is automaticaly flagged as
   * needing a top up of its health/balance/movement etc
   *
   * Which turn this unit was created/last acted on (ie movemade)
   *
   * @generated from field: int32 last_acted_turn = 8;
   */
  lastActedTurn: number;

  /**
   * When the last top up happened
   *
   * @generated from field: int32 last_toppedup_turn = 9;
   */
  lastToppedupTurn: number;

  /**
   * Details around wound bonus tracking for this turn
   *
   * Total number of attacks received this turn
   *
   * @generated from field: int32 attacks_received_this_turn = 10;
   */
  attacksReceivedThisTurn: number;

  /**
   * Detailed attack history for wound bonus calculation
   *
   * @generated from field: repeated weewar.v1.AttackRecord attack_history = 11;
   */
  attackHistory: AttackRecord[];

  /**
   * Action progression tracking - index into UnitDefinition.action_order
   * Indicates which step in the action sequence the unit is currently on
   * Reset to 0 at turn start via TopUpUnitIfNeeded()
   *
   * @generated from field: int32 progression_step = 12;
   */
  progressionStep: number;

  /**
   * When current step has pipe-separated alternatives (e.g., "attack|capture"),
   * this tracks which alternative the user chose, preventing switching mid-step
   * Cleared when advancing to next step
   *
   * @generated from field: string chosen_alternative = 13;
   */
  chosenAlternative: string;
};

/**
 * Describes the message weewar.v1.Unit.
 * Use `create(UnitSchema)` to create a new message.
 */
export const UnitSchema: GenMessage<Unit> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 8);

/**
 * @generated from message weewar.v1.AttackRecord
 */
export type AttackRecord = Message<"weewar.v1.AttackRecord"> & {
  /**
   * Attacker's Q coordinate
   *
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * Attacker's R coordinate
   *
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * Whether attacker is ranged 2+ tiles away
   *
   * @generated from field: bool is_ranged = 3;
   */
  isRanged: boolean;

  /**
   * Which turn this attack occured
   *
   * @generated from field: int32 turn_number = 4;
   */
  turnNumber: number;
};

/**
 * Describes the message weewar.v1.AttackRecord.
 * Use `create(AttackRecordSchema)` to create a new message.
 */
export const AttackRecordSchema: GenMessage<AttackRecord> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 9);

/**
 * Rules engine terrain definition
 *
 * @generated from message weewar.v1.TerrainDefinition
 */
export type TerrainDefinition = Message<"weewar.v1.TerrainDefinition"> & {
  /**
   * Terrain type ID
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Display name (e.g., "Grass", "Mountain")  
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * double base_move_cost = 3;     // Base movement cost
   * double defense_bonus = 4;      // Defense bonus multiplier (0.0 to 1.0)
   *
   * Terrain category type
   *
   * @generated from field: int32 type = 5;
   */
  type: number;

  /**
   * Human-readable description
   *
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * How this terrain impacts 
   *
   * @generated from field: map<int32, weewar.v1.TerrainUnitProperties> unit_properties = 7;
   */
  unitProperties: { [key: number]: TerrainUnitProperties };

  /**
   * List of units that can be built on this terrain
   *
   * @generated from field: repeated int32 buildable_unit_ids = 8;
   */
  buildableUnitIds: number[];

  /**
   * @generated from field: int32 income_per_turn = 9;
   */
  incomePerTurn: number;
};

/**
 * Describes the message weewar.v1.TerrainDefinition.
 * Use `create(TerrainDefinitionSchema)` to create a new message.
 */
export const TerrainDefinitionSchema: GenMessage<TerrainDefinition> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 10);

/**
 * Rules engine unit definition  
 *
 * @generated from message weewar.v1.UnitDefinition
 */
export type UnitDefinition = Message<"weewar.v1.UnitDefinition"> & {
  /**
   * Unit type ID
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Display name (e.g., "Infantry", "Tank")
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Maximum health points
   *
   * @generated from field: int32 health = 4;
   */
  health: number;

  /**
   * how much it costs to build
   *
   * @generated from field: int32 coins = 5;
   */
  coins: number;

  /**
   * Maximum movement per turn
   *
   * @generated from field: double movement_points = 6;
   */
  movementPoints: number;

  /**
   * Movement points available after attacking
   *
   * @generated from field: double retreat_points = 7;
   */
  retreatPoints: number;

  /**
   * Base defense value
   *
   * @generated from field: int32 defense = 8;
   */
  defense: number;

  /**
   * Max Attack range in tiles
   *
   * @generated from field: int32 attack_range = 9;
   */
  attackRange: number;

  /**
   * Minimum attack range in tile radius if specified (otherwise - will be 1
   *
   * @generated from field: int32 min_attack_range = 10;
   */
  minAttackRange: number;

  /**
   * Splash damage amount
   *
   * @generated from field: int32 splash_damage = 11;
   */
  splashDamage: number;

  /**
   * @generated from field: map<int32, weewar.v1.TerrainUnitProperties> terrain_properties = 12;
   */
  terrainProperties: { [key: number]: TerrainUnitProperties };

  /**
   * Special properties/abilities
   *
   * @generated from field: repeated string properties = 13;
   */
  properties: string[];

  /**
   * Unit classification for attack calculations
   *
   * "Light", "Heavy", or "Stealth"
   *
   * @generated from field: string unit_class = 14;
   */
  unitClass: string;

  /**
   * "Air", "Land", or "Water"
   *
   * @generated from field: string unit_terrain = 15;
   */
  unitTerrain: string;

  /**
   * Attack table: base attack values against different unit classes
   * Key format: "Light:Air", "Heavy:Land", "Stealth:Water", etc.
   * Value 0 or missing key means "n/a" (cannot attack)
   *
   * @generated from field: map<string, int32> attack_vs_class = 16;
   */
  attackVsClass: { [key: string]: number };

  /**
   * Ordered list of allowed actions this turn
   * Examples:
   *   ["move", "attack"] - can move then attack
   *   ["move", "attack|capture"] - can move then either attack or capture
   *   ["attack"] - can only attack (no movement)
   * Default if empty: ["move", "attack|capture"]
   *
   * @generated from field: repeated string action_order = 17;
   */
  actionOrder: string[];

  /**
   * How many times each action type can be performed per turn
   * Key: action name, Value: max count
   * Example: {"attack": 2} means can attack twice
   * Default if not specified: 1 per action type
   *
   * @generated from field: map<string, int32> action_limits = 18;
   */
  actionLimits: { [key: string]: number };
};

/**
 * Describes the message weewar.v1.UnitDefinition.
 * Use `create(UnitDefinitionSchema)` to create a new message.
 */
export const UnitDefinitionSchema: GenMessage<UnitDefinition> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 11);

/**
 * Properties that are specific to unit on a particular terrain
 *
 * @generated from message weewar.v1.TerrainUnitProperties
 */
export type TerrainUnitProperties = Message<"weewar.v1.TerrainUnitProperties"> & {
  /**
   * Renamed from tile_id for clarity
   *
   * @generated from field: int32 terrain_id = 1;
   */
  terrainId: number;

  /**
   * @generated from field: int32 unit_id = 2;
   */
  unitId: number;

  /**
   * Movement cost for this unit on this terrain
   *
   * @generated from field: double movement_cost = 3;
   */
  movementCost: number;

  /**
   * How much healing per turn this tile would offer this unit
   *
   * @generated from field: int32 healing_bonus = 4;
   */
  healingBonus: number;

  /**
   * Whether this particular terrain can build this given unit
   *
   * @generated from field: bool can_build = 5;
   */
  canBuild: boolean;

  /**
   * Whether this particular unit can capture this terrain/building type
   *
   * @generated from field: bool can_capture = 6;
   */
  canCapture: boolean;

  /**
   * How much more attack this terrain gives to this unit
   *
   * @generated from field: int32 attack_bonus = 7;
   */
  attackBonus: number;

  /**
   * How much more defense this terrain gives to this unit
   *
   * @generated from field: int32 defense_bonus = 8;
   */
  defenseBonus: number;

  /**
   * Max Attack range in tiles
   *
   * @generated from field: int32 attack_range = 9;
   */
  attackRange: number;

  /**
   * Minimum attack range in tile radius if specified (otherwise - will be 1
   *
   * @generated from field: int32 min_attack_range = 10;
   */
  minAttackRange: number;
};

/**
 * Describes the message weewar.v1.TerrainUnitProperties.
 * Use `create(TerrainUnitPropertiesSchema)` to create a new message.
 */
export const TerrainUnitPropertiesSchema: GenMessage<TerrainUnitProperties> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 12);

/**
 * Properties for unit-vs-unit combat interactions
 *
 * @generated from message weewar.v1.UnitUnitProperties
 */
export type UnitUnitProperties = Message<"weewar.v1.UnitUnitProperties"> & {
  /**
   * @generated from field: int32 attacker_id = 1;
   */
  attackerId: number;

  /**
   * @generated from field: int32 defender_id = 2;
   */
  defenderId: number;

  /**
   * Optional attack override for this Attacker/Defender combo
   *
   * @generated from field: optional int32 attack_override = 3;
   */
  attackOverride?: number;

  /**
   * Optional defense override for this Attacker/Defender combo
   *
   * @generated from field: optional int32 defense_override = 4;
   */
  defenseOverride?: number;

  /**
   * @generated from field: weewar.v1.DamageDistribution damage = 5;
   */
  damage?: DamageDistribution;
};

/**
 * Describes the message weewar.v1.UnitUnitProperties.
 * Use `create(UnitUnitPropertiesSchema)` to create a new message.
 */
export const UnitUnitPropertiesSchema: GenMessage<UnitUnitProperties> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 13);

/**
 * Damage distribution for combat calculations
 *
 * @generated from message weewar.v1.DamageDistribution
 */
export type DamageDistribution = Message<"weewar.v1.DamageDistribution"> & {
  /**
   * @generated from field: double min_damage = 1;
   */
  minDamage: number;

  /**
   * @generated from field: double max_damage = 2;
   */
  maxDamage: number;

  /**
   * @generated from field: double expected_damage = 3;
   */
  expectedDamage: number;

  /**
   * @generated from field: repeated weewar.v1.DamageRange ranges = 4;
   */
  ranges: DamageRange[];
};

/**
 * Describes the message weewar.v1.DamageDistribution.
 * Use `create(DamageDistributionSchema)` to create a new message.
 */
export const DamageDistributionSchema: GenMessage<DamageDistribution> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 14);

/**
 * @generated from message weewar.v1.DamageRange
 */
export type DamageRange = Message<"weewar.v1.DamageRange"> & {
  /**
   * @generated from field: double min_value = 1;
   */
  minValue: number;

  /**
   * @generated from field: double max_value = 2;
   */
  maxValue: number;

  /**
   * @generated from field: double probability = 3;
   */
  probability: number;
};

/**
 * Describes the message weewar.v1.DamageRange.
 * Use `create(DamageRangeSchema)` to create a new message.
 */
export const DamageRangeSchema: GenMessage<DamageRange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 15);

/**
 * Main rules engine definition - centralized source of truth
 *
 * @generated from message weewar.v1.RulesEngine
 */
export type RulesEngine = Message<"weewar.v1.RulesEngine"> & {
  /**
   * Core entity definitions
   *
   * @generated from field: map<int32, weewar.v1.UnitDefinition> units = 1;
   */
  units: { [key: number]: UnitDefinition };

  /**
   * @generated from field: map<int32, weewar.v1.TerrainDefinition> terrains = 2;
   */
  terrains: { [key: number]: TerrainDefinition };

  /**
   * Centralized property definitions (source of truth)
   * Key format: "terrain_id:unit_id" (e.g., "1:3" for terrain 1, unit 3)
   *
   * @generated from field: map<string, weewar.v1.TerrainUnitProperties> terrain_unit_properties = 3;
   */
  terrainUnitProperties: { [key: string]: TerrainUnitProperties };

  /**
   * Key format: "attacker_id:defender_id" (e.g., "1:2" for unit 1 attacking unit 2)
   *
   * @generated from field: map<string, weewar.v1.UnitUnitProperties> unit_unit_properties = 4;
   */
  unitUnitProperties: { [key: string]: UnitUnitProperties };

  /**
   * Terrain type classifications (terrain_id -> TerrainType)
   * Used to determine if a terrain is city, nature, bridge, water, or road
   *
   * @generated from field: map<int32, weewar.v1.TerrainType> terrain_types = 5;
   */
  terrainTypes: { [key: number]: TerrainType };
};

/**
 * Describes the message weewar.v1.RulesEngine.
 * Use `create(RulesEngineSchema)` to create a new message.
 */
export const RulesEngineSchema: GenMessage<RulesEngine> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 16);

/**
 * Describes a game and its metadata
 *
 * @generated from message weewar.v1.Game
 */
export type Game = Message<"weewar.v1.Game"> & {
  /**
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * Version number for optimistic locking
   *
   * @generated from field: int64 version = 3;
   */
  version: bigint;

  /**
   * Unique ID for the game
   *
   * @generated from field: string id = 4;
   */
  id: string;

  /**
   * User who started/created the game
   *
   * @generated from field: string creator_id = 5;
   */
  creatorId: string;

  /**
   * The world this game was created from
   *
   * @generated from field: string world_id = 6;
   */
  worldId: string;

  /**
   * Name if items have names
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * Description if game has a description
   *
   * @generated from field: string description = 8;
   */
  description: string;

  /**
   * Some tags
   *
   * @generated from field: repeated string tags = 9;
   */
  tags: string[];

  /**
   * A possible image url
   *
   * @generated from field: string image_url = 10;
   */
  imageUrl: string;

  /**
   * Difficulty - example attribute
   *
   * @generated from field: string difficulty = 11;
   */
  difficulty: string;

  /**
   * Game configuration
   *
   * @generated from field: weewar.v1.GameConfiguration config = 12;
   */
  config?: GameConfiguration;

  /**
   * URL to screenshot/preview image (defaults to /games/{id}/screenshots/{screenshotName})
   * Can be overridden to point to CDN or external hosting
   *
   * @generated from field: repeated string preview_urls = 13;
   */
  previewUrls: string[];

  /**
   * @generated from field: weewar.v1.IndexInfo search_index_info = 15;
   */
  searchIndexInfo?: IndexInfo;
};

/**
 * Describes the message weewar.v1.Game.
 * Use `create(GameSchema)` to create a new message.
 */
export const GameSchema: GenMessage<Game> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 17);

/**
 * @generated from message weewar.v1.GameConfiguration
 */
export type GameConfiguration = Message<"weewar.v1.GameConfiguration"> & {
  /**
   * Player configuration
   *
   * @generated from field: repeated weewar.v1.GamePlayer players = 1;
   */
  players: GamePlayer[];

  /**
   * Team configuration
   *
   * @generated from field: repeated weewar.v1.GameTeam teams = 2;
   */
  teams: GameTeam[];

  /**
   * Various kinds of per turn income configs
   *
   * @generated from field: weewar.v1.IncomeConfig income_configs = 3;
   */
  incomeConfigs?: IncomeConfig;

  /**
   * Game settings
   *
   * @generated from field: weewar.v1.GameSettings settings = 4;
   */
  settings?: GameSettings;
};

/**
 * Describes the message weewar.v1.GameConfiguration.
 * Use `create(GameConfigurationSchema)` to create a new message.
 */
export const GameConfigurationSchema: GenMessage<GameConfiguration> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 18);

/**
 * @generated from message weewar.v1.IncomeConfig
 */
export type IncomeConfig = Message<"weewar.v1.IncomeConfig"> & {
  /**
   * How much starting coins to give each player
   *
   * @generated from field: int32 starting_coins = 1;
   */
  startingCoins: number;

  /**
   * Income each player just for being in the game
   *
   * @generated from field: int32 game_income = 2;
   */
  gameIncome: number;

  /**
   * Income from each landbase per turn
   *
   * @generated from field: int32 landbase_income = 3;
   */
  landbaseIncome: number;

  /**
   * Income from each navalbase per turn
   *
   * @generated from field: int32 navalbase_income = 4;
   */
  navalbaseIncome: number;

  /**
   * Income from each airport base per turn
   *
   * @generated from field: int32 airportbase_income = 5;
   */
  airportbaseIncome: number;

  /**
   * Income from each missile silo per turn
   *
   * @generated from field: int32 missilesilo_income = 6;
   */
  missilesiloIncome: number;

  /**
   * Income from each mine per turn
   *
   * @generated from field: int32 mines_income = 7;
   */
  minesIncome: number;
};

/**
 * Describes the message weewar.v1.IncomeConfig.
 * Use `create(IncomeConfigSchema)` to create a new message.
 */
export const IncomeConfigSchema: GenMessage<IncomeConfig> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 19);

/**
 * @generated from message weewar.v1.GamePlayer
 */
export type GamePlayer = Message<"weewar.v1.GamePlayer"> & {
  /**
   * Player ID (1-based)
   *
   * @generated from field: int32 player_id = 1;
   */
  playerId: number;

  /**
   * Player type
   *
   * "human", "ai", "open"
   *
   * @generated from field: string player_type = 2;
   */
  playerType: string;

  /**
   * Player color
   *
   * @generated from field: string color = 3;
   */
  color: string;

  /**
   * Team ID (0 = no team, 1+ = team number)
   *
   * @generated from field: int32 team_id = 4;
   */
  teamId: number;

  /**
   * Nickname for the player in this game
   *
   * @generated from field: string name = 5;
   */
  name: string;

  /**
   * Whether play is still in the game - can this just be inferred?
   *
   * @generated from field: bool is_active = 6;
   */
  isActive: boolean;

  /**
   * How many coins the player started off with
   *
   * @generated from field: int32 starting_coins = 7;
   */
  startingCoins: number;

  /**
   * Player's current money/coins balance for building units
   *
   * @generated from field: int32 coins = 8;
   */
  coins: number;
};

/**
 * Describes the message weewar.v1.GamePlayer.
 * Use `create(GamePlayerSchema)` to create a new message.
 */
export const GamePlayerSchema: GenMessage<GamePlayer> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 20);

/**
 * @generated from message weewar.v1.GameTeam
 */
export type GameTeam = Message<"weewar.v1.GameTeam"> & {
  /**
   * ID of the team within the game (unique to the game)
   *
   * @generated from field: int32 team_id = 1;
   */
  teamId: number;

  /**
   * Name of the team - in a game
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Just a color for this team
   *
   * @generated from field: string color = 3;
   */
  color: string;

  /**
   * Whether team has active players - can also be inferred
   *
   * @generated from field: bool is_active = 4;
   */
  isActive: boolean;
};

/**
 * Describes the message weewar.v1.GameTeam.
 * Use `create(GameTeamSchema)` to create a new message.
 */
export const GameTeamSchema: GenMessage<GameTeam> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 21);

/**
 * @generated from message weewar.v1.GameSettings
 */
export type GameSettings = Message<"weewar.v1.GameSettings"> & {
  /**
   * List of allowed unit type IDs
   *
   * @generated from field: repeated int32 allowed_units = 1;
   */
  allowedUnits: number[];

  /**
   * Turn time limit in seconds (0 = no limit)
   *
   * @generated from field: int32 turn_time_limit = 2;
   */
  turnTimeLimit: number;

  /**
   * Team mode
   *
   * "ffa" or "teams"
   *
   * @generated from field: string team_mode = 3;
   */
  teamMode: string;

  /**
   * Maximum number of turns (0 = unlimited)
   *
   * @generated from field: int32 max_turns = 4;
   */
  maxTurns: number;
};

/**
 * Describes the message weewar.v1.GameSettings.
 * Use `create(GameSettingsSchema)` to create a new message.
 */
export const GameSettingsSchema: GenMessage<GameSettings> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 22);

/**
 * Holds the game's Active/Current state (eg world state)
 *
 * @generated from message weewar.v1.GameState
 */
export type GameState = Message<"weewar.v1.GameState"> & {
  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * ID of the game whos state is being tracked
   *
   * @generated from field: string game_id = 3;
   */
  gameId: string;

  /**
   * @generated from field: int32 turn_counter = 4;
   */
  turnCounter: number;

  /**
   * @generated from field: int32 current_player = 5;
   */
  currentPlayer: number;

  /**
   * Current world state
   *
   * @generated from field: weewar.v1.WorldData world_data = 6;
   */
  worldData?: WorldData;

  /**
   * Current state hash for validation
   *
   * @generated from field: string state_hash = 8;
   */
  stateHash: string;

  /**
   * Version number for optimistic locking
   *
   * @generated from field: int64 version = 9;
   */
  version: bigint;

  /**
   * @generated from field: weewar.v1.GameStatus status = 10;
   */
  status: GameStatus;

  /**
   * Only set after a win has been possible
   *
   * @generated from field: bool finished = 11;
   */
  finished: boolean;

  /**
   * @generated from field: int32 winning_player = 12;
   */
  winningPlayer: number;

  /**
   * @generated from field: int32 winning_team = 13;
   */
  winningTeam: number;
};

/**
 * Describes the message weewar.v1.GameState.
 * Use `create(GameStateSchema)` to create a new message.
 */
export const GameStateSchema: GenMessage<GameState> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 23);

/**
 * Holds the game's move history (can be used as a replay log)
 *
 * @generated from message weewar.v1.GameMoveHistory
 */
export type GameMoveHistory = Message<"weewar.v1.GameMoveHistory"> & {
  /**
   * Move history for the game
   *
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  /**
   * Each entry in our history is a "group" of moves
   *
   * @generated from field: repeated weewar.v1.GameMoveGroup groups = 2;
   */
  groups: GameMoveGroup[];
};

/**
 * Describes the message weewar.v1.GameMoveHistory.
 * Use `create(GameMoveHistorySchema)` to create a new message.
 */
export const GameMoveHistorySchema: GenMessage<GameMoveHistory> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 24);

/**
 * A move group - we can allow X moves in one "tick"
 *
 * @generated from message weewar.v1.GameMoveGroup
 */
export type GameMoveGroup = Message<"weewar.v1.GameMoveGroup"> & {
  /**
   * When the moves happened (or were submitted)
   *
   * @generated from field: google.protobuf.Timestamp started_at = 2;
   */
  startedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp ended_at = 3;
   */
  endedAt?: Timestamp;

  /**
   * *
   * List of moves to add - 
   *
   * @generated from field: repeated weewar.v1.GameMove moves = 4;
   */
  moves: GameMove[];
};

/**
 * Describes the message weewar.v1.GameMoveGroup.
 * Use `create(GameMoveGroupSchema)` to create a new message.
 */
export const GameMoveGroupSchema: GenMessage<GameMoveGroup> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 25);

/**
 * *
 * Represents a single move which can be one of many actions in the game
 *
 * @generated from message weewar.v1.GameMove
 */
export type GameMove = Message<"weewar.v1.GameMove"> & {
  /**
   * The player making the move
   *
   * @generated from field: int32 player = 1;
   */
  player: number;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * @generated from oneof weewar.v1.GameMove.move_type
   */
  moveType: {
    /**
     * @generated from field: weewar.v1.MoveUnitAction move_unit = 4;
     */
    value: MoveUnitAction;
    case: "moveUnit";
  } | {
    /**
     * @generated from field: weewar.v1.AttackUnitAction attack_unit = 5;
     */
    value: AttackUnitAction;
    case: "attackUnit";
  } | {
    /**
     * @generated from field: weewar.v1.EndTurnAction end_turn = 6;
     */
    value: EndTurnAction;
    case: "endTurn";
  } | {
    /**
     * @generated from field: weewar.v1.BuildUnitAction build_unit = 7;
     */
    value: BuildUnitAction;
    case: "buildUnit";
  } | { case: undefined; value?: undefined };

  /**
   * A monotonically increasing and unique (within the game) sequence number for the move
   * This is generated by the server
   *
   * @generated from field: int64 sequence_num = 8;
   */
  sequenceNum: bigint;

  /**
   * Whether the result is permenant and can be undone.
   * Just moving a unit for example is not permanent, but attacking a unit
   * would be (ie a player cannot undo it).  This is also determined by the server/validator
   *
   * @generated from field: bool is_permanent = 9;
   */
  isPermanent: boolean;

  /**
   *
   * The corresponding "result" for the move.  This can be "proposed" or can be evaluated.
   * Keeping this colocated with the Move for consistency and simplicity
   *
   * @generated from field: repeated weewar.v1.WorldChange changes = 10;
   */
  changes: WorldChange[];
};

/**
 * Describes the message weewar.v1.GameMove.
 * Use `create(GameMoveSchema)` to create a new message.
 */
export const GameMoveSchema: GenMessage<GameMove> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 26);

/**
 * *
 * Move unit from one position to another
 *
 * @generated from message weewar.v1.MoveUnitAction
 */
export type MoveUnitAction = Message<"weewar.v1.MoveUnitAction"> & {
  /**
   * @generated from field: int32 from_q = 1;
   */
  fromQ: number;

  /**
   * @generated from field: int32 from_r = 2;
   */
  fromR: number;

  /**
   * @generated from field: int32 to_q = 3;
   */
  toQ: number;

  /**
   * @generated from field: int32 to_r = 4;
   */
  toR: number;

  /**
   * Optional fields that can be used for showing move options as well as debugging
   *
   * @generated from field: double movement_cost = 5;
   */
  movementCost: number;

  /**
   * Debug fields
   *
   * @generated from field: weewar.v1.Path reconstructed_path = 6;
   */
  reconstructedPath?: Path;
};

/**
 * Describes the message weewar.v1.MoveUnitAction.
 * Use `create(MoveUnitActionSchema)` to create a new message.
 */
export const MoveUnitActionSchema: GenMessage<MoveUnitAction> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 27);

/**
 * *
 * Attack with one unit against another
 *
 * @generated from message weewar.v1.AttackUnitAction
 */
export type AttackUnitAction = Message<"weewar.v1.AttackUnitAction"> & {
  /**
   * @generated from field: int32 attacker_q = 1;
   */
  attackerQ: number;

  /**
   * @generated from field: int32 attacker_r = 2;
   */
  attackerR: number;

  /**
   * @generated from field: int32 defender_q = 3;
   */
  defenderQ: number;

  /**
   * @generated from field: int32 defender_r = 4;
   */
  defenderR: number;

  /**
   * Optional fields for presenting during "options" and debugging
   *
   * @generated from field: int32 target_unit_type = 5;
   */
  targetUnitType: number;

  /**
   * @generated from field: int32 target_unit_health = 6;
   */
  targetUnitHealth: number;

  /**
   * @generated from field: bool can_attack = 7;
   */
  canAttack: boolean;

  /**
   * Estimated damage this attack would deal
   *
   * @generated from field: int32 damage_estimate = 8;
   */
  damageEstimate: number;
};

/**
 * Describes the message weewar.v1.AttackUnitAction.
 * Use `create(AttackUnitActionSchema)` to create a new message.
 */
export const AttackUnitActionSchema: GenMessage<AttackUnitAction> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 28);

/**
 * *
 * An action to build a unit (at a city tile)
 *
 * @generated from message weewar.v1.BuildUnitAction
 */
export type BuildUnitAction = Message<"weewar.v1.BuildUnitAction"> & {
  /**
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * @generated from field: int32 unit_type = 3;
   */
  unitType: number;

  /**
   * @generated from field: int32 cost = 4;
   */
  cost: number;
};

/**
 * Describes the message weewar.v1.BuildUnitAction.
 * Use `create(BuildUnitActionSchema)` to create a new message.
 */
export const BuildUnitActionSchema: GenMessage<BuildUnitAction> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 29);

/**
 * *
 * A move where a unit can capture a building
 *
 * @generated from message weewar.v1.CaptureBuildingAction
 */
export type CaptureBuildingAction = Message<"weewar.v1.CaptureBuildingAction"> & {
  /**
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * @generated from field: int32 tile_type = 3;
   */
  tileType: number;
};

/**
 * Describes the message weewar.v1.CaptureBuildingAction.
 * Use `create(CaptureBuildingActionSchema)` to create a new message.
 */
export const CaptureBuildingActionSchema: GenMessage<CaptureBuildingAction> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 30);

/**
 * *
 * End current player's turn
 *
 * No additional fields needed
 *
 * @generated from message weewar.v1.EndTurnAction
 */
export type EndTurnAction = Message<"weewar.v1.EndTurnAction"> & {
};

/**
 * Describes the message weewar.v1.EndTurnAction.
 * Use `create(EndTurnActionSchema)` to create a new message.
 */
export const EndTurnActionSchema: GenMessage<EndTurnAction> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 31);

/**
 * *
 * Represents a change to the game world
 *
 * @generated from message weewar.v1.WorldChange
 */
export type WorldChange = Message<"weewar.v1.WorldChange"> & {
  /**
   * When did this change happen
   *
   * @generated from oneof weewar.v1.WorldChange.change_type
   */
  changeType: {
    /**
     * @generated from field: weewar.v1.UnitMovedChange unit_moved = 1;
     */
    value: UnitMovedChange;
    case: "unitMoved";
  } | {
    /**
     * @generated from field: weewar.v1.UnitDamagedChange unit_damaged = 2;
     */
    value: UnitDamagedChange;
    case: "unitDamaged";
  } | {
    /**
     * @generated from field: weewar.v1.UnitKilledChange unit_killed = 3;
     */
    value: UnitKilledChange;
    case: "unitKilled";
  } | {
    /**
     * @generated from field: weewar.v1.PlayerChangedChange player_changed = 4;
     */
    value: PlayerChangedChange;
    case: "playerChanged";
  } | {
    /**
     * @generated from field: weewar.v1.UnitBuiltChange unit_built = 5;
     */
    value: UnitBuiltChange;
    case: "unitBuilt";
  } | {
    /**
     * @generated from field: weewar.v1.CoinsChangedChange coins_changed = 6;
     */
    value: CoinsChangedChange;
    case: "coinsChanged";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message weewar.v1.WorldChange.
 * Use `create(WorldChangeSchema)` to create a new message.
 */
export const WorldChangeSchema: GenMessage<WorldChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 32);

/**
 * *
 * A unit moved from one position to another
 *
 * @generated from message weewar.v1.UnitMovedChange
 */
export type UnitMovedChange = Message<"weewar.v1.UnitMovedChange"> & {
  /**
   * Complete unit state before the move
   *
   * @generated from field: weewar.v1.Unit previous_unit = 6;
   */
  previousUnit?: Unit;

  /**
   * Complete unit state after the move (includes updated position, distanceLeft, etc.)
   *
   * @generated from field: weewar.v1.Unit updated_unit = 7;
   */
  updatedUnit?: Unit;
};

/**
 * Describes the message weewar.v1.UnitMovedChange.
 * Use `create(UnitMovedChangeSchema)` to create a new message.
 */
export const UnitMovedChangeSchema: GenMessage<UnitMovedChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 33);

/**
 * *
 * A unit took damage
 *
 * @generated from message weewar.v1.UnitDamagedChange
 */
export type UnitDamagedChange = Message<"weewar.v1.UnitDamagedChange"> & {
  /**
   * Complete unit state before taking damage
   *
   * @generated from field: weewar.v1.Unit previous_unit = 6;
   */
  previousUnit?: Unit;

  /**
   * Complete unit state after taking damage
   *
   * @generated from field: weewar.v1.Unit updated_unit = 7;
   */
  updatedUnit?: Unit;
};

/**
 * Describes the message weewar.v1.UnitDamagedChange.
 * Use `create(UnitDamagedChangeSchema)` to create a new message.
 */
export const UnitDamagedChangeSchema: GenMessage<UnitDamagedChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 34);

/**
 * *
 * A unit was killed
 *
 * @generated from message weewar.v1.UnitKilledChange
 */
export type UnitKilledChange = Message<"weewar.v1.UnitKilledChange"> & {
  /**
   * Complete unit state before being killed
   *
   * @generated from field: weewar.v1.Unit previous_unit = 6;
   */
  previousUnit?: Unit;
};

/**
 * Describes the message weewar.v1.UnitKilledChange.
 * Use `create(UnitKilledChangeSchema)` to create a new message.
 */
export const UnitKilledChangeSchema: GenMessage<UnitKilledChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 35);

/**
 * *
 * Active player changed
 *
 * @generated from message weewar.v1.PlayerChangedChange
 */
export type PlayerChangedChange = Message<"weewar.v1.PlayerChangedChange"> & {
  /**
   * @generated from field: int32 previous_player = 1;
   */
  previousPlayer: number;

  /**
   * @generated from field: int32 new_player = 2;
   */
  newPlayer: number;

  /**
   * @generated from field: int32 previous_turn = 3;
   */
  previousTurn: number;

  /**
   * @generated from field: int32 new_turn = 4;
   */
  newTurn: number;

  /**
   * Units that had their movement/health reset for the new turn
   *
   * @generated from field: repeated weewar.v1.Unit reset_units = 5;
   */
  resetUnits: Unit[];
};

/**
 * Describes the message weewar.v1.PlayerChangedChange.
 * Use `create(PlayerChangedChangeSchema)` to create a new message.
 */
export const PlayerChangedChangeSchema: GenMessage<PlayerChangedChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 36);

/**
 * *
 * A new unit was built at a tile
 *
 * @generated from message weewar.v1.UnitBuiltChange
 */
export type UnitBuiltChange = Message<"weewar.v1.UnitBuiltChange"> & {
  /**
   * The newly created unit
   *
   * @generated from field: weewar.v1.Unit unit = 1;
   */
  unit?: Unit;

  /**
   * Tile coordinates where unit was built
   *
   * @generated from field: int32 tile_q = 2;
   */
  tileQ: number;

  /**
   * @generated from field: int32 tile_r = 3;
   */
  tileR: number;

  /**
   * Cost in coins
   *
   * @generated from field: int32 coins_cost = 4;
   */
  coinsCost: number;

  /**
   * Player's remaining coins after build
   *
   * @generated from field: int32 player_coins = 5;
   */
  playerCoins: number;
};

/**
 * Describes the message weewar.v1.UnitBuiltChange.
 * Use `create(UnitBuiltChangeSchema)` to create a new message.
 */
export const UnitBuiltChangeSchema: GenMessage<UnitBuiltChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 37);

/**
 * *
 * A player's coin balance changed
 *
 * @generated from message weewar.v1.CoinsChangedChange
 */
export type CoinsChangedChange = Message<"weewar.v1.CoinsChangedChange"> & {
  /**
   * Which player's coins changed
   *
   * @generated from field: int32 player_id = 1;
   */
  playerId: number;

  /**
   * Previous coin balance
   *
   * @generated from field: int32 previous_coins = 2;
   */
  previousCoins: number;

  /**
   * New coin balance
   *
   * @generated from field: int32 new_coins = 3;
   */
  newCoins: number;

  /**
   * Reason for change: "build", "income", "repair", etc.
   *
   * @generated from field: string reason = 4;
   */
  reason: string;
};

/**
 * Describes the message weewar.v1.CoinsChangedChange.
 * Use `create(CoinsChangedChangeSchema)` to create a new message.
 */
export const CoinsChangedChangeSchema: GenMessage<CoinsChangedChange> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 38);

/**
 * Compact representation of all reachable paths from a source
 *
 * @generated from message weewar.v1.AllPaths
 */
export type AllPaths = Message<"weewar.v1.AllPaths"> & {
  /**
   * Starting coordinate for all paths
   *
   * @generated from field: int32 source_q = 1;
   */
  sourceQ: number;

  /**
   * @generated from field: int32 source_r = 2;
   */
  sourceR: number;

  /**
   * Map of edges: key is "toQ,toR" for quick parent lookup
   * Each edge represents the optimal way to reach 'to' from its parent
   *
   * @generated from field: map<string, weewar.v1.PathEdge> edges = 3;
   */
  edges: { [key: string]: PathEdge };
};

/**
 * Describes the message weewar.v1.AllPaths.
 * Use `create(AllPathsSchema)` to create a new message.
 */
export const AllPathsSchema: GenMessage<AllPaths> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 39);

/**
 * A single edge in a path with movement details
 *
 * @generated from message weewar.v1.PathEdge
 */
export type PathEdge = Message<"weewar.v1.PathEdge"> & {
  /**
   * Parent coordinate Q
   *
   * @generated from field: int32 from_q = 1;
   */
  fromQ: number;

  /**
   * Parent coordinate R
   *
   * @generated from field: int32 from_r = 2;
   */
  fromR: number;

  /**
   * Destination coordinate Q
   *
   * @generated from field: int32 to_q = 3;
   */
  toQ: number;

  /**
   * Destination coordinate R
   *
   * @generated from field: int32 to_r = 4;
   */
  toR: number;

  /**
   * Cost to move from 'from' to 'to' (edge cost)
   *
   * @generated from field: double movement_cost = 5;
   */
  movementCost: number;

  /**
   * Total cumulative cost from source to 'to'
   *
   * @generated from field: double total_cost = 6;
   */
  totalCost: number;

  /**
   * e.g., "mountain", "plains", "forest"
   *
   * @generated from field: string terrain_type = 7;
   */
  terrainType: string;

  /**
   * e.g., "Mountain costs Soldier 4 movement points"
   *
   * @generated from field: string explanation = 8;
   */
  explanation: string;
};

/**
 * Describes the message weewar.v1.PathEdge.
 * Use `create(PathEdgeSchema)` to create a new message.
 */
export const PathEdgeSchema: GenMessage<PathEdge> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 40);

/**
 * Full path from source to destination (constructed on-demand from AllPaths)
 *
 * @generated from message weewar.v1.Path
 */
export type Path = Message<"weewar.v1.Path"> & {
  /**
   * Edges in order from source to destination
   *
   * @generated from field: repeated weewar.v1.PathEdge edges = 1;
   */
  edges: PathEdge[];

  /**
   * len(directions) = len(edges) - 1
   * and directions[i] = direction from edge[i - 1] -> edge[i]
   *
   * @generated from field: repeated weewar.v1.PathDirection directions = 2;
   */
  directions: PathDirection[];

  /**
   * Sum of all edge costs
   *
   * @generated from field: double total_cost = 3;
   */
  totalCost: number;
};

/**
 * Describes the message weewar.v1.Path.
 * Use `create(PathSchema)` to create a new message.
 */
export const PathSchema: GenMessage<Path> = /*@__PURE__*/
  messageDesc(file_weewar_v1_models_models, 41);

/**
 * Crossing types for terrain improvements (roads on land, bridges on water)
 *
 * @generated from enum weewar.v1.CrossingType
 */
export enum CrossingType {
  /**
   * @generated from enum value: CROSSING_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Road on land terrain
   *
   * @generated from enum value: CROSSING_TYPE_ROAD = 1;
   */
  ROAD = 1,

  /**
   * Bridge over water terrain
   *
   * @generated from enum value: CROSSING_TYPE_BRIDGE = 2;
   */
  BRIDGE = 2,
}

/**
 * Describes the enum weewar.v1.CrossingType.
 */
export const CrossingTypeSchema: GenEnum<CrossingType> = /*@__PURE__*/
  enumDesc(file_weewar_v1_models_models, 0);

/**
 * Terrain type classification - used for gameplay logic
 *
 * @generated from enum weewar.v1.TerrainType
 */
export enum TerrainType {
  /**
   * @generated from enum value: TERRAIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Player-owned structures (bases, hospitals, etc.)
   *
   * @generated from enum value: TERRAIN_TYPE_CITY = 1;
   */
  CITY = 1,

  /**
   * Neutral natural terrain (grass, mountains, etc.)
   *
   * @generated from enum value: TERRAIN_TYPE_NATURE = 2;
   */
  NATURE = 2,

  /**
   * Bridge crossings
   *
   * @generated from enum value: TERRAIN_TYPE_BRIDGE = 3;
   */
  BRIDGE = 3,

  /**
   * Water tiles
   *
   * @generated from enum value: TERRAIN_TYPE_WATER = 4;
   */
  WATER = 4,

  /**
   * Road tiles
   *
   * @generated from enum value: TERRAIN_TYPE_ROAD = 5;
   */
  ROAD = 5,
}

/**
 * Describes the enum weewar.v1.TerrainType.
 */
export const TerrainTypeSchema: GenEnum<TerrainType> = /*@__PURE__*/
  enumDesc(file_weewar_v1_models_models, 1);

/**
 * /////// Game related models
 *
 *
 * @generated from enum weewar.v1.GameStatus
 */
export enum GameStatus {
  /**
   * @generated from enum value: GAME_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: GAME_STATUS_PLAYING = 1;
   */
  PLAYING = 1,

  /**
   * @generated from enum value: GAME_STATUS_PAUSED = 2;
   */
  PAUSED = 2,

  /**
   * @generated from enum value: GAME_STATUS_ENDED = 3;
   */
  ENDED = 3,
}

/**
 * Describes the enum weewar.v1.GameStatus.
 */
export const GameStatusSchema: GenEnum<GameStatus> = /*@__PURE__*/
  enumDesc(file_weewar_v1_models_models, 2);

/**
 * @generated from enum weewar.v1.PathDirection
 */
export enum PathDirection {
  /**
   * @generated from enum value: PATH_DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PATH_DIRECTION_LEFT = 1;
   */
  LEFT = 1,

  /**
   * @generated from enum value: PATH_DIRECTION_TOP_LEFT = 2;
   */
  TOP_LEFT = 2,

  /**
   * @generated from enum value: PATH_DIRECTION_TOP_RIGHT = 3;
   */
  TOP_RIGHT = 3,

  /**
   * @generated from enum value: PATH_DIRECTION_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: PATH_DIRECTION_BOTTOM_RIGHT = 5;
   */
  BOTTOM_RIGHT = 5,

  /**
   * @generated from enum value: PATH_DIRECTION_BOTTOM_LEFT = 6;
   */
  BOTTOM_LEFT = 6,
}

/**
 * Describes the enum weewar.v1.PathDirection.
 */
export const PathDirectionSchema: GenEnum<PathDirection> = /*@__PURE__*/
  enumDesc(file_weewar_v1_models_models, 3);

